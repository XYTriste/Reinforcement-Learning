# 笔记

## 1. 将C++视为多个语言的联合

C++结合了许多不同编程知识的特性，例如我们只是想通过C++解决某个算法问题，此时我们应用在代码中时更多体现的是本身源自C的基础知识，我们几乎不需要用到模板、异常、重载等功能。而如果我们需要封装对象，在类的基础上进行操作，则是在C++中引入面向对象，等等。

之所以有这一条概念，是因为我们如果可以区分某些特性从哪儿来（用这个表达其实并不是很好，主要想表达的是，例如Java是面向对象的集大成者，我们可以认为C++中的类和对象就模仿了这一点，但是并不是说明面向对象是Java的首创）。

- C++高效编程守则视状况而变化，取决于你使用其中的哪一部分。

## 2. 尽量以const，enum，inline替换 #define

<font color="red">一言以蔽之，宁可使用编译器能够理解的，也不要使用预处理器。</font>`#define`作为宏甚至不被认为是语言的一部分。

例如我们有这样的定义：

```cpp
#define ASPECT_RATIO 1.655
```

由于宏仅仅是将代码中使用该宏的部分使用后面进行替换，这一过程可能在编译器编辑记号表之前就完成了。这样的后果就是编译器并不知道`ASPECT_RATIO`这个记号，假如在使用该宏的语句中出现了错误。我们可能会看到一个类似这样的错误（假设，实际上并没有这样的类型的报错）:

```cpp
error： expression xxx * 1.655
```

如果我们使用别人定义的头文件，而头文件中包含着类似的一个宏。那么程序中所有使用了该宏并报错的部分都会显示一个数字1.655，这将导致问题难以定位，因为我们并不知道这个1.655到底来自何处。

解决方式是使用`const`常量而非宏:

```cpp
const double ASPECT_RATIO = 1.655;
```

使用const时还有两种特殊的情况，<font color="green">第一种情况是声明指向常量的指针时：</font>

```cpp
const char* str = "hello";
```

此时的`const`实际上修饰的是`char`，也就是说我们定义了一个名为`str`的`*`类型（指针），它指向一个`const char`，这意味着我们不能通过指针修改它指向的字符的值，因为在编译器看来它指向的字符都是const的。但是可以修改指针指向的字符串，只是不能通过指针来修改字符串的内容。

如果要真正的声明一个指针常量，则应该：

```cpp
const char* const str = "hello";
```

这表示我们既不能修改指针指向什么内容，也不能通过指针本身来修改指向的内容的值。

<font color="green">第二种情况是class内的专属常量:</font>

```cpp
static const int NumTurns = 5;
```

如果说第一种情况仍算是情有可原，那么第二种情况就是`#define`完全无法胜任的了。由于宏没有作用域规则，所以无法使用它来定义一个专属于某个类的常量。而且宏作为非语言的部分，它也无法被修饰符修饰，因此我们无法对宏使用`static`以保证在创建类对象时仅存在一个常量副本。

此外，如果我们不希望用户使用指针或引用来指向我们定义的常量，则可以使用枚举类型来实现类似`const`的操作。因为枚举类型是不可变的，也是无法取地址的，它的行为更像是宏。

```cpp
class CostEstimate{
	private:
		enum {NumTurns = 5};
		int scores[NumTurns];
}
```

此外，旧式的实现中有尝试用宏来实现函数的功能:

```cpp
#define CALL_WITH_MAX(a, b) f((a) > (b) ? (a): (b))
```

这样的写法存在着诸多问题。如果想要编写针对不同类型的变量都能适用的函数，请使用模板。

- 对于单纯常量，最好以const或enum来替换`#define`
- 对于形似函数的宏，最好使用inline函数来替换`#define`。（提醒自己，`inline`声明是一种君子约定，即使我们将函数声明为`inline`的，最终该函数是否为内联的仍然由编译器决定）

## 3. 尽可能的使用const

<font color="red">如果`const`出现在指针或引用的`*`或`&`符号左边，说明被指的无法通过指针或引用修改。如果出现在右边则说明指针指向的变量不能修改（指向了A就不能再指向B了）。</font>

对于一个函数，尤其是类内的函数，尽可能的返回一个常量值。

考虑如下的有理数类：

```cpp
class Rational {...};
const Rational operator*(Rational& lhs, Rational& rhs);
```

如果我们不将返回值声明为`const`类型的，则可能会出现如下调用：

```cpp
Rational a, b, c;
a * b = c;
```

这显然不是我们想要的，因为我们将c赋值给了一个a*b的运算结果，这个结果是一个临时变量，没有记号来给予其意义，因此很快就会被销毁，也无法通过任何方式使用。

类似的，如果可能的话，我们需要将const关键字同样用在成员函数上。这样做有两个好处，首先，这使得我们的class接口容易被理解，通过const修饰我们可以知道有哪些函数可能对类的对象属性产生影响，而哪些肯定不会。这会使得我们在产生错误时定位问题更加容易。

第二，将成员函数定义为const的将使得我们更好的操作一个const对象。

成员函数如果是const，意味着什么？

这里有两个概念或观点：

"Bitwise constness" 和 "logical constness" 是与 C++ 中 const 成员函数的设计和语义相关的两个概念。

1. **Bitwise Constness（位常量性）**：
   - "Bitwise constness" 涉及到在 const 成员函数内部是否允许修改非静态数据成员的值，即在比特级别（bitwise）上是否允许改变对象的状态。
   - C++ 允许在 const 成员函数内修改对象的 mutable 成员变量，因此在这种情况下，"bitwise constness" 被打破，对象的状态在比特级别上是可变的。
   - 这种情况下，编译器仍然允许将该成员函数标记为 const，因为它不改变对象的外部可见状态，但在该成员函数内部，您可以改变一些内部状态。

```cpp
class MyClass {
public:
    void ConstFunc() const {
        // 修改mutable成员变量，违反了bitwise constness
        mutableVar = 42;
    }

private:
    mutable int mutableVar;
};
```

2. **Logical Constness（逻辑常量性）**：
   - "Logical constness" 更关注的是 const 成员函数的外部行为，即它们是否在逻辑上保持了对象的常量性。
   - "Logical constness" 要求 const 成员函数不会更改对象在外部可见的状态，即不会修改非静态数据成员的值。
   - 这种情况下，对象被视为在逻辑上是常量的，而不仅仅是在比特级别上是常量的。

```cpp
class MyClass {
public:
    int GetValue() const {
        // 逻辑上保持常量性，不修改非静态数据成员的值
        return value;
    }

private:
    int value;
};
```

总之，"bitwise constness" 强调了 const 成员函数内部是否可以修改对象的内部状态，而 "logical constness" 强调了 const 成员函数是否在逻辑上保持了对象的常量性，即是否不会修改外部可见的状态。通常，C++ 编程中更关注 "logical constness"，因为它涉及到对象的外部接口和可维护性。如果需要在 const 成员函数内部修改对象的状态，可以使用 mutable 成员变量来打破 "bitwise constness"，但需要小心使用，确保不会破坏 "logical constness"。

---

上面是GPT的回答，总结一下就是，const成员函数相当于我们对编译器做出了承诺，承诺不会在其中修改对象的成员属性。然而，如果成员属性中包含了指针，则即使在声明为const的成员函数中，我们仍然可以修改指针指向的值（只要指针不是const的）。const成员函数的声明仅仅只能保证不会修改成员指针指向的地址，而不能保证对应地址中的值不变。

由此也产生上面两个概念，到底是在地址级别上都不变（bitwise constness）才能称为const成员函数，还是说从逻辑上保持不变（logical constness）才能称为const成员函数呢？

- 将某些东西声明为const可帮助编译器侦测出错误用法。const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。
- 编译器强制实施`bitwise constness`，但是编写程序时应当遵守`logical constness`。
- 当const和non-const成员函数有着实质上等价的实现时，令non-const版本调用const版本可避免代码重复。（之所以不是const调用non-const版本，是因为在承诺了const的情况下不应该调用可能对对象做出改变的函数。事实上编译器会阻止这样的调用，即禁止在const成员函数中调用non-const成员函数）。

## 4. 确定对象被使用前已经被初始化

如果一个未初始化的值或者对象被使用，将会导致不确定的行为。

根据之前的经验，局部内置变量似乎不会自动进行初始化，而全局的内置类型则会默认初始化为0。然而，与其相信默认初始化以及它们可能带来的运行时成本，不如<font color="red">永远在使用对象之前将其初始化，而对无任何成员的内置类型同样手动完成此事。</font>

此外，不要混淆赋值和初始化的概念。假设我们有如下类:

```cpp
class Test{
	private:
		string name;
		int val;
	public:
		Test(const string& name, const int& val){
			this.name = name;
			this.val = val;
		}
}
```

那么在这个类中，构造函数实际上进行的是赋值而非初始化操作。

C++规定，类对象的成员变量初始化<font color="red">发生在进入构造函数本体之前。</font>例如对于成员变量`name`，初始化发生于<font color="red">`string`的默认构造函数调用之时。</font>而对于内置的`int`类型的`val`这一点则无法保证，初始化不保证一定在调用赋值之前使得`val`获得一个初始值。

值得注意的是，对象如果包含了成员变量是复合类型的话，则上述代码中的赋值操作实质上是调用了该成员的拷贝构造函数。那么对于一个复合类型的成员变量来说，上述代码实质调用了两次构造函数来使得它具有一个值：

1. 第一次，调用了该成员变量的默认构造函数，这使得成员变量被初始化。对于`string`类型来说，就是默认初始化成了一个空字符串`""`。
2. 第二次，在`Test`类的构造函数中调用了`this.name = name;`，这将导致调用`string`类型的拷贝构造函数。

显然，如果我们能够只进行一次拷贝构造函数调用，而不进行默认构造函数调用是更加高效的。只要我们能够保证我们并不需要用到它默认初始化的值即可。方法就是使用成员初始化列表：

```cpp
class Test{
	private:
		string name;
		int val;
	public:
		Test(const string& n, const int& v):name(n), val(v){
			// pass
		}
}
```

甚至如果想要通过默认构造函数来构造一个成员变量，也应该使用成员列表初始化语法，只要指定初始化时参数列表为空即可。

<font color="red">请记住一个规则，规则是总是在成员初始化列表中列出所有成员变量，以免还得记住哪些成员变量可以无需初始值。同时为了避免需要记住成员变量何时需要在成员初始列中初始化，何时不需要，最简单的做法就是总是使用成员初始化列表。</font>

### C++中的成员初始化次序

基类总是早于它的派生类进行初始化，而类的成员变量总是以其声明次序进行初始化。记住，<font color="red">当你在成员初始值列表中列出各个成员时，最好总是以其声明次序进行列出。</font>
