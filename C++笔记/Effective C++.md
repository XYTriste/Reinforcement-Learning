# 笔记

## 1. 将C++视为多个语言的联合

C++结合了许多不同编程知识的特性，例如我们只是想通过C++解决某个算法问题，此时我们应用在代码中时更多体现的是本身源自C的基础知识，我们几乎不需要用到模板、异常、重载等功能。而如果我们需要封装对象，在类的基础上进行操作，则是在C++中引入面向对象，等等。

之所以有这一条概念，是因为我们如果可以区分某些特性从哪儿来（用这个表达其实并不是很好，主要想表达的是，例如Java是面向对象的集大成者，我们可以认为C++中的类和对象就模仿了这一点，但是并不是说明面向对象是Java的首创）。

- C++高效编程守则视状况而变化，取决于你使用其中的哪一部分。

## 2. 尽量以const，enum，inline替换 #define

<font color="red">一言以蔽之，宁可使用编译器能够理解的，也不要使用预处理器。</font>`#define`作为宏甚至不被认为是语言的一部分。

例如我们有这样的定义：

```cpp
#define ASPECT_RATIO 1.655
```

由于宏仅仅是将代码中使用该宏的部分使用后面进行替换，这一过程可能在编译器编辑记号表之前就完成了。这样的后果就是编译器并不知道`ASPECT_RATIO`这个记号，假如在使用该宏的语句中出现了错误。我们可能会看到一个类似这样的错误（假设，实际上并没有这样的类型的报错）:

```cpp
error： expression xxx * 1.655
```

如果我们使用别人定义的头文件，而头文件中包含着类似的一个宏。那么程序中所有使用了该宏并报错的部分都会显示一个数字1.655，这将导致问题难以定位，因为我们并不知道这个1.655到底来自何处。

解决方式是使用`const`常量而非宏:

```cpp
const double ASPECT_RATIO = 1.655;
```

使用const时还有两种特殊的情况，<font color="green">第一种情况是声明指向常量的指针时：</font>

```cpp
const char* str = "hello";
```

此时的`const`实际上修饰的是`char`，也就是说我们定义了一个名为`str`的`*`类型（指针），它指向一个`const char`，这意味着我们不能通过指针修改它指向的字符的值，因为在编译器看来它指向的字符都是const的。但是可以修改指针指向的字符串，只是不能通过指针来修改字符串的内容。

如果要真正的声明一个指针常量，则应该：

```cpp
const char* const str = "hello";
```

这表示我们既不能修改指针指向什么内容，也不能通过指针本身来修改指向的内容的值。

<font color="green">第二种情况是class内的专属常量:</font>

```cpp
static const int NumTurns = 5;
```

如果说第一种情况仍算是情有可原，那么第二种情况就是`#define`完全无法胜任的了。由于宏没有作用域规则，所以无法使用它来定义一个专属于某个类的常量。而且宏作为非语言的部分，它也无法被修饰符修饰，因此我们无法对宏使用`static`以保证在创建类对象时仅存在一个常量副本。

此外，如果我们不希望用户使用指针或引用来指向我们定义的常量，则可以使用枚举类型来实现类似`const`的操作。因为枚举类型是不可变的，也是无法取地址的，它的行为更像是宏。

```cpp
class CostEstimate{
	private:
		enum {NumTurns = 5};
		int scores[NumTurns];
}
```

此外，旧式的实现中有尝试用宏来实现函数的功能:

```cpp
#define CALL_WITH_MAX(a, b) f((a) > (b) ? (a): (b))
```

这样的写法存在着诸多问题。如果想要编写针对不同类型的变量都能适用的函数，请使用模板。

- 对于单纯常量，最好以const或enum来替换`#define`
- 对于形似函数的宏，最好使用inline函数来替换`#define`。（提醒自己，`inline`声明是一种君子约定，即使我们将函数声明为`inline`的，最终该函数是否为内联的仍然由编译器决定）

## 3. 尽可能的使用const

<font color="red">如果`const`出现在指针或引用的`*`或`&`符号左边，说明被指的无法通过指针或引用修改。如果出现在右边则说明指针指向的变量不能修改（指向了A就不能再指向B了）。</font>

对于一个函数，尤其是类内的函数，尽可能的返回一个常量值。

考虑如下的有理数类：

```cpp
class Rational {...};
const Rational operator*(Rational& lhs, Rational& rhs);
```

如果我们不将返回值声明为`const`类型的，则可能会出现如下调用：

```cpp
Rational a, b, c;
a * b = c;
```

这显然不是我们想要的，因为我们将c赋值给了一个a*b的运算结果，这个结果是一个临时变量，没有记号来给予其意义，因此很快就会被销毁，也无法通过任何方式使用。

类似的，如果可能的话，我们需要将const关键字同样用在成员函数上。这样做有两个好处，首先，这使得我们的class接口容易被理解，通过const修饰我们可以知道有哪些函数可能对类的对象属性产生影响，而哪些肯定不会。这会使得我们在产生错误时定位问题更加容易。

第二，将成员函数定义为const的将使得我们更好的操作一个const对象。

成员函数如果是const，意味着什么？

这里有两个概念或观点：

"Bitwise constness" 和 "logical constness" 是与 C++ 中 const 成员函数的设计和语义相关的两个概念。

1. **Bitwise Constness（位常量性）**：
   - "Bitwise constness" 涉及到在 const 成员函数内部是否允许修改非静态数据成员的值，即在比特级别（bitwise）上是否允许改变对象的状态。
   - C++ 允许在 const 成员函数内修改对象的 mutable 成员变量，因此在这种情况下，"bitwise constness" 被打破，对象的状态在比特级别上是可变的。
   - 这种情况下，编译器仍然允许将该成员函数标记为 const，因为它不改变对象的外部可见状态，但在该成员函数内部，您可以改变一些内部状态。

```cpp
class MyClass {
public:
    void ConstFunc() const {
        // 修改mutable成员变量，违反了bitwise constness
        mutableVar = 42;
    }

private:
    mutable int mutableVar;
};
```

2. **Logical Constness（逻辑常量性）**：
   - "Logical constness" 更关注的是 const 成员函数的外部行为，即它们是否在逻辑上保持了对象的常量性。
   - "Logical constness" 要求 const 成员函数不会更改对象在外部可见的状态，即不会修改非静态数据成员的值。
   - 这种情况下，对象被视为在逻辑上是常量的，而不仅仅是在比特级别上是常量的。

```cpp
class MyClass {
public:
    int GetValue() const {
        // 逻辑上保持常量性，不修改非静态数据成员的值
        return value;
    }

private:
    int value;
};
```

总之，"bitwise constness" 强调了 const 成员函数内部是否可以修改对象的内部状态，而 "logical constness" 强调了 const 成员函数是否在逻辑上保持了对象的常量性，即是否不会修改外部可见的状态。通常，C++ 编程中更关注 "logical constness"，因为它涉及到对象的外部接口和可维护性。如果需要在 const 成员函数内部修改对象的状态，可以使用 mutable 成员变量来打破 "bitwise constness"，但需要小心使用，确保不会破坏 "logical constness"。

---

上面是GPT的回答，总结一下就是，const成员函数相当于我们对编译器做出了承诺，承诺不会在其中修改对象的成员属性。然而，如果成员属性中包含了指针，则即使在声明为const的成员函数中，我们仍然可以修改指针指向的值（只要指针不是const的）。const成员函数的声明仅仅只能保证不会修改成员指针指向的地址，而不能保证对应地址中的值不变。

由此也产生上面两个概念，到底是在地址级别上都不变（bitwise constness）才能称为const成员函数，还是说从逻辑上保持不变（logical constness）才能称为const成员函数呢？

- 将某些东西声明为const可帮助编译器侦测出错误用法。const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。
- 编译器强制实施`bitwise constness`，但是编写程序时应当遵守`logical constness`。
- 当const和non-const成员函数有着实质上等价的实现时，令non-const版本调用const版本可避免代码重复。（之所以不是const调用non-const版本，是因为在承诺了const的情况下不应该调用可能对对象做出改变的函数。事实上编译器会阻止这样的调用，即禁止在const成员函数中调用non-const成员函数）。

## 4. 确定对象被使用前已经被初始化

如果一个未初始化的值或者对象被使用，将会导致不确定的行为。

根据之前的经验，局部内置变量似乎不会自动进行初始化，而全局的内置类型则会默认初始化为0。然而，与其相信默认初始化以及它们可能带来的运行时成本，不如<font color="red">永远在使用对象之前将其初始化，而对无任何成员的内置类型同样手动完成此事。</font>

此外，不要混淆赋值和初始化的概念。假设我们有如下类:

```cpp
class Test{
	private:
		string name;
		int val;
	public:
		Test(const string& name, const int& val){
			this.name = name;
			this.val = val;
		}
}
```

那么在这个类中，构造函数实际上进行的是赋值而非初始化操作。

C++规定，类对象的成员变量初始化<font color="red">发生在进入构造函数本体之前。</font>例如对于成员变量`name`，初始化发生于<font color="red">`string`的默认构造函数调用之时。</font>而对于内置的`int`类型的`val`这一点则无法保证，初始化不保证一定在调用赋值之前使得`val`获得一个初始值。

值得注意的是，对象如果包含了成员变量是复合类型的话，则上述代码中的赋值操作实质上是调用了该成员的拷贝构造函数。那么对于一个复合类型的成员变量来说，上述代码实质调用了两次构造函数来使得它具有一个值：

1. 第一次，调用了该成员变量的默认构造函数，这使得成员变量被初始化。对于`string`类型来说，就是默认初始化成了一个空字符串`""`。
2. 第二次，在`Test`类的构造函数中调用了`this.name = name;`，这将导致调用`string`类型的拷贝构造函数。

显然，如果我们能够只进行一次拷贝构造函数调用，而不进行默认构造函数调用是更加高效的。只要我们能够保证我们并不需要用到它默认初始化的值即可。方法就是使用成员初始化列表：

```cpp
class Test{
	private:
		string name;
		int val;
	public:
		Test(const string& n, const int& v):name(n), val(v){
			// pass
		}
}
```

甚至如果想要通过默认构造函数来构造一个成员变量，也应该使用成员列表初始化语法，只要指定初始化时参数列表为空即可。

<font color="red">请记住一个规则，规则是总是在成员初始化列表中列出所有成员变量，以免还得记住哪些成员变量可以无需初始值。同时为了避免需要记住成员变量何时需要在成员初始列中初始化，何时不需要，最简单的做法就是总是使用成员初始化列表。</font>

### C++中的成员初始化次序

基类总是早于它的派生类进行初始化，而类的成员变量总是以其声明次序进行初始化。记住，<font color="red">当你在成员初始值列表中列出各个成员时，最好总是以其声明次序进行列出。</font>

然而，如果考虑到static修饰符修饰的变量或对象，则又是另一回事。

我们可以简单的将static修饰符修饰的变量或对象简单的分为两类。

第一类指的是在函数中声明的static，这样的static我们称为`local-static`，因为它的作用域处于函数之中，而对于函数而言该变量或对象的作用看上去像是一个`local-variable`。

第二类指的自然就是非函数中声明的static，它可以是在namespace作用域中，也可能是一个global变量或对象。这样的static我们称为`non-local-static`。

>  涉及到上述概念的一个问题是：假设我们包含了两个源代码文件，在其中一个文件中包含了一个`non-local-static`对象（例如数据库的`Connection`）。而在另一个源码文件中我们使用`extern`引入了这个对象并进行使用。然而在实际使用过程中，Connection对象可能尚未进行初始化。因为C++对不同源代码文件中的`non-local-static`对象的初始化顺序并没有定义。

<font color="red">也就是说，假设我们要将两个源文件一起编译并尝试执行。则我们必须保证Connection对象在使用前进行了初始化，或至少有某种办法处理没有初始化的情况。</font>

可能直觉上的想法就是我们在第一个文件中将Connection对象进行初始化，使其和某个数据库建立链接。但是这样肯定就失去了通用性，毕竟我们想要建立链接的不一定就是源码文件中链接的数据库，更可能的一种情况是我们的第一个文件是外部引入的，这样的初始化显然不可行。

所以解决办法就是，将`non-local-static`转换为`local-static`。

方法就是定义一个专有的函数，该函数中定义了一个`local-static`对象，并返回其引用。C++保证函数内的`local-static`对象在函数调用或首次遇到该对象的定义时创建该对象。这样就能够保证我们在使用该对象前一定对它进行了初始化。这样做的另一重好处就是如果你引入了某个源码文件，而并不是想要使用所有的`non-local-static`对象的话，则那些没有进行函数调用过的对象将不会进行构造和析构，节省了更多的成本。

- 为内置类型的变量进行手动初始化，C++并不保证初始化它们。
- 构造函数中最好使用成员初始化列表，而不要在构造函数中使用赋值操作。初始化列表中列出的成员变量应该和其声明时的次序相同。
- 为了免除“跨文件的初始化次序”问题，使用`local-static`对象来替代`non-local-static`对象。

## 5. 了解C++默认添加并调用的函数

如果类的创建者没有明确定义，则编译器会自动生成构造函数、析构函数、拷贝构造函数、拷贝赋值运算符这几个函数。这些函数都是public且inline的。

也就是说，如果你定义了一个空类(Empty class)，则该类将不具有任何属性。但也会有这四个函数。

默认的构造函数与析构函数将调用该类的父类的构造与析构函数以及`non-static`成员的构造与析构函数以完成一个对象的创建与销毁。

而默认的拷贝构造函数以及拷贝赋值运算符同样也只是简单的将`non-static`成员进行拷贝到目标对象。

<font color="red">然而，如果类的成员属性中包含了const或reference（引用），则编译器将不会为该类生成默认的拷贝构造函数和拷贝赋值运算符。</font>

原因很简单，默认的拷贝构造函数和拷贝赋值运算符都会将对象的`non-static`成员复制到目标对象，而不管是`const`还是`reference`，二者都是不可变的。如果希望对这样的类调用这些函数，则应该自定义它们。

另外一种情况是，如果某个类将拷贝赋值运算符（或拷贝构造函数）定义为private，则编译器也不会为其派生类生成对应的拷贝赋值运算符（或拷贝构造函数）。原因可以想象，派生类中的拷贝操作通常需要处理父类中的部分，而派生类是无法调用private的父类函数的。

- 编译器会为类创建默认构造函数、拷贝构造函数、拷贝赋值运算符以及析构函数。

## 6. 若不想使用编译器自动生成的函数，则应该声明其为删除的

在某些情况下，有些类我们并不想其具有某些操作。例如，如果某个类的每个对象都是一个独一无二的，我们也不希望出现“该类的两个对象的成员属性的值完全相同”的情况，则该类不应该具有拷贝构造或拷贝赋值的操作。

然而，默认编译器会生成这些函数，因此即使我们不去定义，编译器仍然会生成这些函数。这就与我们的初衷相悖。

一种解决方法就是声明这两个函数，但是定义为private的，这样在类外的作用域就无法调用该函数。但是在类内作用域呢？类的成员函数以及友元中仍然能够调用这个private函数。而且由于编译器无法在编译阶段了解你是否为一个函数提供了定义（因为函数定义可能在外部，或者别的文件中），因此在编写代码过程中IDE甚至不会对这样的调用报错。只有在链接阶段才会引发链接错误（没有找到函数的定义）。

解决上述问题的办法就是为其定义一个父类，并在父类中将这些函数定义为private。这样子类中生成的拷贝构造函数以及拷贝赋值运算符会尝试着调用父类的对应函数，而这样的操作会被编译器拒绝，继而引发编译错误而不是链接错误。

<font color="red">在C++11以及更高的版本，可以使用`delete`关键字将一个函数声明为删除的，编译器不会为删除的函数生成默认的对应函数。</font>

```cpp
class MyClass {
public:
    // 删除拷贝构造函数和拷贝赋值操作
    MyClass(const MyClass&) = delete;
    MyClass& operator=(const MyClass&) = delete;
    
    // 构造函数和其他成员函数
    // ...
};
```

- 为了拒绝编译器生成默认的函数，可以将相应的函数声明为private的，或创建一个类来帮助，或者使用delete关键字。

## 7. 为多态基类声明virtual析构函数

当我们使用一个基类指针指向一个派生类对象，然后调用 `delete` 来释放该指针指向的内存时，调用的是基类的析构函数。这是因为 C++ 默认情况下析构函数不是虚函数，它根据指针的静态类型（即基类）来决定调用哪个析构函数。

这可能会导致问题，特别是当派生类对象包含动态分配的资源（例如堆上分配的内存）时。如果只调用基类的析构函数，而不调用派生类的析构函数，那么派生类的资源可能无法正确释放，导致资源泄漏。

为了解决这个问题，通常会将基类的析构函数声明为虚函数。这样做将启用多态析构行为，确保在通过基类指针释放对象时，将调用正确的派生类析构函数，以正确释放资源。

```cpp
class Base {
public:
    virtual ~Base() {
        // 基类析构函数
    }
};

class Derived : public Base {
public:
    ~Derived() override {
        // 派生类析构函数
    }
};

int main() {
    Base* ptr = new Derived;
    delete ptr; // 调用Derived的析构函数
    return 0;
}
```

任何类只要带有一个virtual函数，通常情况下也需要有一个virtual析构函数。

> 当一个类拥有虚函数时，它通常意味着这个类是可继承的（可以作为其他类的基类）。这意味着其他类可以派生自这个类，并且您可能会使用基类指针或引用来操作派生类对象。
>
> 因此，为了确保在通过基类指针或引用释放派生类对象时调用正确的析构函数，通常建议在基类中声明一个虚析构函数。这确保了多态性和正确的资源管理，以避免资源泄漏。
>
> 总之，包含虚函数的类通常需要声明虚析构函数，以支持继承和多态性，并确保正确的对象销毁行为。这是一种良好的设计实践。

- 带有多态性质（也就是说基类指针指向派生类对象）的类应该声明一个virtual析构函数。
- 如果一个类并不打算作为基类使用，也不想具有多态性，则不应该声明virtual析构函数。

## 8. 别让异常逃离析构函数

假设我们定义了一个数据库连接的类：

```cpp
class DBConnection{
	public:
		...
		static DBConnection create();
		
		void close();
};
```

为了确保用户在使用完毕后记得调用close()函数来关闭数据库连接，实际过程中我们通常会创建一个该类的管理类，并在其析构函数中调用DBConnection的close()。

```cpp
class DBConn{
	public:
		...
		~DBConn(){
			db.close();
		}
	private:
		DBConnection db;
};
```

这样用户创建了一个`DBConn`类对象时可以正常使用`DBConnection`并在不再使用时通过析构函数中的调用正确的关闭数据库连接。

但是一个问题是，如果析构函数中的`db.close()`抛出了一个异常，数据库连接没有正确的关闭呢？异常会从析构函数中传出，继而引发未知的错误。

如何解决这个问题？通常有两种方式：

1. 如果close()抛出异常，那么结束程序，通常可以通过调用abort来完成：

```cpp
DBConn::~DBConn(){
	try{
		db.close();
	}catch(...){
		std::abort();
		/*
		`std::abort()` 是 C++ 标准库中的一个函数，它的作用是用来终止程序的执行，并生成一个异常终止信号。当调用 `std::abort()` 时，程序会立即终止，不再执行任何未完成的操作，也不会调用任何析构函数。

`std::abort()` 通常用于处理严重错误情况，例如在程序中检测到不可恢复的错误或安全漏洞时。它会导致程序非正常退出，并可能生成核心转储文件以供调试。核心转储文件包含了程序在崩溃时的内存状态，可用于分析问题。

一般情况下，`std::abort()` 应该小心使用，仅用于处理紧急错误情况，以确保程序在不安全或无法恢复的情况下能够优雅地退出。在正常情况下，应该使用异常处理或其他错误处理机制来处理错误。
		*/
	}
}
```

这样做将会在异常发生时立即结束程序，阻止异常从析构函数中传播出去。

2. 吞下close()调用发生的异常:

```cpp
DBConn::~DBConn(){
	try{
		db.close();
	}catch(...){
		//异常处理部分
	}
}
```

通常这样做并不好，因为我们可能无从得知发生了异常。这种情况下只有当程序在发生了异常仍然能够可靠执行的情况下，才是一个可行的方案。

---

一个更好的方案是重新设计`DBConn`接口，使得用户有机会对可能出现的问题进行处理：

```cpp
class DBConn{
	public:
		void close(){
			db.close()；
			closed = true;
		}
		~DBConn(){
			if(!closed){
                try{
                    db.close();
                }catch(...){
                    //异常处理部分
                }
            }
		}
	private:
		DBConnection db;
		bool closed;
};
```

在这样的情况下，用户创建`DBConn`的对象时，将会有机会手动关闭数据库连接并对可能发生的异常进行处理。即使用户忘记了关闭数据库连接，析构函数也会尝试对连接进行关闭并处理可能发生的异常。

这样做的好处是满足了用户自己处理异常的可能性，用户可以根据可能的异常自定义异常发生后的行为。

记住，<font color="red">如果某个操作可能在失败时抛出异常，而又存在某种需要必须处理这个异常。那么这个异常必须来自析构函数以外的某个函数。</font>

- 析构函数绝对不要抛出异常，如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后处理它们或结束程序，绝对不要进行传播。
- 如果用户需要对某个操作函数运行期间抛出的异常做出反应，那么类应该提供过一个普通的函数来提供该操作，以使得用户调用该函数并捕捉这个异常进行处理。

## 9. 绝不在构造和析构过程中调用virtual函数

假设我们自定义了一个基类，日志类，用来针对不同的类生成不同的日志。我们需要通过继承这个类来实现不同的类的日志记录。

```cpp
class Log{
	public:
		Log();
		virtual void logSomething() const = 0;
}
Log::Log(){
    //...
    logSomething();
}
```

现在，我们需要对某个线程的运行情况进行日志记录。因此我们继承Log类创建了一个类：

```cpp
class ProcessLog: public Log{
	public:
		virtual void logSomething() const; //记录日志的方法
}
```

显然，创建`ProcessLog`对象时会调用它的构造函数，但是基类的构造函数将会早于派生类的构造函数调用（这样做是为了保证派生类中的基类部分一定被正确的初始化）。然而，在`Log`类的构造函数中调用了`logSomething()`方法，这行调用将发生在`ProcessLog`类的对象调用自身的构造函数（派生类的构造函数）之前发生。要知道这意味着派生类自己拥有的属性还没有得到初始化，这样的行为将变得不安全。

再者，在派生类的构造函数调用基类的构造函数的期间，该派生类的对象将被视为一个基类对象。

同样的道理适用于析构函数。回顾一下，析构函数的调用顺序与构造函数正相反，当派生类对象被析构时，首先调用派生类的析构函数，然后再调用基类的析构函数。当派生类的析构函数开始调用时，派生类对象的成员变量将呈现未定义的值，调用成员函数可能会引发问题。

- 在构造和析构期间不要调用virtual函数，因为这类调用不会实际调用派生类实现的那个虚函数。

## 10. 令operator=返回一个对 *this 的引用

没有特别的理由，只是标准库以及STL中的实现都遵循它。

- 令赋值操作返回一个对 *this的引用

## 11. 在operator=中处理自我赋值

在编写代码的过程中，我们可能编写出自我赋值的代码：

```cpp
class Test{
	...
};
Test a;
a = a;
```

尽管在上述的例子中，这样的赋值似乎正常人都写不出来。但是当我们使用指针、引用等功能时，则可能意外的造成这种情况的出现。尤其是基类指针指向派生类对象的情况下，如果有以下代码：

```cpp
derived temp;
base *pointer = temp;
derived *d_pointer = temp;
*pointer = *d_pointer;
```

实际情况中这上面的几行代码可能分散在代码中的不同地方，有时候我们会忘记了给两个指针赋了相同的值。在这样的情况下，尽管是两个不同类型的指针，它们仍然可能具有相同的值。

这样做潜在可能造成的危险就在于，如果在`operator=`中需要对对象中的指针进行销毁并重新赋值的操作，则会造成错误：

```cpp
class Derived{
	public:
        ...
        Derived& Derived::operator=(const int& rhs){
			delete ptr;
			ptr = new int;
			*ptr = rhs;
        }
	private:
		int *ptr;
}
```

如果参数中的`rhs`和`ptr`实际上指向的是同一个对象的话，则第一行的`delete ptr`语句将会销毁ptr的同时也销毁了rhs引用指向的值。

想要解决这个问题，传统的方法就是在函数的前面加上“证同测试”：

```cpp
class Derived{
	public:
        ...
        Derived& Derived::operator=(const int& rhs){
        	if(this == &rhs){
        		return *this;
        	}
			delete ptr;
			ptr = new int;
			*ptr = rhs;
            return *this;
        }
	private:
		int *ptr;
}
```

然而，这样的代码仍然不具有异常安全性。考虑如果在`new`分配内存的过程中发生了异常（内存不足等），那么ptr将始终指向一块被删除的内存。这样是非常不安全的。

我们可以继续改写上述代码，如下所示：

```cpp
class Derived{
	public:
        ...
        Derived& Derived::operator=(const int& rhs){
        	int *temp = ptr;
        	ptr = new int;
        	*ptr = rhs;
        	delete temp;
        	return *this;
        }
	private:
		int *ptr;
}
```

在这段代码中，首先我们得到了一个当前指针的副本，然后我们使用当前指针去尝试得到一块新的内存来存放赋值操作得到的值。如果`new`操作成功了，则当前指针将会指向一个新的位置并存放赋值的值（不论这个值是不是它本身的值）。如果`new`操作抛出了一个异常，则不会执行后面的操作。ptr指向的内存也就不会被改变，也不会删除ptr指向的内存。

除此之外，还有一种称为`copy and swap`的技术，同样可以实现异常安全的操作：

```cpp
class Widget{
	...
	void swap(Widget &rhs);
	...
};
Widget& Widget::operator=(const Widget& rhs){
	Widget temp(rhs); // 创建要复制的对象的副本
	swap(temp);		  //将副本的值与调用对象的值进行交换
					  //副本（函数作用域的对象）被销毁
	return *this;
}
```

与之类似的是将`operator=`函数参数中的引用改为变量，这样在调用函数时就会直接从参数中得到一个关于赋值表达式右边的对象的副本。

- 确保当对象自我赋值时`operator=`具有良好的行为，常用的技术包括比较“来源对象”和“目标对象”的地址、在赋值成功前不要删除原对象、以及`copy and swap`等。
- 确定任何函数如果操作一个以上的对象，而其中多个对象是同一对象时，其行为仍然正确。

## 12. 复制对象时别忘记每一个成分

当我们定义类的拷贝构造函数以及类的拷贝赋值运算符时，我们通常会将对象的属性复制到另一个对象中去。然而，如果我们修改了类的定义呢？或者说，我们给类添加或删除了某个成员，在这样的条件下，类的构造函数、拷贝构造函数、拷贝赋值运算符、析构函数可能都需要进行修改。

如果我们忘记了修改这些函数，那么可能会造成对象中的成员没有赋值，继而在使用过程中引发不确定的错误。

更为糟糕的是，如果我们忘记了修改这些函数。那么该类的派生类的拷贝构造函数等几乎都会产生问题，派生类的拷贝构造函数通常需要在其内部调用基类的相应函数，以完成派生类的基类成员的赋值。这些基类成员通常对派生类而言是私有的，因此只能通过基类的相应函数调用来进行赋值。

当你编写一个拷贝函数（包括拷贝构造函数与拷贝赋值运算符）时，你需要记住：

1. 复制所有的local成员变量。
2. 调用所有基类内适当的拷贝函数

<font color="red">不应该在拷贝赋值运算符函数中调用拷贝构造函数，反之亦然。</font>

- 拷贝函数（包含拷贝构造函数以及拷贝赋值运算符等）应该确保复制“对象内的所有成员变量”以及“所有基类的成分”
- 不要尝试以某个拷贝函数实现另一个拷贝函数，应该将它们共同的部分放入某个私有成员函数中，并由两个函数共同调用。
