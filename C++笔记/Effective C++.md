# 笔记

## 1. 将C++视为多个语言的联合

C++结合了许多不同编程知识的特性，例如我们只是想通过C++解决某个算法问题，此时我们应用在代码中时更多体现的是本身源自C的基础知识，我们几乎不需要用到模板、异常、重载等功能。而如果我们需要封装对象，在类的基础上进行操作，则是在C++中引入面向对象，等等。

之所以有这一条概念，是因为我们如果可以区分某些特性从哪儿来（用这个表达其实并不是很好，主要想表达的是，例如Java是面向对象的集大成者，我们可以认为C++中的类和对象就模仿了这一点，但是并不是说明面向对象是Java的首创）。

- C++高效编程守则视状况而变化，取决于你使用其中的哪一部分。

## 2. 尽量以const，enum，inline替换 #define

<font color="red">一言以蔽之，宁可使用编译器能够理解的，也不要使用预处理器。</font>`#define`作为宏甚至不被认为是语言的一部分。

例如我们有这样的定义：

```cpp
#define ASPECT_RATIO 1.655
```

由于宏仅仅是将代码中使用该宏的部分使用后面进行替换，这一过程可能在编译器编辑记号表之前就完成了。这样的后果就是编译器并不知道`ASPECT_RATIO`这个记号，假如在使用该宏的语句中出现了错误。我们可能会看到一个类似这样的错误（假设，实际上并没有这样的类型的报错）:

```cpp
error： expression xxx * 1.655
```

如果我们使用别人定义的头文件，而头文件中包含着类似的一个宏。那么程序中所有使用了该宏并报错的部分都会显示一个数字1.655，这将导致问题难以定位，因为我们并不知道这个1.655到底来自何处。

解决方式是使用`const`常量而非宏:

```cpp
const double ASPECT_RATIO = 1.655;
```

使用const时还有两种特殊的情况，<font color="green">第一种情况是声明指向常量的指针时：</font>

```cpp
const char* str = "hello";
```

此时的`const`实际上修饰的是`char`，也就是说我们定义了一个名为`str`的`*`类型（指针），它指向一个`const char`，这意味着我们不能通过指针修改它指向的字符的值，因为在编译器看来它指向的字符都是const的。但是可以修改指针指向的字符串，只是不能通过指针来修改字符串的内容。

如果要真正的声明一个指针常量，则应该：

```cpp
const char* const str = "hello";
```

这表示我们既不能修改指针指向什么内容，也不能通过指针本身来修改指向的内容的值。

<font color="green">第二种情况是class内的专属常量:</font>

```cpp
static const int NumTurns = 5;
```

如果说第一种情况仍算是情有可原，那么第二种情况就是`#define`完全无法胜任的了。由于宏没有作用域规则，所以无法使用它来定义一个专属于某个类的常量。而且宏作为非语言的部分，它也无法被修饰符修饰，因此我们无法对宏使用`static`以保证在创建类对象时仅存在一个常量副本。

此外，如果我们不希望用户使用指针或引用来指向我们定义的常量，则可以使用枚举类型来实现类似`const`的操作。因为枚举类型是不可变的，也是无法取地址的，它的行为更像是宏。

```cpp
class CostEstimate{
	private:
		enum {NumTurns = 5};
		int scores[NumTurns];
}
```

此外，旧式的实现中有尝试用宏来实现函数的功能:

```cpp
#define CALL_WITH_MAX(a, b) f((a) > (b) ? (a): (b))
```

这样的写法存在着诸多问题。如果想要编写针对不同类型的变量都能适用的函数，请使用模板。

- 对于单纯常量，最好以const或enum来替换`#define`
- 对于形似函数的宏，最好使用inline函数来替换`#define`。（提醒自己，`inline`声明是一种君子约定，即使我们将函数声明为`inline`的，最终该函数是否为内联的仍然由编译器决定）

## 3. 尽可能的使用const

<font color="red">如果`const`出现在指针或引用的`*`或`&`符号左边，说明被指的无法通过指针或引用修改。如果出现在右边则说明指针指向的变量不能修改（指向了A就不能再指向B了）。</font>

对于一个函数，尤其是类内的函数，尽可能的返回一个常量值。

考虑如下的有理数类：

```cpp
class Rational {...};
const Rational operator*(Rational& lhs, Rational& rhs);
```

如果我们不将返回值声明为`const`类型的，则可能会出现如下调用：

```cpp
Rational a, b, c;
a * b = c;
```

这显然不是我们想要的，因为我们将c赋值给了一个a*b的运算结果，这个结果是一个临时变量，没有记号来给予其意义，因此很快就会被销毁，也无法通过任何方式使用。

类似的，如果可能的话，我们需要将const关键字同样用在成员函数上。这样做有两个好处，首先，这使得我们的class接口容易被理解，通过const修饰我们可以知道有哪些函数可能对类的对象属性产生影响，而哪些肯定不会。这会使得我们在产生错误时定位问题更加容易。

第二，将成员函数定义为const的将使得我们更好的操作一个const对象。

成员函数如果是const，意味着什么？

这里有两个概念或观点：

"Bitwise constness" 和 "logical constness" 是与 C++ 中 const 成员函数的设计和语义相关的两个概念。

1. **Bitwise Constness（位常量性）**：
   - "Bitwise constness" 涉及到在 const 成员函数内部是否允许修改非静态数据成员的值，即在比特级别（bitwise）上是否允许改变对象的状态。
   - C++ 允许在 const 成员函数内修改对象的 mutable 成员变量，因此在这种情况下，"bitwise constness" 被打破，对象的状态在比特级别上是可变的。
   - 这种情况下，编译器仍然允许将该成员函数标记为 const，因为它不改变对象的外部可见状态，但在该成员函数内部，您可以改变一些内部状态。

```cpp
class MyClass {
public:
    void ConstFunc() const {
        // 修改mutable成员变量，违反了bitwise constness
        mutableVar = 42;
    }

private:
    mutable int mutableVar;
};
```

2. **Logical Constness（逻辑常量性）**：
   - "Logical constness" 更关注的是 const 成员函数的外部行为，即它们是否在逻辑上保持了对象的常量性。
   - "Logical constness" 要求 const 成员函数不会更改对象在外部可见的状态，即不会修改非静态数据成员的值。
   - 这种情况下，对象被视为在逻辑上是常量的，而不仅仅是在比特级别上是常量的。

```cpp
class MyClass {
public:
    int GetValue() const {
        // 逻辑上保持常量性，不修改非静态数据成员的值
        return value;
    }

private:
    int value;
};
```

总之，"bitwise constness" 强调了 const 成员函数内部是否可以修改对象的内部状态，而 "logical constness" 强调了 const 成员函数是否在逻辑上保持了对象的常量性，即是否不会修改外部可见的状态。通常，C++ 编程中更关注 "logical constness"，因为它涉及到对象的外部接口和可维护性。如果需要在 const 成员函数内部修改对象的状态，可以使用 mutable 成员变量来打破 "bitwise constness"，但需要小心使用，确保不会破坏 "logical constness"。

---

上面是GPT的回答，总结一下就是，const成员函数相当于我们对编译器做出了承诺，承诺不会在其中修改对象的成员属性。然而，如果成员属性中包含了指针，则即使在声明为const的成员函数中，我们仍然可以修改指针指向的值（只要指针不是const的）。const成员函数的声明仅仅只能保证不会修改成员指针指向的地址，而不能保证对应地址中的值不变。

由此也产生上面两个概念，到底是在地址级别上都不变（bitwise constness）才能称为const成员函数，还是说从逻辑上保持不变（logical constness）才能称为const成员函数呢？

- 将某些东西声明为const可帮助编译器侦测出错误用法。const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。
- 编译器强制实施`bitwise constness`，但是编写程序时应当遵守`logical constness`。
- 当const和non-const成员函数有着实质上等价的实现时，令non-const版本调用const版本可避免代码重复。（之所以不是const调用non-const版本，是因为在承诺了const的情况下不应该调用可能对对象做出改变的函数。事实上编译器会阻止这样的调用，即禁止在const成员函数中调用non-const成员函数）。

## 4. 确定对象被使用前已经被初始化

如果一个未初始化的值或者对象被使用，将会导致不确定的行为。

根据之前的经验，局部内置变量似乎不会自动进行初始化，而全局的内置类型则会默认初始化为0。然而，与其相信默认初始化以及它们可能带来的运行时成本，不如<font color="red">永远在使用对象之前将其初始化，而对无任何成员的内置类型同样手动完成此事。</font>

此外，不要混淆赋值和初始化的概念。假设我们有如下类:

```cpp
class Test{
	private:
		string name;
		int val;
	public:
		Test(const string& name, const int& val){
			this.name = name;
			this.val = val;
		}
}
```

那么在这个类中，构造函数实际上进行的是赋值而非初始化操作。

C++规定，类对象的成员变量初始化<font color="red">发生在进入构造函数本体之前。</font>例如对于成员变量`name`，初始化发生于<font color="red">`string`的默认构造函数调用之时。</font>而对于内置的`int`类型的`val`这一点则无法保证，初始化不保证一定在调用赋值之前使得`val`获得一个初始值。

值得注意的是，对象如果包含了成员变量是复合类型的话，则上述代码中的赋值操作实质上是调用了该成员的拷贝构造函数。那么对于一个复合类型的成员变量来说，上述代码实质调用了两次构造函数来使得它具有一个值：

1. 第一次，调用了该成员变量的默认构造函数，这使得成员变量被初始化。对于`string`类型来说，就是默认初始化成了一个空字符串`""`。
2. 第二次，在`Test`类的构造函数中调用了`this.name = name;`，这将导致调用`string`类型的拷贝构造函数。

显然，如果我们能够只进行一次拷贝构造函数调用，而不进行默认构造函数调用是更加高效的。只要我们能够保证我们并不需要用到它默认初始化的值即可。方法就是使用成员初始化列表：

```cpp
class Test{
	private:
		string name;
		int val;
	public:
		Test(const string& n, const int& v):name(n), val(v){
			// pass
		}
}
```

甚至如果想要通过默认构造函数来构造一个成员变量，也应该使用成员列表初始化语法，只要指定初始化时参数列表为空即可。

<font color="red">请记住一个规则，规则是总是在成员初始化列表中列出所有成员变量，以免还得记住哪些成员变量可以无需初始值。同时为了避免需要记住成员变量何时需要在成员初始列中初始化，何时不需要，最简单的做法就是总是使用成员初始化列表。</font>

### C++中的成员初始化次序

基类总是早于它的派生类进行初始化，而类的成员变量总是以其声明次序进行初始化。记住，<font color="red">当你在成员初始值列表中列出各个成员时，最好总是以其声明次序进行列出。</font>

然而，如果考虑到static修饰符修饰的变量或对象，则又是另一回事。

我们可以简单的将static修饰符修饰的变量或对象简单的分为两类。

第一类指的是在函数中声明的static，这样的static我们称为`local-static`，因为它的作用域处于函数之中，而对于函数而言该变量或对象的作用看上去像是一个`local-variable`。

第二类指的自然就是非函数中声明的static，它可以是在namespace作用域中，也可能是一个global变量或对象。这样的static我们称为`non-local-static`。

>  涉及到上述概念的一个问题是：假设我们包含了两个源代码文件，在其中一个文件中包含了一个`non-local-static`对象（例如数据库的`Connection`）。而在另一个源码文件中我们使用`extern`引入了这个对象并进行使用。然而在实际使用过程中，Connection对象可能尚未进行初始化。因为C++对不同源代码文件中的`non-local-static`对象的初始化顺序并没有定义。

<font color="red">也就是说，假设我们要将两个源文件一起编译并尝试执行。则我们必须保证Connection对象在使用前进行了初始化，或至少有某种办法处理没有初始化的情况。</font>

可能直觉上的想法就是我们在第一个文件中将Connection对象进行初始化，使其和某个数据库建立链接。但是这样肯定就失去了通用性，毕竟我们想要建立链接的不一定就是源码文件中链接的数据库，更可能的一种情况是我们的第一个文件是外部引入的，这样的初始化显然不可行。

所以解决办法就是，将`non-local-static`转换为`local-static`。

方法就是定义一个专有的函数，该函数中定义了一个`local-static`对象，并返回其引用。C++保证函数内的`local-static`对象在函数调用或首次遇到该对象的定义时创建该对象。这样就能够保证我们在使用该对象前一定对它进行了初始化。这样做的另一重好处就是如果你引入了某个源码文件，而并不是想要使用所有的`non-local-static`对象的话，则那些没有进行函数调用过的对象将不会进行构造和析构，节省了更多的成本。

- 为内置类型的变量进行手动初始化，C++并不保证初始化它们。
- 构造函数中最好使用成员初始化列表，而不要在构造函数中使用赋值操作。初始化列表中列出的成员变量应该和其声明时的次序相同。
- 为了免除“跨文件的初始化次序”问题，使用`local-static`对象来替代`non-local-static`对象。

## 5. 了解C++默认添加并调用的函数

如果类的创建者没有明确定义，则编译器会自动生成构造函数、析构函数、拷贝构造函数、拷贝赋值运算符这几个函数。这些函数都是public且inline的。

也就是说，如果你定义了一个空类(Empty class)，则该类将不具有任何属性。但也会有这四个函数。

默认的构造函数与析构函数将调用该类的父类的构造与析构函数以及`non-static`成员的构造与析构函数以完成一个对象的创建与销毁。

而默认的拷贝构造函数以及拷贝赋值运算符同样也只是简单的将`non-static`成员进行拷贝到目标对象。

<font color="red">然而，如果类的成员属性中包含了const或reference（引用），则编译器将不会为该类生成默认的拷贝构造函数和拷贝赋值运算符。</font>

原因很简单，默认的拷贝构造函数和拷贝赋值运算符都会将对象的`non-static`成员复制到目标对象，而不管是`const`还是`reference`，二者都是不可变的。如果希望对这样的类调用这些函数，则应该自定义它们。

另外一种情况是，如果某个类将拷贝赋值运算符（或拷贝构造函数）定义为private，则编译器也不会为其派生类生成对应的拷贝赋值运算符（或拷贝构造函数）。原因可以想象，派生类中的拷贝操作通常需要处理父类中的部分，而派生类是无法调用private的父类函数的。

- 编译器会为类创建默认构造函数、拷贝构造函数、拷贝赋值运算符以及析构函数。

## 6. 若不想使用编译器自动生成的函数，则应该声明其为删除的

在某些情况下，有些类我们并不想其具有某些操作。例如，如果某个类的每个对象都是一个独一无二的，我们也不希望出现“该类的两个对象的成员属性的值完全相同”的情况，则该类不应该具有拷贝构造或拷贝赋值的操作。

然而，默认编译器会生成这些函数，因此即使我们不去定义，编译器仍然会生成这些函数。这就与我们的初衷相悖。

一种解决方法就是声明这两个函数，但是定义为private的，这样在类外的作用域就无法调用该函数。但是在类内作用域呢？类的成员函数以及友元中仍然能够调用这个private函数。而且由于编译器无法在编译阶段了解你是否为一个函数提供了定义（因为函数定义可能在外部，或者别的文件中），因此在编写代码过程中IDE甚至不会对这样的调用报错。只有在链接阶段才会引发链接错误（没有找到函数的定义）。

解决上述问题的办法就是为其定义一个父类，并在父类中将这些函数定义为private。这样子类中生成的拷贝构造函数以及拷贝赋值运算符会尝试着调用父类的对应函数，而这样的操作会被编译器拒绝，继而引发编译错误而不是链接错误。

<font color="red">在C++11以及更高的版本，可以使用`delete`关键字将一个函数声明为删除的，编译器不会为删除的函数生成默认的对应函数。</font>

```cpp
class MyClass {
public:
    // 删除拷贝构造函数和拷贝赋值操作
    MyClass(const MyClass&) = delete;
    MyClass& operator=(const MyClass&) = delete;
    
    // 构造函数和其他成员函数
    // ...
};
```

- 为了拒绝编译器生成默认的函数，可以将相应的函数声明为private的，或创建一个类来帮助，或者使用delete关键字。

## 7. 为多态基类声明virtual析构函数

当我们使用一个基类指针指向一个派生类对象，然后调用 `delete` 来释放该指针指向的内存时，调用的是基类的析构函数。这是因为 C++ 默认情况下析构函数不是虚函数，它根据指针的静态类型（即基类）来决定调用哪个析构函数。

这可能会导致问题，特别是当派生类对象包含动态分配的资源（例如堆上分配的内存）时。如果只调用基类的析构函数，而不调用派生类的析构函数，那么派生类的资源可能无法正确释放，导致资源泄漏。

为了解决这个问题，通常会将基类的析构函数声明为虚函数。这样做将启用多态析构行为，确保在通过基类指针释放对象时，将调用正确的派生类析构函数，以正确释放资源。

```cpp
class Base {
public:
    virtual ~Base() {
        // 基类析构函数
    }
};

class Derived : public Base {
public:
    ~Derived() override {
        // 派生类析构函数
    }
};

int main() {
    Base* ptr = new Derived;
    delete ptr; // 调用Derived的析构函数
    return 0;
}
```

任何类只要带有一个virtual函数，通常情况下也需要有一个virtual析构函数。

> 当一个类拥有虚函数时，它通常意味着这个类是可继承的（可以作为其他类的基类）。这意味着其他类可以派生自这个类，并且您可能会使用基类指针或引用来操作派生类对象。
>
> 因此，为了确保在通过基类指针或引用释放派生类对象时调用正确的析构函数，通常建议在基类中声明一个虚析构函数。这确保了多态性和正确的资源管理，以避免资源泄漏。
>
> 总之，包含虚函数的类通常需要声明虚析构函数，以支持继承和多态性，并确保正确的对象销毁行为。这是一种良好的设计实践。

- 带有多态性质（也就是说基类指针指向派生类对象）的类应该声明一个virtual析构函数。
- 如果一个类并不打算作为基类使用，也不想具有多态性，则不应该声明virtual析构函数。

## 8. 别让异常逃离析构函数

假设我们定义了一个数据库连接的类：

```cpp
class DBConnection{
	public:
		...
		static DBConnection create();
		
		void close();
};
```

为了确保用户在使用完毕后记得调用close()函数来关闭数据库连接，实际过程中我们通常会创建一个该类的管理类，并在其析构函数中调用DBConnection的close()。

```cpp
class DBConn{
	public:
		...
		~DBConn(){
			db.close();
		}
	private:
		DBConnection db;
};
```

这样用户创建了一个`DBConn`类对象时可以正常使用`DBConnection`并在不再使用时通过析构函数中的调用正确的关闭数据库连接。

但是一个问题是，如果析构函数中的`db.close()`抛出了一个异常，数据库连接没有正确的关闭呢？异常会从析构函数中传出，继而引发未知的错误。

如何解决这个问题？通常有两种方式：

1. 如果close()抛出异常，那么结束程序，通常可以通过调用abort来完成：

```cpp
DBConn::~DBConn(){
	try{
		db.close();
	}catch(...){
		std::abort();
		/*
		`std::abort()` 是 C++ 标准库中的一个函数，它的作用是用来终止程序的执行，并生成一个异常终止信号。当调用 `std::abort()` 时，程序会立即终止，不再执行任何未完成的操作，也不会调用任何析构函数。

`std::abort()` 通常用于处理严重错误情况，例如在程序中检测到不可恢复的错误或安全漏洞时。它会导致程序非正常退出，并可能生成核心转储文件以供调试。核心转储文件包含了程序在崩溃时的内存状态，可用于分析问题。

一般情况下，`std::abort()` 应该小心使用，仅用于处理紧急错误情况，以确保程序在不安全或无法恢复的情况下能够优雅地退出。在正常情况下，应该使用异常处理或其他错误处理机制来处理错误。
		*/
	}
}
```

这样做将会在异常发生时立即结束程序，阻止异常从析构函数中传播出去。

2. 吞下close()调用发生的异常:

```cpp
DBConn::~DBConn(){
	try{
		db.close();
	}catch(...){
		//异常处理部分
	}
}
```

通常这样做并不好，因为我们可能无从得知发生了异常。这种情况下只有当程序在发生了异常仍然能够可靠执行的情况下，才是一个可行的方案。

---

一个更好的方案是重新设计`DBConn`接口，使得用户有机会对可能出现的问题进行处理：

```cpp
class DBConn{
	public:
		void close(){
			db.close()；
			closed = true;
		}
		~DBConn(){
			if(!closed){
                try{
                    db.close();
                }catch(...){
                    //异常处理部分
                }
            }
		}
	private:
		DBConnection db;
		bool closed;
};
```

在这样的情况下，用户创建`DBConn`的对象时，将会有机会手动关闭数据库连接并对可能发生的异常进行处理。即使用户忘记了关闭数据库连接，析构函数也会尝试对连接进行关闭并处理可能发生的异常。

这样做的好处是满足了用户自己处理异常的可能性，用户可以根据可能的异常自定义异常发生后的行为。

记住，<font color="red">如果某个操作可能在失败时抛出异常，而又存在某种需要必须处理这个异常。那么这个异常必须来自析构函数以外的某个函数。</font>

- 析构函数绝对不要抛出异常，如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后处理它们或结束程序，绝对不要进行传播。
- 如果用户需要对某个操作函数运行期间抛出的异常做出反应，那么类应该提供过一个普通的函数来提供该操作，以使得用户调用该函数并捕捉这个异常进行处理。

## 9. 绝不在构造和析构过程中调用virtual函数

假设我们自定义了一个基类，日志类，用来针对不同的类生成不同的日志。我们需要通过继承这个类来实现不同的类的日志记录。

```cpp
class Log{
	public:
		Log();
		virtual void logSomething() const = 0;
}
Log::Log(){
    //...
    logSomething();
}
```

现在，我们需要对某个线程的运行情况进行日志记录。因此我们继承Log类创建了一个类：

```cpp
class ProcessLog: public Log{
	public:
		virtual void logSomething() const; //记录日志的方法
}
```

显然，创建`ProcessLog`对象时会调用它的构造函数，但是基类的构造函数将会早于派生类的构造函数调用（这样做是为了保证派生类中的基类部分一定被正确的初始化）。然而，在`Log`类的构造函数中调用了`logSomething()`方法，这行调用将发生在`ProcessLog`类的对象调用自身的构造函数（派生类的构造函数）之前发生。要知道这意味着派生类自己拥有的属性还没有得到初始化，这样的行为将变得不安全。

再者，在派生类的构造函数调用基类的构造函数的期间，该派生类的对象将被视为一个基类对象。

同样的道理适用于析构函数。回顾一下，析构函数的调用顺序与构造函数正相反，当派生类对象被析构时，首先调用派生类的析构函数，然后再调用基类的析构函数。当派生类的析构函数开始调用时，派生类对象的成员变量将呈现未定义的值，调用成员函数可能会引发问题。

- 在构造和析构期间不要调用virtual函数，因为这类调用不会实际调用派生类实现的那个虚函数。

## 10. 令operator=返回一个对 *this 的引用

没有特别的理由，只是标准库以及STL中的实现都遵循它。

- 令赋值操作返回一个对 *this的引用

## 11. 在operator=中处理自我赋值

在编写代码的过程中，我们可能编写出自我赋值的代码：

```cpp
class Test{
	...
};
Test a;
a = a;
```

尽管在上述的例子中，这样的赋值似乎正常人都写不出来。但是当我们使用指针、引用等功能时，则可能意外的造成这种情况的出现。尤其是基类指针指向派生类对象的情况下，如果有以下代码：

```cpp
derived temp;
base *pointer = temp;
derived *d_pointer = temp;
*pointer = *d_pointer;
```

实际情况中这上面的几行代码可能分散在代码中的不同地方，有时候我们会忘记了给两个指针赋了相同的值。在这样的情况下，尽管是两个不同类型的指针，它们仍然可能具有相同的值。

这样做潜在可能造成的危险就在于，如果在`operator=`中需要对对象中的指针进行销毁并重新赋值的操作，则会造成错误：

```cpp
class Derived{
	public:
        ...
        Derived& Derived::operator=(const int& rhs){
			delete ptr;
			ptr = new int;
			*ptr = rhs;
        }
	private:
		int *ptr;
}
```

如果参数中的`rhs`和`ptr`实际上指向的是同一个对象的话，则第一行的`delete ptr`语句将会销毁ptr的同时也销毁了rhs引用指向的值。

想要解决这个问题，传统的方法就是在函数的前面加上“证同测试”：

```cpp
class Derived{
	public:
        ...
        Derived& Derived::operator=(const int& rhs){
        	if(this == &rhs){
        		return *this;
        	}
			delete ptr;
			ptr = new int;
			*ptr = rhs;
            return *this;
        }
	private:
		int *ptr;
}
```

然而，这样的代码仍然不具有异常安全性。考虑如果在`new`分配内存的过程中发生了异常（内存不足等），那么ptr将始终指向一块被删除的内存。这样是非常不安全的。

我们可以继续改写上述代码，如下所示：

```cpp
class Derived{
	public:
        ...
        Derived& Derived::operator=(const int& rhs){
        	int *temp = ptr;
        	ptr = new int;
        	*ptr = rhs;
        	delete temp;
        	return *this;
        }
	private:
		int *ptr;
}
```

在这段代码中，首先我们得到了一个当前指针的副本，然后我们使用当前指针去尝试得到一块新的内存来存放赋值操作得到的值。如果`new`操作成功了，则当前指针将会指向一个新的位置并存放赋值的值（不论这个值是不是它本身的值）。如果`new`操作抛出了一个异常，则不会执行后面的操作。ptr指向的内存也就不会被改变，也不会删除ptr指向的内存。

除此之外，还有一种称为`copy and swap`的技术，同样可以实现异常安全的操作：

```cpp
class Widget{
	...
	void swap(Widget &rhs);
	...
};
Widget& Widget::operator=(const Widget& rhs){
	Widget temp(rhs); // 创建要复制的对象的副本
	swap(temp);		  //将副本的值与调用对象的值进行交换
					  //副本（函数作用域的对象）被销毁
	return *this;
}
```

与之类似的是将`operator=`函数参数中的引用改为变量，这样在调用函数时就会直接从参数中得到一个关于赋值表达式右边的对象的副本。

- 确保当对象自我赋值时`operator=`具有良好的行为，常用的技术包括比较“来源对象”和“目标对象”的地址、在赋值成功前不要删除原对象、以及`copy and swap`等。
- 确定任何函数如果操作一个以上的对象，而其中多个对象是同一对象时，其行为仍然正确。

## 12. 复制对象时别忘记每一个成分

当我们定义类的拷贝构造函数以及类的拷贝赋值运算符时，我们通常会将对象的属性复制到另一个对象中去。然而，如果我们修改了类的定义呢？或者说，我们给类添加或删除了某个成员，在这样的条件下，类的构造函数、拷贝构造函数、拷贝赋值运算符、析构函数可能都需要进行修改。

如果我们忘记了修改这些函数，那么可能会造成对象中的成员没有赋值，继而在使用过程中引发不确定的错误。

更为糟糕的是，如果我们忘记了修改这些函数。那么该类的派生类的拷贝构造函数等几乎都会产生问题，派生类的拷贝构造函数通常需要在其内部调用基类的相应函数，以完成派生类的基类成员的赋值。这些基类成员通常对派生类而言是私有的，因此只能通过基类的相应函数调用来进行赋值。

当你编写一个拷贝函数（包括拷贝构造函数与拷贝赋值运算符）时，你需要记住：

1. 复制所有的local成员变量。
2. 调用所有基类内适当的拷贝函数

<font color="red">不应该在拷贝赋值运算符函数中调用拷贝构造函数，反之亦然。</font>

- 拷贝函数（包含拷贝构造函数以及拷贝赋值运算符等）应该确保复制“对象内的所有成员变量”以及“所有基类的成分”
- 不要尝试以某个拷贝函数实现另一个拷贝函数，应该将它们共同的部分放入某个私有成员函数中，并由两个函数共同调用。

## 13. 以对象管理资源

假设我们创建了一个基类，名为`Investment`。随后，在该类中创建一个工厂函数（factory function）用于供应一个特定的`Investment`对象：

```cpp
class Investment{
	public:
        ...
        static Investment* createInvestment();
}
```

随后，用户在使用该类的过程中通常会编写这样的代码:

```cpp
int main(){
	Investment *ptr = Investment.createInvestment();
	...  //其他逻辑代码，业务处理等。
	delete ptr;
	return 0;
}
```

通常情况下这是正常的，但是如果在`...`语句块中发生了异常呢？或者一个意外的`return`导致函数提前结束了，这些情况都会使得`delete ptr`得不到合适的调用，继而引发内存泄漏。

如何解决这个问题呢？<font color="red">为了确保由`createInvestment`函数返回的资源得到释放，我们需要将资源放进对象内。当使用了`ptr`对象的函数结束时，类对象的析构函数将调用以自动释放资源。</font>

### auto_ptr

`auto_ptr`是由标准库中提供的一种类指针(pointer-like)对象，也是智能指针的一种。该类对象的析构函数调用时，也将自动对其所指向的对象调用`delete`。

因此改写后的代码如下:

```cpp
int main(){
	std::auto_ptr<Investment> ptr(createInvestment());
	...
	return 0;
}
```

由于`auto_ptr`在析构时会`delete`它所指向的对象资源，因此不要让多个`auto_ptr`指向同一个对象，否则会引发未知的错误。

此外，如果对`auto_ptr`调用拷贝构造或拷贝赋值运算符，则会将原`auto_ptr`指向的对象"传递"给新的`auto_ptr`，而原`auto_ptr`则会指向`null`。

<font color="red">上述的问题意味着`auto_ptr`并不是管理动态分配资源的好手段，尤其是在我们需要复制资源的情况下。比如STL容器通常要求对象拥有“正常的”复制行为，因此STL中容不下`auto_ptr`。</font>

### shared_ptr

`auto_ptr`的替代方案，则是引用计数型智能指针(reference-counting smart pointer，RCSP)。顾名思义，RCSP会持续追踪有多少个对象指向同一资源，且只有在没有对象指向该资源时才将资源释放。它的行为类似于垃圾回收，只有没人要的东西才被定义为垃圾并进行回收。缺点在于，它受到环状引用的限制，若两个RCSP互相指向对方所指向的对象，则引用计数始终存在，继而引发内存泄漏。

```cpp
#include <memory>

class Node {
public:
    std::shared_ptr<Node> next;

    Node() {
        std::cout << "Node created" << std::endl;
    }

    ~Node() {
        std::cout << "Node destroyed" << std::endl;
    }
};

int main() {
    std::shared_ptr<Node> node1 = std::make_shared<Node>();
    std::shared_ptr<Node> node2 = std::make_shared<Node>();

    // 形成环状引用
    node1->next = node2;
    node2->next = node1;

    // 引用计数不会降为零，内存泄漏
    return 0;
}
```

- 为了防止资源泄漏，请使用RAII（资源取得时即初始化，Resource Acquisition is Initialization）对象，它们在构造函数中获得资源并在析构函数中释放资源。
- 两个常被使用的RAII class分别是`auto_ptr`和`shared_ptr`。后者通常是更好的选择，因为其复制行为相较于`auto_ptr`更加"正常"。若选择`auto_ptr`，复制动作会使它指向null。

## 14. 在资源管理类中小心copying行为

有时候我们创建的类对象是复杂的，简单的使用智能指针进行资源管理可能非常麻烦。在这样的条件下，我们可能需要自定义一个资源管理类。

假设我们创建了一个互斥器类`Mutex`，并使用两个函数来锁定与解锁该类对象：

```cpp
void lock(Mutex* pm);
void unlock(Mutex* pm);
```

为了确保不会忘记解锁每一个被锁定的`Mutex`，我们可以建立一个class来管理锁定与解锁，该类遵循RAII守则，即“资源在构造期间获得，在析构期间释放”：

```cpp
class Lock{
	public:
		explicit Lock(Mutex* pm): mutexPtr(pm){
			lock(mutexPtr);
		}
		~Lock(){ unlock(mutexPtr); }
	private:
		Mutex *mutexPtr;
}
```

用户在使用过程中也符合RAII的方式:

```
Mutex m;
...
{	// 建立一个代码块用来定义临界区(critical section)
	Lock m1(&m);	// 锁定互斥器
	...				// 执行操作
}					//代码块结束，Lock的析构函数调用，释放互斥器的锁。
```

这样很不错，但是如果Lock对象被复制，会发生什么事？

```cpp
Lock m1(&m);
Lock m2(m1);
```

通常情况下对于这样的事情，我们有两种可能的处理方式：

1. 禁止复制：有时候允许RAII对象复制并不合理，例如对于Lock这样的类而言，通常不会拥有合理的"同步原语"（Synchronization Primitives）的副本。如果复制动作不合理，则应该将copying操作设置为private来阻止复制。
2. 对底层对象使用“引用计数”法：有时候我们希望保有资源，直到其最后一个使用者被销毁。这种情况下使用RAII对象时，应该将该资源的“被引用数”递增。因此可以使用`shared_ptr`。

​		如果前述的Lock想要使用引用计数，则需要改变`mutexPtr`的类型，将其改为`std::shared_ptr<Mutex>`。

然而，`shared_ptr`对象的默认行为是“当引用计数为0时删除其所指物”，那并不是我们希望锁所做的事。我们希望`shared_ptr`的析构动作是释放锁定而不是删除。

因此，我们需要对`shared_ptr`指定其删除器，删除器是一个函数或者函数对象，当引用计数为0时自动调用删除器。我们可以对`shared_ptr`提供第二个参数来指定其删除器：

```cpp
class Lock{
	public:
		explicit Lock(Mutex* pm): mutexPtr(pm, unlock){ //注意这里的成员列表初始化语句指定了第二个参数
			lock(mutexPtr.get());
		}
	private:
		std::shared_ptr<Mutex> *mutexPtr;
}
```

- 复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为。
- 普遍而常见的RAII class的copying行为是：抑制copying、使用引用计数法，不过其他行为可能也被实现。

## 15. 在资源管理类中提供对原始资源的访问

没太多能说的，字面意思。

- API往往要求访问原始资源，所以每一个RAII class应该提供一个“取得其所管理资源”的办法。
- 对原始资源的访问可能经由显式转换或隐式转换，一般而言显式转换更加安全，但是隐式转换对用户而言更加方便。

## 16.成对使用new和delete时要采取相同的形式

也没太多能说的，无非是new对象和new对象组成的数组时，需要分别使用delete和delete []进行释放。

- 如果你在new表达式中使用[]，必须在相应的delete表达式中也使用[]。如果你在new表达式中不使用[]，一定不要在相应的delete表达式中使用[]。

## 17. 将通过`new`创建的对象存储在独立的语句中的智能指针中。

假设我们创建了一个函数，该函数用来表明处理程序的优先权。另一个函数在动态分配所得的`Widget`上进行带有优先权的处理：

```cpp
int priority();
void processWidget(std::shared_ptr<Widget> pw, int priority);
```

现在考虑调用`processWidget`：

```cpp
processWidget(new Widget, priority());
```

事实上，这样的代码不能通过编译。因为`shared_ptr`类的构造函数声明是`explicit`的，因此无法通过创建`Widget`并隐式转换为智能指针的方式来传递参数。

以下代码可以通过编译:

```cpp
processWidget(std::shared_ptr<Widget>(new Widget), priority());
```

然而，上述代码可能造成内存泄漏。原因如下：

编译器在产生`processWidget`的实际调用之前，必须首先核算它的各个参数。上述调用的第二个参数是一个简单的函数调用，第一个语句则是由`std::shared_ptr<Widget>`和`new Widget`复合而成。

也就是说，在实际调用`processWidget`之前，还有这些事需要做：

1. 创建一个`Widget`对象，即`new Widget`。
2. 创建一个`shared_ptr`对象，即`std::shared_ptr<Widget>(new Widget)`。
3. 调用`priority()`函数。

C++中保证1一定会在2之前被调用，因为创建智能指针对象依赖于第1条语句。然而，对于函数`priority`的调用却并不一定排在创建智能指针后，C++中并不保证上述三件事一定按顺序执行。比如，可能产生如下的序列：

1. 创建一个`Widget`对象，即`new Widget`。
2. 调用`priority()`函数。
3. 创建一个`shared_ptr`对象，即`std::shared_ptr<Widget>(new Widget)`。

在这样的情况下，如果调用`priority()`函数过程中<font color="red">抛出</font>了异常，会发生什么事？注意这里的情况是抛出，如果`priority`函数能够处理这样的情况并正常返回，那么不会出现问题。但是如果抛出了异常，则`new Widget`返回的指针将无法被置入智能指针中，这部分的内存将会发生泄漏。

避免这样的问题的方法就是本知识点的主题，使用分离语句将通过`new`创建的对象存储在独立的语句中的智能指针中。

```cpp
std::shared_ptr<Widget> pw(new Widget);
processWidget(pw, priority());
```

- 以独立语句将通过new创建的对象存入智能指针内。如果不这样做，一旦异常被抛出，则可能导致难以察觉的资源泄漏。

## 18.让接口容易被正确使用，不易被误用

这部分内容看书更合适，写起来非常麻烦。

- 好的接口很容易被正确使用，不容易被误用。你应该在你的所有接口中努力达成这些性质。
- “促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容。
- “阻止误用”的办法包括建立新类型、限制类型上的操作、限定对象的值范围、以及消除客户的资源管理责任。
- shared_ptr支持自定义删除器，这可以防范DLL问题，可以用来自动解除互斥锁等等。

## 19. 设计class犹如设计type

同上述，都是文字内容，看书。

- class的设计就是type的设计。在定义一个新的type之前，请确定已经考虑过书中本条款覆盖的所有讨论主题。

## 20. 相较于pass-by-value，请偏向使用pass-by-reference-to-const

简而言之，如果我们在某个函数中使用对象的属性，但是我们无需对对象本身的属性进行修改时，尽量使用传递const引用的方式而不是传递值的方式。因为传值意味着调用对象的拷贝构造函数，这可能非常耗时。

- 尽量以pass-by-reference-to-const替代pass-by-value。前者通常比较高效，并可以避免父类引用指向子类对象引起的切割属性问题。
- 上述规则并不适用于内置类型，以及STL的迭代器和函数对象。对它们而言，pass-by-value往往更加妥当。

## 21.必须返回对象时，不要试图返回其引用

首先，任何函数如果返回一个指向函数内局部变量的引用。由于局部对象作用域结束后立即调用析构函数，因此引用将会指向一个无意义的区域，这样的引用显然是无用的。

其次，如果返回的是堆上分配的内存，即指针指向的内存呢？（指针指向的堆内存不受到函数作用域的影响）

```cpp
const Ref& operator*(const Ref& lhs, const Ref& rhs){
	...
	Ref *ptr = new Ref(lhs.n * rhs.n, lhs.d * rhs.d);
	return *ptr;
}
```

此时，函数可以正确的返回一个针对`*ptr`对象的引用。然而，我们无法对这样分配的内存进行delete。换句话说，在函数调用结束后，我们无法通过引用得到引用指向的那个指针，继而无法销毁这部分的内存。

更有趣的一件事是，我们能不能使用`static`变量来克服这个问题呢？

乍一看好像是可行的，首先static使得变量不受作用域的影响，因此无需考虑对象被析构的问题。其次static变量仍然处于栈内存中，因此无需像动态管理的堆内存那样进行手动分配和释放。

然而...

```cpp
const Ref& operator*(const Ref& lhs, const Ref& rhs){
	...
	static Ref result;
	result = ...;
	return result;
}
```

假设有这样的调用:

```cpp
Ref a, b, c, d;
if((a * b) == (c * d)){	//假设Ref类的==运算符已定义
	...
}else{
    ...
}
```

这样的调用结果将始终执行`if`语句的内容，也就是说`(a * b) == (c * d)`始终为真。

道理很简单，无论是==运算符的左边还是右边返回的都是引用。而且是针对同一个对象的匿名引用，因此这个表达式的结果始终为真。

总之，<font color="red">当你必须在返回一个reference和返回一个object之间进行抉择时，你的工作就是挑选行为正确的那个。</font>

- 绝不要返回指针和引用指向一个局部栈对象，或者返回一个指向堆分配的内存的引用，或者返回一个指向局部静态变量的指针或引用。

## 22. 将成员变量声明为private

首先，从语法一致性的角度来说。如果成员变量不是public，客户唯一能够访问对象的方法就是通过成员函数。如果public接口内的每样东西都是函数，客户就不需要在打算访问class成员时试着记住是否应该使用小括号了。

> "是否应该使用小括号" 这部分的意思是，当客户使用类的公有接口来访问类的成员时，客户需要调用类的方法（成员函数），并且在调用方法时需要使用小括号（即函数调用操作符）。这是因为方法实际上是通过函数来实现的。
>
> 举个例子，假设有一个类 `MyClass`，其中有一个公有方法 `doSomething()`，客户如果想要使用这个方法来执行某些操作，可以这样做：
>
> ```cpp
> MyClass myObject;  // 创建一个类的对象
> 
> // 调用 doSomething() 方法，需要使用小括号
> myObject.doSomething();
> ```
>
> 在这个例子中，`doSomething()` 是一个方法，客户必须使用小括号来调用它。这就是 "是否应该使用小括号" 这部分的含义，它强调了客户在使用类的公有接口时需要调用方法（使用小括号），而不是直接访问成员变量。这有助于保持接口的一致性和清晰性。

更重要的是，如果将成员变量声明为非private的，可能会破坏其封装性。

考虑一个修饰为public的成员变量，用户可能在任何地方修改它（包括用户自己编写的业务代码以及用户派生出的类中），如果类的创建者对该成员变量进行了修改（改名、改变其类型或别的操作），用户代码中任何涉及到该成员变量的部分可能都会遭到破坏。

protected成员变量同样如此，即使它在类外不可见。我们仍然无法阻止用户派生出一个类并修改这个变量的值。

只有通过private进行修饰的成员变量可以防止以上的问题，用户只能通过public成员函数间接的访问或者使用成员变量。即便因为功能上的调整类的创建者修改了成员变量，用户也几乎无需进行任何调整。

- 切记将成员变量声明为private。这可赋予客户访问数据的一致性、可细微划分访问控制、允诺约束条件得到保证，并给予类的创建者足够多的灵活性。
- protected并不比public更具有封装性。

## 23. 相较于成员函数，最好用非成员函数、非友元函数替代它

考虑一个用来表示网页浏览器的类:

```cpp
class WebBrowser{
	public:
		...
		void clearCache();
		void clearHistory();
		void removeCookies();
		...
};
```

假设用户希望使用该类来实现一个无痕访问的浏览器，那么在关闭浏览器时就需要调用上述三个函数。通常情况下有两种做法，将三个函数的调用作为一个成员函数，或作为一个非成员函数：

```cpp
class WebBrowser{
	public:
		...
		void clearEverything();
		...
};
or...
void clearBrowser(WebBrowser& wb){	//这是非成员函数
	wb.clearCache();
	wb.clearHistory();
	wb.removeCookies();
}
```

面向对象的守则告诉我们，数据以及操作数据的函数应该捆绑在一起。因此似乎使用成员函数的方法更好。

然而，这是对于面向对象封装思想的一个误解。将该函数作为成员函数会在一定程度上降低类的封装性。

考虑成员函数可以访问类的私有变量，如果我们为了这样的功能多去定义一个成员函数。那么该成员函数可能、或者说有机会访问到私有的成员变量。将该函数作为非成员函数则不会有这个问题。

<font color="red">但是，这并不意味着“对于该类成员函数进行调用的非成员函数，不能是其他类的成员函数”。</font>

针对友元函数也是同样的道理，友元函数是非成员函数，然而友元函数同样可以访问类的私有成员变量。因此使用友元函数来调用`WebBroswer`的成员函数的方式同样在一定程度上会破坏类的封装性。

- 宁愿以非成员 非友元函数来替换成员函数，这样做可以增加封装性、包装灵活性以及机能扩展性。

## 24. 若所有参数都需要类型转换，请为此采用非成员函数

考虑一个有理数类：

```cpp
class Rational{
	public:
		Rational(int numerator=0, int denominator = 1); // 构造函数没有声明explicit，即允许进行隐式类型转换
		int numerator() const;
		int denominator() const;
	private:
		...
};
```

很自然的，我们希望一个分数能够和一个整数进行加减乘除。假设我们想要实现分数和整数的相乘操作，实现一个`operator*`的成员函数版本:

```cpp
class Rational{
	public:
		...
		const Rational operator*(const Rational& rhs) const;
	private:
		...
};
```

此时我们可以轻松的将两个有理数相乘，并不会导致任何问题。但是，考虑如下调用：

```cpp
Rational result, oneHalf(1, 2);
result = oneHalf * 2;	//没问题
result = 2 * oneHalf;	//错误！
```

第二行没有问题的原因在于，由于我们提供了`Rational`类的`operator*`函数并提供了一个非`explicit`的构造函数。当我们尝试将2传递给`operator*`函数的形参时，会发生隐式类型转换。因此该调用仍然可以正常运行。

<<<<<<< HEAD
而第三行的问题在于，2作为了"承载成员函数`operator=*`调用的函数，也就是将2作为`this`来调用`this.operator*(oneHalf)`"。由于`2`很显然是一个内置类型`int`，因此不存在相应的重载`operator*`。更重要的是，这说明了C++不会为`this`调用隐式转换。

结论是，只有当参数位于参数列表中时，它才是一个隐式转换的参与者。而作为承载函数调用的`this`，它是一个隐喻式的参数，不在参数列表内，因此不参与隐式转换。

那么，如果我们不使用成员函数的版本，而是将`opeartor*`作为非成员函数进行重载呢？

```cpp
class Rational{
	...
};
const Rational operator*(const Rational& lhs, const Rational& rhs){
	return Rational(lhs.numerator() * rhs.numerator(),
					lhs.denominator() * rhs.demominator());
}
Rational oneFourth(1, 4);
Rational result;
result = oneFourth * 2;	//仍然没问题
result = 2 * oneFourth; //现在可以通过编译
```

一切大功告成了，现在可以正常的使用这个类了。

最后一个值得商榷的问题是，即使是非成员函数，`operator*`应该是`Rational`类的友元吗？

答案是否定的，一个函数是否应该成为类的友元，其<font color="red">决定性的因素在于，该函数内是否需要对类成员的数据进行修改操作等。</font>在上面这个例子中，`operator*`函数籍由`Rational`类的公有接口即可胜任工作。前面也提到过，友元会破坏一个类的封装性，因此在没有必要的情况下，不应该让这样的函数成为友元。

- 如果你需要为某个参数的所有参数(包括this指针指向的隐喻式参数)进行类型转换，那么这个函数必须是非成员函数。

## 25. 考虑写一个不抛异常的swap函数

首先，我们需要了解什么是全特化，什么是偏特化：
在C++中，模板特化是指为模板类型参数的特定值或范围提供自定义实现的机制。有两种主要类型的模板特化：全特化（full specialization）和偏特化（partial specialization）。

1. **全特化（Full Specialization）**：
   - 全特化是指为模板类型参数提供完全特定的实现。
   - 在全特化中，你为模板的每个类型参数都提供了一个具体的实现。
   - 通常用于处理模板参数的特殊情况，以提供高度定制的行为。
   - 例如，你可以为模板类创建完全特化的版本，以处理特定类型的数据。

```cpp
template <typename T>
class MyClass {
    // 通用实现
};

// 全特化的版本，处理 int 类型的参数
template <>
class MyClass<int> {
    // int 类型的定制实现
};
```

2. **偏特化（Partial Specialization）**：
   - 偏特化是指为模板类型参数的某些特定值或模式提供自定义实现。
   - 在偏特化中，你只特定了模板的某些部分，而不是全部。
   - 偏特化通常用于处理一类类型的参数，而不仅仅是一个特定的类型。
   - 例如，你可以为容器模板创建偏特化版本，以处理不同大小的容器。

```cpp
template <typename T, typename U>
class Pair {
    // 通用实现
};

// 偏特化的版本，处理包含指针的 Pair
template <typename T>
class Pair<T, T*> {
    // 处理包含指针的 Pair 的定制实现
};
```

总之，模板特化允许你为不同类型或模式的模板参数提供不同的实现，以满足特定的需求。全特化涵盖所有类型参数，而偏特化专注于一组类型参数或特定模式。

<font color="red">一言以蔽之，全特化指的就是如果我们的模板包含了3个模板类型（假设是T、A、B），我们将这三个模板类型全部指定为某个具体的类型（假设int、string、double），然后针对这三个具体类型提供一份模板类的实现。偏特化就是为其中部分模板类型提供具体类型，然后提供一份实现。</font>

<font color="blue">在C++中，类模板可以进行全特化和偏特化。而函数模板只能进行全特化。注意，类的成员函数是类的一部分，因此不要将类的成员函数认为是函数模板。</font>

> C++中的函数模板不能进行偏特化，这是语言规范的设计决策。函数模板的设计初衷是为了提供通用性和代码重用，而不是为了允许特定参数类型的偏特化。
>
> 函数模板的目的是在编译时生成通用的代码，可以用于不同的参数类型。偏特化会引入模板参数的局部修改，这会增加模板实例化的复杂性，并可能导致模板实例化的不一致性和困难。此外，C++语言设计者认为偏特化的需求可以通过函数重载、普通函数以及类模板的特化来满足，而不必引入函数模板的偏特化。
>
> 总之，C++中的函数模板不能进行偏特化，因为语言规范没有提供这个功能。如果需要根据特定的参数类型进行定制化的行为，可以使用函数重载或类模板的特化来实现。

在默认情况下，swap动作可以由标准库中提供的swap算法完成：

```cpp
namespace std{
	template<T>
	void swap(T& a, T& b){
		T temp(a);
		a = b;
		b = temp;
	}
}
```

只要类型T支持copying操作（拷贝构造以及拷贝赋值），默认的swap函数就可以应用于其上。

而假设某个类中包含大量数据呢？例如：

```cpp
class WidgetImpl{
	public:
		...
	private:
		int a, b, c;
		std::vector<int> v;
};
class Widget{
    public:
    	Widget(const Widget& rhs);
    	Widget& operator=(const Widget& rhs){
            ...
                *pImpl = *(rhs.pImpl);
            ...
        }
    	...
    private:
    	WidgetImpl *pImpl;
};
```

从代码中我们可以看出，如果我们想要交换两个`Widget`对象值，实际上只要交换两个指针指向的对象即可。但是默认的`swap`函数并不知道这一点，它会创建一个临时的`Widget`，然后按照默认的方式将内容复制过去，效率非常低。

为了解决这个问题，我们显然需要为我们的`Widget`类定制一个swap操作，这样的操作在C++中称为特化。准确来说：将std::swap针对Widget进行特化。

```cpp
namespace std{
	template<>
	void swap<Widget>(Widget &a, Widget &b){
		swap(a.pImpl, b.pImpl);
	}
}
```

这是<font color="red">std::swap针对`Widget`类的一个全特化版本</font>，但是这段代码无法通过编译，因为`pImpl`是类的私有属性，我们无法在类外部访问它。友元是一种可行的方式，但是还有更好的办法。

我们在`Widget`类中声明一个public成员函数做上述操作，然后令std::swap进行特化，调用该成员函数。

```cpp
class Widget{
    public:
    	void swap(Widget &other){
    		using std::swap;
    		swap(pImpl, other.pImpl);
    	}
    	...
    private:
    	WidgetImpl *pImpl;
};
namespace std{
	template<>
	void swap<Widget>(Widget &a, Widget &b){
		a.swap(b);
	}
}
```

上述代码即可实现针对类的std::swap特化，从而完成交换的操作。

但是，如果`Widget`以及`WidgetImpl`都是类模板，而不是具体的类呢？

```cpp
template<typename T>
class Widget{
	...
};
template<typename T>
class WidgetImpl{
	...
};
namespace std{
    template<typename T>
    void swap< Widget<T>>(Widget<T> &a, Widget<T> &b){
        a.swap(b);
    }
}
```

可能我们以为只要像上面这样改写特化的代码，为其加上模板即可。

然而，这段代码无法通过编译（有些编译器会让它通过，但是仍然是错误的），因为C++中不允许对函数模板进行偏特化（值得一提的是，函数模板偏特化似乎可以籍由函数重载做到类似的事）。

那么，如果我们不对std::swap进行特化，而只是简单的提供一份针对std::swap的函数重载呢？

```cpp
namespace std{
	template<typename T>
	void swap(Widget<T> &a, Widget<T> &b){	//注意swap后没有<>，这是函数重载而不是函数特化
		a.swap(b);
	}
}
```

这也是不行的，这段代码尝试将自定义的`swap`函数添加到`std`命名空间中，但C++标准禁止了在`std`命名空间中添加自定义函数或特化标准库的函数模板。这是为了防止与标准库产生冲突。

最终，解决办法是，我们还是声明一个非成员函数`swap`让它调用成员函数`swap`。但是不再将其声明为std::swap的特化或者重载版本：

```cpp
namespace WidgetStuff{	//注意，这里并非std命名空间，因此这里的swap并不是std::swap的重载
	...
	template<typename T>
	class Widget{...};
	...
	template<typename T>
	void swap(Widget<T>& a, Widget<T>& b){
		a.swap(b);
	}
}
```

这个做法对于类或者类模板都是行得通的，因此我们似乎应该采用这种方式。

<font color="red">然而，如果我们希望我们的“class专属版`swap`”尽可能多的语境下被调用，我们应该提供它的非成员函数版本以及std::swap特化版本。</font>

如果我们正在编写一个函数模板，并希望交换两个类的值，我们或许会编写如下代码：

```cpp
template<typename T>
void doSomething(T& obj1, T& obj2){
	using std::swap;
	...
	swap(obj1, obj2);
	...
}
```

编译器会查找适当的swap进行调用，如果针对类型T有具体的特化版本，且类型T以及特化版本所在的命名空间在该函数中“可见”。那么会优先调用特化版本，其次是非成员函数的版本（前提也是需要可见），如果找不到这些实现，那么最终会调用一般化的std::swap。

- 当std::swap针对你的类型效率不高时，提供一个swap成员函数，并确定该成员函数不抛出异常。
- 如果你提供一个成员函数swap，也该提供一个非成员函数swap来调用前者，对于类而非类模板，也请特化std::swap。
- 调用swap时应该针对std::swap使用using声明式，然后调用swap且不带任何“命名空间修饰”。
- 为“用户定义类型”进行std命名空间中的全特化是好的，但是不要尝试在std内加入任何东西（在std命名空间内提供std中的函数重载等）。

## 26. 尽可能延后变量定义式出现的时间

简而言之，如果我们有如下代码用于加密代码：

```cpp
std::string doSomething(std::string& password){ 
	std::string encrypted;
	if(password.length() < MinimumPasswordLength){
		throw logic_error("Password is too short");
	}
	...	//加密部分
	return encrypted;
}
```

那么，这段代码在运行过程中可能从未使用过变量`encrypted`就抛出异常退出了，这样就多余了一次对于string对象的构造和析构的成本。这个例子中仅仅是string对象，因此构造和析构的成本并不高，但是如果是自定义的类对象，构造和析构的成本可能非常昂贵。

如果改写成这样：

```
std::string doSomething(std::string& password){ 
	
	if(password.length() < MinimumPasswordLength){
		throw logic_error("Password is too short");
	}
	std::string encrypted;
	...	//加密部分
	return encrypted;
}
```

这样可以保证构造函数只有在必要的情况下调用，因此比前面的代码更加高效。

然而，`encrypted`最初虽然获得了定义，但是没有得到任何初值，这意味着调用的是默认构造函数。随后我们在加密过程中给`encrypted`赋值，条款4中也解释了这样做非常低效。

更合适的做法是调用拷贝构造函数:

```
std::string doSomething(std::string& password){ 
	
	if(password.length() < MinimumPasswordLength){
		throw logic_error("Password is too short");
	}
	std::string encrypted(password);
	...	//加密部分
	return encrypted;
}
```

这样调用拷贝构造函数来构造的方式，跳过了default构造函数的部分，使得代码更加高效。

上面的例子意味着，你不止应该延后变量的定义，直到使用变量的前一刻，甚至应该延后这份定义直到能够给它初值实参为止。

- 尽可能延后变量定义式的出现。这样做可以增加程序的清晰度并改善程序效率。

## 27. 尽量少做转型动作

理由很简单，转型很有可能导致代码带来错误的操作。

- 如果可以，尽量避免转型，特别是在注重效率的代码中避免`dynamic_cast`。如果有个设计需要转型动作，试着发展无需转型的替代设计。
- 如果转型是必要的，试着将它隐藏于某个函数背后。客户随后可以调用该函数，而不需要将转型放进它们自己的代码内。
- 宁可使用C++ style（新式）转型，不要使用旧式转型。前者很容易辨识出来，而且也比较有着分门别类的功能。

## 28. 避免返回handles指向对象内部成分
这一条款主要针对的是防止由于返回引用致使本身private的成员属性意外的遭到外部修改，例如：

```cpp
class Triangle{
	private:
		int a, b, c;
	public:
		...
		int& ReturnASize() const{
			return a;
		}
}
```

尽管我们期望的是返回三角形的某条边长，但是返回这样的引用很可能导致用户错误的去修改它的值。如果我们返回一个指针或者迭代器，同样的事情仍然会发生。同时尽管我们在函数后面加上了const，我们其实没有做到我们所说的承诺，原因也是因为我们可以通过这样的调用修改变量`a`的值。

这个问题的解决方案也很简单，那就是在返回类型前加上`const`修饰符，使其返回值仅可读而不可写。这样做只在一定程度上降低了封装性，但是并不会导致封装性被破坏。

另外一点值得注意的是，正如条款21所提到的问题，返回引用可能导致我们不小心编写出返回一个局部对象的引用，或者返回一个被析构的对象的代码，这将导致空悬引用。

不论如何，返回一个“指向对象内部成分的handles”总是危险的，尽管有时我们可能必须这么做（比如`string`类的`at`成员函数），所以我们需要小心使用它。

- 避免返回handles（包括引用、指针、迭代器）指向对象内部。遵守这个条款可增加封装性，帮助const成员函数的行为像个const，并将发生“悬垂handles”的可能性降至最低。

## 29. 为“异常安全”而努力是值得的

这里涉及到了异常安全的基本承诺、强烈保证以及不抛出异常的承诺。

通常情况下，我们需要在代码的异常安全性和代码效率方面做取舍。例如书中提到的`copy and swap`策略，就是在每次更改对象时首先创建一个对象副本，然后在副本上进行所有操作。最后再将副本中的数据复制到原对象中（注意，条款25提醒我们写一个不抛异常的swap，因此我们可以假设swap操作不会抛出异常）。这样做的好处就是如果我们在构造副本、修改副本的过程中出现任何异常，原对象不会有任何变化，保持函数调用前的状态。这就是一种强烈保证。

然而，这样的方法并不总是可行的，构造和析构对象的副本可能也是昂贵的。所以我们说有时候需要在异常安全性和效率之间做出取舍，但是我们应该尽量做到基本承诺（如果异常被抛出，程序内的任何事物仍然保持在有效状态下）。

- 异常安全函数即使发生异常也不会泄漏资源或者任何数据结构败坏。这样的函数区分三种可能的保证：基本型保证、强烈型保证、不抛出异常保证。
- “强烈型保证”通常能够以`copy-and-swap`实现出来，但是“强烈保证”并非对所有函数都可以实现或者具备现实意义。
- 函数提供的“异常安全保证”通常最高只等于其所调用之各个函数的“异常安全保证”中的最弱者。

## 30. 透彻了解inlining的里里外外

inline函数背后的整体观念是，将“对此函数的每一个调用，都以函数本体替换之”。这样做很显然会增加编译后目标码的大小，可能导致额外的换页行为，降低高速缓存的命中率，以及伴随而来的效率损失。

值得注意的是，inline只是对编译器的一个申请，而非强制命令，这意味着编译器有权决定对要求成为inline的函数最终是否成为inline。

inline函数通常被置于头文件中，因为大多数build环境在编译过程中进行内联，而为了将“函数调用”替换为“函数本体”，编译器需要知道这个函数的内容具体是什么。对于模板而言也是同样的道理。而对于包含了循环或者递归，以及virtual函数的inline申请，编译器通常会拒绝。因为这些函数进行inline要么实际代码太大，要么无法在编译期间确定实际调用哪个函数。

另外一点，即便类的构造函数和析构函数中无需进行任何操作，看起来平平无奇代码很少，我们也不应该对这些函数进行inline。因为实际上编译器可能会以一种复杂的方式将类的成员的初始化代码“插入”其中，这在编写代码过程中是不可见的，inline将使得代码变得非常复杂。

如果我们要决定哪些函数应不应该成为inline，请使用这样一个合乎逻辑的策略：<font color="red">一开始不要将任何函数声明为inline，或者至少将inline范围限定在那些“一定会成为inline”或者“非常平平无奇”的函数上。</font>

- 将大多数inline限制在小型、被频繁调用的函数身上。这可以使得日后的调试过程和二进制升级更容易，也可以使得潜在的代码膨胀问题最小化，使得程序的速度提升机会最大化。
- 不要只因为函数模板出现在头文件，就将它们声明为inline。

## 31.将文件间的编译依存关系降至最低

这部分内容还是推荐看书，但是总之介绍了Pimpl:

Pimpl（Pointer to Implementation）是一种C++编程惯用法，用于将类的实现细节封装在一个独立的私有类中，然后通过指针或智能指针来访问该私有类的实例。Pimpl的核心思想是将类的接口和实现分离，使得类的用户只能访问公共接口，而不需要了解或直接访问类的私有实现细节。

Pimpl Idiom的主要好处包括：

1. 封装实现细节：Pimpl允许将类的实现细节完全隐藏起来，只暴露公共接口，从而提高了类的封装性和安全性。这有助于防止用户直接访问类的私有成员变量或函数。

2. 降低编译依赖性：通过将实现细节移至独立的私有类中，可以减少头文件的依赖性。这有助于减小编译时间和减少对其他类的重新编译。

3. 优化构建时间：Pimpl可以减小编译单元的大小，使得在修改实现细节时只需重新编译少量文件，而不是整个类。

4. 启用二进制兼容性：如果Pimpl的私有实现类的接口保持稳定，可以在不破坏二进制兼容性的情况下修改类的实现细节，这对于库的开发者来说是非常有价值的。

5. 隐藏第三方库的细节：当使用第三方库时，Pimpl允许将库的实现细节隔离开来，以便在不影响用户代码的情况下升级库。

使用Pimpl Idiom需要额外的内存分配和间接访问的开销，因为实际的对象需要存储在堆上并通过指针或智能指针来访问。因此，在选择是否使用Pimpl时需要权衡封装性和性能方面的需求。通常，当类的实现细节变化频繁或需要隐藏时，Pimpl是一个有用的工具。

以下是一个简单的Pimpl示例，演示了如何使用Pimpl Idiom 来隐藏类的实现细节：

```cpp
// Widget.h - 公共接口

class Widget {
public:
    Widget();
    ~Widget();
    
    void doSomething();
    
private:
    class WidgetImpl; // 声明私有实现类
    WidgetImpl* pImpl; // Pimpl指针
};

// Widget.cpp - 实现

#include "Widget.h"

// 私有实现类的定义
class Widget::WidgetImpl {
public:
    void doInternalWork() {
        // 实现细节
    }
};

Widget::Widget() : pImpl(new WidgetImpl()) {}

Widget::~Widget() {
    delete pImpl;
}

void Widget::doSomething() {
    pImpl->doInternalWork(); // 通过Pimpl访问实现细节
}
```

在上面的示例中，`Widget` 类将其实现细节存储在名为 `WidgetImpl` 的私有类中。用户只能访问 `Widget` 类的公共接口，而实现细节被隐藏在 `WidgetImpl` 中。这种封装提高了类的安全性和可维护性，允许在不影响用户代码的情况下修改实现细节。

> 也就是说，在这样的情况下只要我不修改Widget接口处的声明，整个具体实现细节与用户就完全分离了。如果我修改了具体实现细节，也只需要将WidgetImpl所在的文件重新进行编译链接，而不需要将Widget所在的文件也重新进行编译链接。
>
> Pimpl Idiom允许您将类的实现细节与其公共接口分开，从而实现了信息隐藏和封装。如果您需要修改实现细节，只需重新编译和链接实现细节的部分，而不需要影响用户代码。这提供了更好的可维护性和可扩展性，同时减少了编译时间，因为只有实现细节的更改需要重新编译。
>
> 这对于库开发和保护知识产权非常有用，因为您可以将实现细节视为私有信息，而仅向用户公开接口。这确保了用户只能使用您提供的接口来访问对象，而不需要了解其内部工作原理。

另外几个值得注意的点：

- 如果使用对象引用或对象指针能够完成任务，就不要使用对象本身。因为你只需要一个类型声明就可以定义指向该对象的引用或指针，而如果定义一个对象本身，则需要用到该类型的定义。
- 如果可以的话，尽量以class声明替代class定义。假如你有一个包含了上百个类的文件，如果你没有采用Pimpl的方式（即将类声明和类定义分开并写在不同文件中）的话，那么如果你需要在一个新的文件中编写代码使用其中一些类，你就必须引入整个文件。而如果采用Pimpl的方式，你将会把类按照功能进行划分，在使用其中一部分的时候引入对应的头文件即可。
- 为声明式和定义式提供不同的头文件。道理同上。

此外，接口类通常还会声明一个static函数，它返回一个接口类的指针或者一个引用，指向一个具体的实例。这样的函数称为工厂函数。

由于将类的声明和定义分开，这样做会为每一次访问增加一层间接性。而对于接口类，由于每个函数都是virtual，所以每次函数调用也会增加一个间接跳跃的成本。但是我个人认为，相较于代码耦合带来的编译链接的不便而言，这样的牺牲通常是值得的。

- 支持“编译依存性最小化”的一半构想是：相依于声明式，不要相依于定义式。给予此构想的两个手段是Handle classes和Interface classes
- 程序库头文件应该以“完全且仅有声明式”的形式存在。这种做法不论是否涉及templates都适用。

## 32. 确定你的public继承呈现出“is-a”关系

简而言之，如果派生类D从基类B中派生出来，我们就必须承认“D是B的一个例子，或者一种情况。而B是D的一种一般性的例子或情况”。

这样说起来还是太过复杂，只要记住公有继承必须使得“D是B”就好了。

但是即便满足了“D是B”，不代表公有继承就一定是很好的了。例如，正方形是矩形，因此我们通常会编写出一个正方形类继承自矩形。然而，假设我们在矩形基类中期望改变矩形的宽度或者高度。使用公有继承的正方形类如果只是简单的继承了这个函数，那么将会导致不正确的结果（我们都知道正方形的宽高相同）。因此正方形类还必须重写这个函数。

- “public继承”意味着“is-a”。适用于base classes身上的每一件事情一定也适用于derived classes身上，因为每一个derived class对象也都是一个base class对象。

## 33. 避免隐藏继承而来的名称

简单来说，这一条款涉及到作用域的问题。

我们都知道，如果我们定义了一个变量`x`，如果我们在`x`的作用域内的某个代码块（这意味着作用域比`x`更小）重新定义了一个变量`x`。无论二者的类型是否相同，新的`x`都会覆盖旧的变量`x`。直到离开新的`x`的作用域为止。

在继承关系中同样如此，如果基类中声明了一个函数并将其重载。从函数名称的角度来说，同一函数的重载仍然具有相同的名称。

在公有继承的前提下，派生类会继承函数名称。因此子类中会继承基类的函数名，但是如果这个函数具有多个重载版本，则子类无法直接“看到”所有的重载版本。这就意味着假如基类中实现了函数`foo()`并提供了重载`foo(int)`，子类继承该函数名称时只能看到`foo()`而无法使用`foo(int)`。

解决这个问题的办法就是使用`using`声明，假设基类为`Base`，那么只要在子类的`public`部分（表示这是一个公有声明）使用`using Base::foo;`即可。

然而，使用`using`声明的缺点在于，这使得基类的所有重载实现对子类都可见，有时候我们或许只是想要其中一部分。例如某个函数具有5个重载版本，子类中由于其功能的影响只需要其中两个。如果使用`using`声明直接得到基类的所有重载版本可能导致意外的调用。

在这样的情况下，我们可以使用转交函数(forwarding function):

```cpp
class Base{
	public:
		void foo();
		...	//假设这里是其余4个foo函数
};
class Derived: private Base{
	public:
		void foo(){	//转交函数
			Base::foo();
		}
}
```

这样实质上调用的仍然是基类中对应的函数，同时不使用`using`声明避免了函数名称及重载带来的困扰。

- derived classes内的名称会隐藏base classes内的名称，在public继承下我们不希望如此。
- 为了让被隐藏的名称重见天日，我们可以使用using声明或者转交函数。

## 34. 区分接口继承和实现继承

有时候我们期望派生类继承成员函数的接口，有时候又希望派生类同时继承接口和实现，亦或是重写继承的实现。有时候又希望继承接口和实现，但是不允许重写任何内容。

我们需要了解以下几点：

1. <font color="red">成员函数的接口总是会被继承。</font>在公有继承的前提下，所有的公有或受保护的基类成员函数，它的声明都会被继承。所以某个函数如果可以施加到基类上，则它也一定可以施加到派生类上。
2. <font color="red">声明一个纯虚函数的目的是为了让派生类只继承函数接口。</font>通常情况下我们定义纯虚函数，是由于对于相应的类而言我们很难提供具体实现。例如“椭圆”和“长方形”都继承自基类“形状”，我们可以为椭圆和长方形提供绘制的功能的实现，但是我们无法定义一个“形状”的实现，因为不同的形状对象实际上是迥然不同的。

​		然而，有原则就有例外。我们仍然可以为纯虚函数所在的类中提供一份纯虚函数的实现，但是调用它唯一的路径就是“调用时明确指出其class名称”。即如果在`Base`类中定义了纯虚函数`foo()`。那么唯一的调用方式就是`Base::foo()`。

​		为纯虚函数提供实现，可以提供一种更安全的默认实现方式。后面详述

3. <font color="red">声明虚函数（非纯虚）的目的，是让派生类继承该函数的接口和默认实现。</font>这意味着我们可以自己定制派生类对该函数的实现，但是如果我们不需要特别的功能，也可以使用基类提供的默认实现。

​		但是，允许虚函数同时指定函数声明和函数默认实现的行为，可能会带来一定的危险性。这里书上给出了一个例子，我用自己的语言描述一下。

​		假如我们为某个需要高度安全的公司开发一款软件。为此我们定义了一个基类，基类中使用虚函数`danger()`报告危险并提供了默认实现。该公司有两款产品，它们都继承了这个基类以及虚函数，由于不需要额外的功能，因此没有重写该虚函数而是继承了默认实现。

​		现在公司因业务需求开发了新的产品，新的产品仍然需要`danger()`这个功能，但是需要额外做一些事情才能报告危险。但是由于程序员的疏忽大意，忘记了重写这个函数，这将导致新的产品出现问题时问题不能得到正确的报告，从而造成灾难性的后果。

​		在这个例子中，问题并不在于“基类中含有默认的行为”，而是在于“新的产品在没有明确说明使用默认行为的前提下，就继承了默认行为”。

​		解决办法就是我们刚刚提到的，将基类中的虚函数重新定义为纯虚函数，并提供一份实现。在这样的情况下，如果我们认为派生类中不需要额外的功能，使用基类的默认实现，也需要调用`Base::danger()`才能使用默认行为，即“明确的说明我要使用默认继承的实现”。而由于将函数定义成了纯虚函数，因此基类派生出子类时，编译器会强制派生类“必须自己决定如何实现”。

​		更笼统的来说，这样的实现方式表明“`danger()`函数的声明部分表现出接口，而`danger()`函数的默认实现表现出默认行为”。

4. <font color="red">声明非虚函数的目的是为了派生类继承函数的接口以及一份强制性实现。</font>如果我们把函数声明为非虚的，最显著的影响就是我们无法在这个函数运用虚函数多态，所以我们说继承了一份强制性实现。通常情况下如果一个成员函数声明为非虚的，意味着我们期望派生类“都不应该尝试改变它的行为”。

- 接口继承和实现继承不同。在public继承之下，派生类总是继承基类的接口。
- 纯虚函数只具体指定接口继承。
- 非纯虚函数具体指定接口继承及默认实现继承。
- 非虚函数具体指定接口继承以及强制性的实现继承。

## 35. 考虑虚函数以外的其他选择

该条款介绍了几个除了使用虚函数以外的替代的继承设计方案，具体需要看书。

- virtual函数的替代方案包括NVI手法以及Strategy设计模式的多种形式。NVI手法自身是一个特殊的Template Method设计模式。
- 将成员函数的机能移到class外部的函数带来的缺点是，非成员函数无法访问类的非公有成员。
- `tr1::function`对象的行为就像是一般的函数指针。这样的对象可以接纳“与给定目标签名式兼容”的所有可调用物。

## 36.绝不重新定义继承而来的非虚函数

简而言之，本条款的目的旨在说明非虚函数与继承之间可能产生的冲突。

C++对非虚函数实现的是静态绑定，而对于虚函数实现的是动态绑定。这将导致使用基类指针或引用指向一个派生类对象时，针对非虚函数的调用会产生不同的结果。

一言以蔽之，对于非虚函数，如果子类中重写了该函数，但是由基类指针或引用调用该函数时，不管指针或引用指向的是否是派生类对象，最终调用的都是基类的函数版本。而虚函数由于实现了动态绑定，所以会根据实际指向的对象类型来调用对应的函数。

这一设计考虑的是，非虚函数反应的是“接口继承以及强制性的实现继承”。用通俗的话来说就是，基类B的非虚函数反应的是“如果你是B，那你就可以做到接口及接口强制性实现的事”。比如我们定义了一个基类“人类”，在其中实现了接口“眨眼”并提供了默认的眨眼动作。那么所有继承该类的派生类都应该能够眨眼并做到和“人类”相同的眨眼方式。

- 绝对不要重新定义继承而来的非虚函数。

## 37. 绝不重新定义继承而来的默认参数值

本条款的理由非常明确：<font color="red">在C++中，virtual函数是动态绑定的。但是默认参数值却是静态绑定的。</font>

简单来说，如果基类定义了一个虚函数，同时为该函数的参数指定了默认参数值。现在派生类继承了这个基类并重写了该函数，指定了一个不同的函数默认参数。然而，实际调用过程中虽然能够依据多态性调用实际对象所对应的那个函数，但是默认参数仍然是基类中指定的默认参数。

---



在 C++ 中，虚函数会根据对象的实际类型来选择调用正确的函数版本。这意味着如果你有一个基类指针或引用，它指向派生类对象，然后调用虚函数时，将根据派生类的实际类型来确定应该调用哪个版本的虚函数。

但是默认参数的解析是在编译时进行的，而不是在运行时。这意味着编译器在编译时必须确定要调用的函数版本，包括默认参数的值。因此，默认参数值的选择是在编译时静态绑定的，不会受到运行时对象类型的影响。

考虑以下示例：

```cpp
class Base {
public:
    virtual void foo(int x = 0) {
        cout << "Base foo: " << x << endl;
    }
};

class Derived : public Base {
public:
    void foo(int x = 1) override {
        cout << "Derived foo: " << x << endl;
    }
};

int main() {
    Base* ptr = new Derived;
    ptr->foo(); // 虚函数调用，动态绑定，选择Derived类的foo()，输出 "Derived foo: 0"
    delete ptr;
    return 0;
}
```

在这个示例中，虚函数 `foo()` 虽然被动态绑定，但是默认参数的值仍然是在编译时确定的，所以输出中的 `x` 值是 `0`，这是因为编译器使用了基类的默认参数值。所以，虚函数的默认参数值是静态绑定的。

---



如果你坚持要为继承而来的虚函数指定默认参数，哪怕默认参数和基类相同也在所不惜。这将会造成代码重复，而且如果基类中的默认参数改变了，要么你为它的所有派生类修改对应的默认参数，要么仍然面临之前的问题。

另外一种解决办法是采用条款35中提到的设计方法，具体还是看书。

- 绝对不要重新定义一个继承而来的默认参数值，因为默认参数值都是静态绑定。而虚函数--你唯一一个应该重写的东西--却是动态绑定的。

## 通过复合或者“根据某物实现出”的方式实现has-a关系

这一条款非常简单，总而言之就是一个实际的对象（就是我们要操作的一个实际的有用的对象，比如我们希望操作`Person`类的对象）通常都是由多个对象复合而成（`Person`类中包含了`string name`、`int age`等）。

- 复合的意义和public继承完全不同。
- 在应用领域，复合意味着has-a。在实现领域，复合意味着“根据某物实现出”。

## 39. 小心的使用私有继承

首先，我们需要认识一下究竟什么是私有继承。

如果classes之间的关系是私有继承，编译器不会自动将一个派生类对象转换成一个基类对象。其次，由私有继承而来的基类的任何成员，不论其原先的访问属性，在派生类中都会成为私有属性。

总而言之，private继承仅仅是一种实现技术，它的目的旨在于“根据某物实现出”。我们刚刚提到了私有继承而来的成员（包括属性和函数）都会成为派生类的私有成员，这意味着派生类并没有得到基类中的接口，而是继承了实现。这意味着私有继承实际上是使用了基类的实现，使用基类的实现来达到自己的某些目的。

比如我们定义了一个类，用来打印一个进度条，表示程序运行的一个进度。现在我们希望用它来测试某些类的运行速度，但是我们不能说“某些类”是“进度条”，它们之间并不满足`is-a`的关系。或许我们也不应该说"某些类"拥有"进度条"，而是应该说”根据进度条来实现类的运行速度检测“。

在这样的情况下，我们就可以使用私有继承的方式来得到进度条的功能，从而实现运行速度的检测。

然而正如我刚才所言，private继承只是一种实现技术。我们仍然可以通过其他方式来得到同样的功能，比如在”某些类“中的私有部分定义一个”进度条“类。这样做的好处在于由”某些类“派生出的子类不会继承这些类，子类可以根据需要定制对应的”进度条“类。

此外，还有一种EBO的情况，在此不再赘述，书上写有。

- 私有继承意味着”根据某物实现出“。它通常比复合的级别低。但是当派生类需要访问受保护的基类成员时，或者需要重新定义继承而来的虚函数时，这么设计是合理的。
- 和复合不同，私有继承可以造成空基类最优化。这对致力于”对象尺寸最小化“的程序库开发者而言可能非常重要。

## 40. 小心的使用多重继承

和私有继承同理，多重继承也是一种技术。

多重继承面临的首当其冲的一个问题就是语义上的歧义。考虑如果两个基类中含有同名的函数（这很常见），继承了这两个基类的派生类调用该函数时，直接调用会产生二义性的问题，因为编译器实在不知道调用的是哪个基类继承而来的对应函数。

在这里值得一提的是，即便两个基类中对应函数的访问修饰不同（假设一个访问权限为public，另一个为private）。二义性的问题仍然会发生，这是因为C++解析重载函数的调用首先会根据函数名称进行匹配，找到最佳匹配函数之后再检查其是否可访问（访问其实不太恰当，听起来像是会访问作用域以外的函数，实际上是取用）。而在不考虑访问修饰的情况下，两个基类中的成员函数具有相同的匹配等级，因此编译器不知道应该取用哪个函数。

此外，多重继承还会导致菱形继承的问题。

所谓菱形继承，假如基类A派生出了B、C两个子类。而D类又多重继承了B、C类，只要A类中包含了任何可继承的成员属性或函数，在D类中都会继承出两个副本。这在大多数情况下都不是我们想要的，我们只是希望得到可重写的功能接口，而只需要一份数据来使用。C++在默认情况下不会为你解决菱形继承的问题，也就是说如果你坚持这么写，它就会继承出两个副本。

然而，这样的问题当然是可以解决的。方法就是使用虚继承，让B、C类虚继承自A类。即:

```cpp
class A{...};
class B:virtual public A{...};
class C:virtual public A{...};
class D:public B,public C{...};
```

不同于普通的继承，虚继承的子类只会拥有一份共享的基类成员副本。这里的共享并不意味着B、C之间能够共享成员之类的，而是说如果任何类再继承它们时，虚继承的部分（由A继承而来的部分）保证只有一份。

> 普通的继承和虚继承之间的主要区别在于派生类如何继承基类的成员以及如何处理多继承时的二义性问题。
>
> 1. **继承方式**：
>    - 普通继承（非虚继承）：在普通继承中，派生类会完全复制基类的成员，包括成员变量和成员函数。这意味着每个派生类对象都包含一份完整的基类对象。普通继承通常用于建立"is-a"关系，表示派生类是基类的一种类型。
>
>    - 虚继承：在虚继承中，基类的成员变量在派生类中只有一份共享的副本，而不是每个派生类对象都有自己的拷贝。这种方式通常用于解决多继承的菱形继承问题，以避免二义性。
>
> 2. **解决多继承二义性**：
>    - 普通继承可能会导致多继承时的二义性问题，例如菱形继承问题。这种情况下，派生类可能会继承两个或更多基类，其中包含相同名称的成员。这样的情况可能导致编译器无法确定使用哪个基类的成员，从而引发二义性错误。
>
>    - 虚继承通过共享基类的实例来解决多继承的二义性问题。这意味着在虚继承中，基类的成员只有一个实例，因此无论有多少派生类继承它，都不会导致二义性。虚继承通常用于处理多继承中的复杂情况，以确保继承体系的一致性。
>
> 总之，虚继承是为了解决多继承时的二义性问题而设计的，它允许多个派生类共享一个基类的实例，从而确保在多继承情况下继承体系的一致性。普通继承则是常见的继承方式，每个派生类都有自己的基类成员的拷贝，适用于一般的"is-a"关系。

- 多重继承比单一继承复杂，它可能导致新的歧义性，以及对virtual继承的需要。
- virtual继承会增加大小、速度、初始化（及赋值）复杂度等等成本。如果虚基类不带任何数据，则时最具实用价值的情况。
- 多重继承的确有正当用途。例如，”public继承某个接口类“和”私有继承某个协助实现的类“的组合。

## 41. 了解隐式接口和编译期多态

假如我们有这样的一个类及函数：

```cpp
class Widget{
	public:
		Widget();
		virtual ~Widget();
		...	//包含了下面函数中w调用的函数，且是虚函数
}
void doProcessing(Widget& w){
    if(w.size() > 10 && w != someNastyWidget){
        Widget temp(w);
        temp.normalize();
        temp.swap(w);
    }
}
```

- 由于`w`被声明为`Widget`，所以`w`一定是支持了`Widget`接口的。我们可以从源代码文件中找到`Widget`的定义，这样的称为显式接口，它在源码中清晰可见。
- 由于`Widget`包含了虚函数，所以实际上对于引用`w`的调用会在运行时根据参数实际的类型来实现运行时多态，调用对应的成员函数。

而如果涉及到模板，情况就有所不同：

```cpp
template<typename T>
void doProcessing(T& w){
	if(w.size() > 10 && w != someNastyWidget){
        T temp(w);
        temp.normalize();
        temp.swap(w);
    }
}
```

- 与之前不同，`w`现在必须支持某种接口，这将由调用函数时实际的类型决定。而从代码中来看，该接口还必须实现了`doProcessing`中调用的所有函数以及重载运算符。这种”不确定究竟支持什么接口，但是必须实现了这些方法“的内容称为隐式接口。
- 但凡涉及到`w`的调用，都可能使得模板具现化（说白了就是模板生成了对应类型的该函数），使得调用得以成功。这样的具现化过程发生在编译期。以不同的模板参数具现化函数模板会导致不同的函数，也就是说，如果参数是`Widget`类型，则会调用`Widget`类对应的函数。但是如果以其他类型作为参数，则会导致其他类型的对应函数被调用。这就是所谓的编译期多态。

让我们把上面的内容总结一下，来解释显式接口和隐式接口具体的差异。

显式接口通常可以直接在源码文件中观察到，接口中的函数由函数签名式（函数名称、参数类型、返回类型）构成，所有的成员函数和属性构成了显式接口类。

隐式接口则完全不同，它并不是由函数签名式构成，而是由有效的表达式构成，回顾上面的模板：

```cpp
template<typename T>
void doProcessing(T& w){
	if(w.size() > 10 && w != someNastyWidget){
        ...
    }
}
```

正如刚才所言，我们对模板类型`T`的隐式接口的要求就是实现了对应的函数和运算符重载。但是思考一种可能性，`T`在运行时的具体类型可能从某个基类中继承了`size`函数，而这个`size`函数甚至不需要返回一个数值类型，只要其返回类型能够和`int`类型10执行`operator>`即可。对于`!=`运算符的道理也类似。

总而言之，显示接口更像是从接口的本身出发，明确的告诉用户”我具有哪些功能，可以如何使用“。而隐式接口更像是从用户的角度出发，实现某个功能，然后”你们只要支持这项功能，就是该功能中的隐式接口实现之一“。

- 类和模板都支持接口和多态
- 对类而言接口是显式的，以函数签名式为中心。多态则是通过虚函数实现，发生在运行期。
- 对模板参数而言，接口是隐式的，它基于有效的表达式。多态则是通过模板的具现化和函数重载解析来实现的。

## 42. 了解typename的双重意义

让我们从这里开始：

```cpp
template<typename T> class Widget;
template<class T> class Widget;
```

在这段代码中，使用`typename`和`class`的作用完全相同，具体使用哪个仅仅取决于你的个人习惯。

然而，这并不意味着这二者在什么情况下都是等价的。

书中给出了一个例子，我将抄上这个例子并用自己的话解释：

假设我们定义了一个模板函数，并接受一个STL兼容容器作为参数，容器内保存的对象可以转换为`int`类型，该函数用于打印容器中第二个保存的值：

```cpp
template<typename T>
void print2nd(const T& container){
	if(container.size() >= 2){
		T::const_iterator iter(container.begin());
		++iter;
		int value = *iter;
		std::cout << value;
	}
}
```

首先，我们需要关注两个局部变量，`iter`和`value`。

`iter`是一个`T::const_iterator`类型的变量，具体是什么类型当然到了编译期才能确定。但是我们规定了一件事，<font color="red">如果在模板内出现的名称依赖于模板参数(这里的`iter`就依赖于模板参数`T`)，称为从属名称。而如果从属名称在类内呈现嵌套状(`iter`不仅依赖`T`的类型，更依赖`T::const_iterator`的名称)称为嵌套从属名称。</font>很显然这里的`iter`就是一个从属名称。

`value`则没有太多好说的，它是一个非从属名称。

之所以提到这一点，是因为嵌套从属名称可能导致解析困难。我们直觉上当然认为`T::const_iterator`当然是`T`类型中的某个迭代器类型，但是如果不是呢？如果它是`T`类型中的一个`static`变量的名称呢？那么假如有如下调用：

```cpp
T::const_iterator* x;
```

直觉上来说我们尝试在定义一个迭代器指针`x`，但是正如刚刚提问所说的，万一`T::const_iterator`是一个`static`变量之类的，那么这个表达式的含义就成了"使用static变量与x进行相乘的操作"。

在我们知道`T`的类型之前，我们无从得知`T::const_iterator`的类型，对于编译器而言更是如此。C++中定义的规则则是：<font color="red">如果解析器在模板中遇到了一个嵌套从属名称，它便假设它不是一个类型名，除非明确告诉它是。</font>

所以我们上面提供的`print2nd()`函数的代码其实是无效的，甚至无法通过编译。

绕了这么多，我们现在可以想办法解决这个问题了。方法就是用到`typename`关键字，明确的告诉编译器你提供的是一个类型：

```cpp
template<typename T>
void print2nd(const T& container){
	if(container.size() >= 2){
		typename T::const_iterator iter(container.begin());
		++iter;
		int value = *iter;
		std::cout << value;
	}
}
```

这也引出一个一般性的规则：<font color="red">任何时候当你想要在模板中使用一个嵌套从属名称，就必须在前面放上`typename`关键字。当然，也有一个例外。</font>

这个例外就是：<font color="red">`typename`不能出现在继承时基类列表的嵌套从属名称之前，也不能作为基类的修饰符出现在成员初始化列表中。</font>

```cpp
template<typename T>
class Derived: public Base<T>::Nested{ //Nested是一个嵌套从属名称，但是不允许typename
	public:
		explicit Derived(int x): Base<T>::Nested(x){ //同理
			...
		}
}
```

- 声明template参数时，前缀关键字class和typename可互换。
- 请使用关键字typename标识嵌套从属类型名称，但不得在基类列表或者成员初始值列表中将其作为修饰符。

## 43. 学习处理模板化基类内的名称

这一条款旨在说明，当我们继承一个模板基类时，我们不能在派生类的成员函数中直接调用模板基类中定义的函数（无论是虚函数还是非虚函数）。

究其本因，先看一个例子：

```cpp
class ACompany{
	public:
		void foo(...);
		void zoo(...);
};
class BCompany{
	public:
		void foo(...);
		void zoo(...);
};
template<typename Company>
class MsgSender{
	public:
		...
		void sendfoo(){
			Company c;
			c.foo();
		}
    	void sendzoo(){
			Company c;
			c.zoo();
		}
};
```

假设A公司和B公司都需要发送信息的功能，使用一个模板基类来实现这些功能即可。调用时会根据模板参数类型进行匹配对应的函数进行调用。

但是如果我们需要在发送信息的同时写日志呢？比较不好的实现方式是为`MsgSender`添加一个写日志的私有成员函数（这超出了`MsgSender`本身的功能，尽管用户感觉不到）或者定义一个日志类，然后让`MsgSender`私有继承它（也超出了它本身的功能，用户也感觉不到）。

一种看上去较为合理的方式是继承`MsgSender`，并重写它的函数:

```cpp
template<typename Company>
class LoggingMsgSender: public MsgSender<Company>{
	public:
		...
		void sendfooMsg(){
			//传送信息前写日志
			sendfoo();
			//传送信息后写日志
		}
    	void sendzooMsg(){
            //与sendfooMsg做着类似的事
        }
};
```

看上去一切都好，但其实不然。编译器会拒绝`sendfoo`函数的调用，因为它找不到这个函数。

原因是看上去我们虽然从基类中公有的继承（函数是公有的，继承也是公有继承）了这个函数，但是考虑这样的代码：

```cpp
template<>
class MsgSender<ZCompany>{
	public:
		...
		void foo();
}
```

这是模板类`MsgSender`的一个全特化版本（所有的模板参数都已指定具体类型，因此是全特化），在这个特化的版本中，我们仅实现了`foo()`函数。这是因为我们假设它不应该具备`zoo()`函数的功能，这也是我们为`ZCompany`类型进行全特化的原因。

那么问题就变得了然了，如果代码中存在像`ZCompany`这样的特化实现的话，对`zoo`函数的调用就是一个招致错误的行为。C++拒绝`sendfooMsg()`函数中调用的行为正是因为<font color="red">它知道模板基类有可能被特化，而特化版本中可能提供了和模板基类不一致的接口，因此它拒绝在模板基类中寻找继承而来的名称。</font>

问题既然已经发觉，那么如何解决呢？C++中提供了几种方式：

1. 使用`this->sendfoo`，这明确告诉编译器“我要使用本类中定义（其实是继承而来的）的那个sendfoo函数。”
2. 使用`using`声明式，在类的public区域声明`using MsgSender::sendfoo`。这将告诉编译器去对应的作用域内查找这个函数。
3. 第三种则是不使用`using`声明，而是直接使用`MsgSender::sendfoo`。

- 可在派生类模板内通过`this->`引用模板基类内的成员名称，或者一个明确写出的“基类资格修饰符“完成。

## 44. 将与参数无关的代码抽离模板

