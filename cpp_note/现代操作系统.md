# 笔记

## 第一章 引论

操作系统的任务是为用户提供一个更好、更简单、更清晰的计算机模型，并管理诸如处理器、主存等硬件设备。

用户与操作系统交互的程序，基于文本的称为`Shell`，基于图标的则是图形用户界面`GUI`。

多数计算机有两种运行模式：内核态和用户态。软件中最基本的就是操作系统，它运行在内核态。在内核态中，操作系统具备对硬件的所有访问权，可以执行机器能够运行的任何指令。其余部分则运行在用户态，只能使用机器指令中的一个子集，尤其那些影响机器控制或者与`IO`有关的指令在用户态程序中是禁止的。

然而，也有一些在用户态运行的程序协助操作系统完成特权功能。例如，文件系统被认为是操作系统的一部分，但是当我们使用资源管理器的时候，相当于也是在通过文件系统（用户态）与操作系统（内核态）进行交互，实现与硬盘之间的`IO`。

> 这个说法基本上是正确的。操作系统通常分为内核态和用户态。内核态（Kernel Mode）是操作系统的核心部分，它具有完全的访问权限，可以直接与硬件交互。用户态（User Mode）则是普通应用程序运行的环境，它们不能直接操作硬件，而是通过系统调用（System Calls）来请求内核态的服务。
>
> 文件系统是操作系统的一个重要组成部分，它管理着所有的文件和目录。虽然文件系统的核心部分在内核态运行，但是用户通常通过用户态的程序，如资源管理器（在Windows中）或文件管理器（在Linux或macOS中），来与文件系统交互。这些程序提供了用户界面，允许用户执行文件操作，如创建、编辑、移动或删除文件和目录。
>
> 当用户通过这些用户态程序执行文件操作时，这些程序会发出系统调用，请求内核态的文件系统服务来实际执行硬盘的I/O操作。因此，虽然用户是通过用户态的程序与文件系统交互，但最终的硬件操作是由内核态完成的。

### 1.1 什么是操作系统

操作系统是一种运行在内核态的软件（尽管该说法并不是总是符合事实）。

#### 1.1.1 作为扩展机器的操作系统

从机器语言的层次上来说，与硬件设备打交道总是很困难的，例如编写程序对硬盘进行输入/输出。因此，程序员们通常使用硬盘驱动的方式，将与硬盘的交互抽象到一个接口中，这样程序员只需要通过接口就可以正常与硬盘交互了。

然而，这样的方法还是太底层了，由此操作系统在这一层级上又抽象出文件的概念。程序中只要创建、读写文件，就可以完成和硬盘的实际交互。

#### 1.1.2 作为资源管理者的操作系统

如果把操作系统看作向应用程序提供基本抽象的事物的话，这是一种自顶向下的观点，从应用程序的视角出发，操作系统就是把一系列复杂的机器指令抽象起来最终呈现给用户一个良好的界面或者交互。

如果按照自底向上的观点，即从硬件的角度出发的话，那么操作系统无疑是用来管理这些硬件的管理者。它的任务是在相互竞争的程序之间有序的控制对处理器、存储器以及其他`I/O`接口设备的分配。

现代操作系统允许同时在内存中运行多个程序，显然这些程序之间可能会有资源上的竞争（争取处理器的使用等）。操作系统的主要任务就是记录哪个程序在使用什么资源，对资源请求进行分配，评估使用代价，为不同的程序和用户调解互相冲突的资源请求。

资源管理包括用两种方式实现多路复用（共享）资源：时间上复用和空间上复用。

- 时间复用：当一种资源在时间上复用时，不同的程序或用户轮流使用它。例如，某个系统中只有一个cpu，而多个程序需要在cpu上运行，操作系统负责把cpu分配给某个程序，在它运行足够长时间后另一个程序得到cpu，以此类推。至于究竟谁首先得到资源，运行多长时间算够长，则是操作系统考虑的事。
- 空间复用：每个客户都得到资源的一部分，从而避免了客户排队。例如在若干个应用程序需要运行时为它们分配内存，这样多个应用程序可以同时存在于内存中，这比让应用程序排队进入内存再退出要好得多。

### 1.2 操作系统的历史

#### 1.2.1 第一代（1945~1955）：真空管和穿孔卡片

#### 1.2.2 第二代(1955~1965)：晶体管和批处理系统

#### 1.2.3 第三代（1965~1980）：集成电路和多道程序设计

#### 1.2.4 第四代（1980~至今）：个人计算机

 #### 1.2.5 第五代（1990~至今）：移动计算机

### 1.3 计算机硬件简介

一台简单的个人计算机可以看作是一个模型：cpu、内存以及`I/O`设备都由一条系统总线连接起来并通过总线与其他设备通信。

#### 1.3.1 处理器

在每个cpu基本周期中，首先从内存中取出指令，解码以确定其类型和操作数。执行并取址解码下一条指令，循环往复。

cpu中还有一些用来保存关键变量和临时数据的寄存器。

>什么是寄存器？它的作用是什么？
>
>寄存器是中央处理单元（CPU）内部的一种非常快速的小容量存储设备。它们用于存储指令、数据和地址等信息，以便CPU在执行计算和处理任务时快速访问。寄存器的存储容量有限，通常只有几十到几百个字节，但它们的访问速度远远高于其他类型的存储器，如缓存、主存（RAM）和硬盘。
>
>寄存器的作用包括：
>
>1. 指令寄存器（Instruction Register, IR）：存储当前正在被CPU执行的指令。
>2. 程序计数器（Program Counter, PC）：存储下一条要执行的指令的内存地址。
>3. 累加器（Accumulator）：用于存储中间计算结果或操作的结果。
>4. 数据寄存器（Data Registers）：暂时存储操作数，即指令操作的数据。
>5. 地址寄存器（Address Registers）：存储内存地址，指示CPU从哪里读取数据或向哪里写入数据。
>6. 状态寄存器/标志寄存器（Status Register/Flag Register）：存储指令执行后的状态信息，如零标志、进位标志、溢出标志等。
>7. 通用寄存器（General Purpose Registers）：可以被程序用于多种目的，如存储临时数据、指针等。
>
>寄存器的高速访问特性使得CPU能够快速处理数据和执行指令，从而提高整个计算机系统的性能。由于它们的数量有限，编程时需要高效地使用寄存器资源。在现代处理器架构中，寄存器通常是编程模型的一部分，编译器和汇编器会在生成机器代码时分配和管理寄存器的使用。

##### 多线程和多核芯片

近似的说，多线程允许cpu保持两个不同的线程状态，然后在纳秒级的时间尺度内来回切换。<font color="red">多线程不提供真正的并行处理，在一个时刻只有一个进程在运行，但是线程的切换时间则减少到纳秒数量级。</font>

#### 1.3.2 存储器

存储器是一个统称，按照速度从高到低划分，寄存器、高速缓存、主存（内存）、磁盘都是存储器。

第一层的是寄存器，它使用和cpu相同的材料制成，因此和cpu一样快。

第二层的是高速缓存，这是一个位于cpu和内存之间的部件，通常内置在cpu芯片或cpu附近的独立芯片上。当我们需要访问一些数据时，这些数据被划分为"高速缓存行"。当cpu访问某段数据时，会先检查这些数据是否位于高速缓存中。如果是，称为**高速缓存命中**。如果在高速缓存中没有找到数据，就只能去内存中查找了。

> 高速缓存（Cache）是计算机存储体系中的一种特殊组件，它位于CPU和主存储器（RAM）之间，用于暂时存储频繁访问的数据和指令，以便快速访问。高速缓存的访问速度远高于主存储器，因此可以显著提高计算机的性能。
>
> 当我们说“主存被划分为高速缓存行”时，我们是在描述高速缓存的组织方式。主存储器中的数据被分成小块，这些小块称为“高速缓存行”或“块”。高速缓存也被分成相应大小的行。当CPU需要访问主存中的数据时，它会检查这些数据是否已经在高速缓存中。如果所需数据已经在高速缓存中（这称为“缓存命中”），CPU可以直接从高速缓存读取数据，而不必访问较慢的主存储器。如果数据不在高速缓存中（这称为“缓存未命中”），则必须从主存中读取数据并将其放入高速缓存中。
>
> 高速缓存不是物理上的一部分主存储器，而是一种独立的、更快速的存储设备。它通常是内置在CPU芯片上或位于CPU附近的独立芯片上。高速缓存的大小远小于主存储器，但由于其设计和技术，它能够提供非常快的访问速度。
>
> 高速缓存中存储的数据是自动管理的，通常基于算法预测哪些数据将被频繁访问。这些算法可能基于“最近最少使用”（LRU）原则或其他复杂的预测模型。因此，并不是将“更重要”的数据放入高速缓存，而是将“最可能被接下来访问”的数据放入高速缓存。这种预测性的数据管理有助于确保CPU能够尽可能地从高速缓存中获取数据，从而提高整体系统性能。
>
> 也就是说，假如我有一大块数据需要访问，这些数据将被划分为若干高速缓存行。但是高速缓存的大小有限，这一大块数据未必能一起存储在高速缓存中，因此还有一部分停留在内存中。当我访问其中某个部分的数据时，首先到高速缓存中寻找，没有找到再去内存中查找，对吗？
>
> 
>
> 是的。当您有一大块数据需要访问时，这些数据确实会被划分为若干高速缓存行。由于高速缓存的大小有限，它无法同时容纳所有的数据，因此只有一部分数据会被加载到高速缓存中。
>
> 这个过程通常是这样的：
>
> 1. **缓存加载**：当CPU尝试读取数据时，它首先会检查所需的数据是否已经存在于高速缓存中。
> 2. **缓存命中**：如果所需数据在高速缓存中，CPU可以直接读取，这是一个非常快速的操作。
> 3. **缓存未命中**：如果所需数据不在高速缓存中，CPU必须从主存储器中读取数据。这个过程相对较慢，因为主存储器的访问速度慢于高速缓存。
> 4. **数据替换**：读取的数据将被加载到高速缓存中，如果高速缓存已满，一些旧的数据（根据特定的替换策略）将被新数据替换出去。
>
> 高速缓存管理的目标是最大化缓存命中率，即尽可能多地从高速缓存中读取数据，以减少对慢速主存储器的访问。这通常通过智能的缓存替换策略来实现，如最近最少使用（LRU）策略，它会优先替换掉最长时间未被访问的数据。这样，高速缓存中的数据尽可能地反映了CPU近期的访问模式。

第三层就是我们的主存了，其实上面对内存的说法应该说是主存才对。主存也分为了随机访问存储器（RAM）以及只读存储器（ROM）等。

至于第四层磁盘，则在下一节介绍。

#### 1.3.3 磁盘

磁盘分为机械硬盘和固态硬盘。

先说说机械硬盘，机械硬盘内部有多个盘面，每个盘面上都有一个读写头。在任意一个读写头不改变位置的情况下，它可以读写一个**磁道**。而一个盘面上所有磁道的组合称为**柱面**。

**磁道**又被划分为若干个**扇区**，扇区的典型大小是`512字节`。也正如常理，靠近磁盘外侧的磁道拥有更多的扇区。

固态硬盘和机械硬盘的区别很大，它们唯一相似之处就在于都拥有大量在电源关闭时也不会丢失的数据。

#### 1.3.4 I/O 设备

