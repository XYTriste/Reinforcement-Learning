# 笔记

## 第一章 引论

操作系统的任务是为用户提供一个更好、更简单、更清晰的计算机模型，并管理诸如处理器、主存等硬件设备。

用户与操作系统交互的程序，基于文本的称为`Shell`，基于图标的则是图形用户界面`GUI`。

多数计算机有两种运行模式：内核态和用户态。软件中最基本的就是操作系统，它运行在内核态。在内核态中，操作系统具备对硬件的所有访问权，可以执行机器能够运行的任何指令。其余部分则运行在用户态，只能使用机器指令中的一个子集，尤其那些影响机器控制或者与`IO`有关的指令在用户态程序中是禁止的。

然而，也有一些在用户态运行的程序协助操作系统完成特权功能。例如，文件系统被认为是操作系统的一部分，但是当我们使用资源管理器的时候，相当于也是在通过文件系统（用户态）与操作系统（内核态）进行交互，实现与硬盘之间的`IO`。

> 这个说法基本上是正确的。操作系统通常分为内核态和用户态。内核态（Kernel Mode）是操作系统的核心部分，它具有完全的访问权限，可以直接与硬件交互。用户态（User Mode）则是普通应用程序运行的环境，它们不能直接操作硬件，而是通过系统调用（System Calls）来请求内核态的服务。
>
> 文件系统是操作系统的一个重要组成部分，它管理着所有的文件和目录。虽然文件系统的核心部分在内核态运行，但是用户通常通过用户态的程序，如资源管理器（在Windows中）或文件管理器（在Linux或macOS中），来与文件系统交互。这些程序提供了用户界面，允许用户执行文件操作，如创建、编辑、移动或删除文件和目录。
>
> 当用户通过这些用户态程序执行文件操作时，这些程序会发出系统调用，请求内核态的文件系统服务来实际执行硬盘的I/O操作。因此，虽然用户是通过用户态的程序与文件系统交互，但最终的硬件操作是由内核态完成的。

### 1.1 什么是操作系统

操作系统是一种运行在内核态的软件（尽管该说法并不是总是符合事实）。

#### 1.1.1 作为扩展机器的操作系统

从机器语言的层次上来说，与硬件设备打交道总是很困难的，例如编写程序对硬盘进行输入/输出。因此，程序员们通常使用硬盘驱动的方式，将与硬盘的交互抽象到一个接口中，这样程序员只需要通过接口就可以正常与硬盘交互了。

然而，这样的方法还是太底层了，由此操作系统在这一层级上又抽象出文件的概念。程序中只要创建、读写文件，就可以完成和硬盘的实际交互。

#### 1.1.2 作为资源管理者的操作系统

如果把操作系统看作向应用程序提供基本抽象的事物的话，这是一种自顶向下的观点，从应用程序的视角出发，操作系统就是把一系列复杂的机器指令抽象起来最终呈现给用户一个良好的界面或者交互。

如果按照自底向上的观点，即从硬件的角度出发的话，那么操作系统无疑是用来管理这些硬件的管理者。它的任务是在相互竞争的程序之间有序的控制对处理器、存储器以及其他`I/O`接口设备的分配。

现代操作系统允许同时在内存中运行多个程序，显然这些程序之间可能会有资源上的竞争（争取处理器的使用等）。操作系统的主要任务就是记录哪个程序在使用什么资源，对资源请求进行分配，评估使用代价，为不同的程序和用户调解互相冲突的资源请求。

资源管理包括用两种方式实现多路复用（共享）资源：时间上复用和空间上复用。

- 时间复用：当一种资源在时间上复用时，不同的程序或用户轮流使用它。例如，某个系统中只有一个cpu，而多个程序需要在cpu上运行，操作系统负责把cpu分配给某个程序，在它运行足够长时间后另一个程序得到cpu，以此类推。至于究竟谁首先得到资源，运行多长时间算够长，则是操作系统考虑的事。
- 空间复用：每个客户都得到资源的一部分，从而避免了客户排队。例如在若干个应用程序需要运行时为它们分配内存，这样多个应用程序可以同时存在于内存中，这比让应用程序排队进入内存再退出要好得多。

### 1.2 操作系统的历史

#### 1.2.1 第一代（1945~1955）：真空管和穿孔卡片

#### 1.2.2 第二代(1955~1965)：晶体管和批处理系统

#### 1.2.3 第三代（1965~1980）：集成电路和多道程序设计

#### 1.2.4 第四代（1980~至今）：个人计算机

 #### 1.2.5 第五代（1990~至今）：移动计算机

### 1.3 计算机硬件简介

一台简单的个人计算机可以看作是一个模型：cpu、内存以及`I/O`设备都由一条系统总线连接起来并通过总线与其他设备通信。

#### 1.3.1 处理器

在每个cpu基本周期中，首先从内存中取出指令，解码以确定其类型和操作数。执行并取址解码下一条指令，循环往复。

cpu中还有一些用来保存关键变量和临时数据的寄存器。

>什么是寄存器？它的作用是什么？
>
>寄存器是中央处理单元（CPU）内部的一种非常快速的小容量存储设备。它们用于存储指令、数据和地址等信息，以便CPU在执行计算和处理任务时快速访问。寄存器的存储容量有限，通常只有几十到几百个字节，但它们的访问速度远远高于其他类型的存储器，如缓存、主存（RAM）和硬盘。
>
>寄存器的作用包括：
>
>1. 指令寄存器（Instruction Register, IR）：存储当前正在被CPU执行的指令。
>2. 程序计数器（Program Counter, PC）：存储下一条要执行的指令的内存地址。
>3. 累加器（Accumulator）：用于存储中间计算结果或操作的结果。
>4. 数据寄存器（Data Registers）：暂时存储操作数，即指令操作的数据。
>5. 地址寄存器（Address Registers）：存储内存地址，指示CPU从哪里读取数据或向哪里写入数据。
>6. 状态寄存器/标志寄存器（Status Register/Flag Register）：存储指令执行后的状态信息，如零标志、进位标志、溢出标志等。
>7. 通用寄存器（General Purpose Registers）：可以被程序用于多种目的，如存储临时数据、指针等。
>
>寄存器的高速访问特性使得CPU能够快速处理数据和执行指令，从而提高整个计算机系统的性能。由于它们的数量有限，编程时需要高效地使用寄存器资源。在现代处理器架构中，寄存器通常是编程模型的一部分，编译器和汇编器会在生成机器代码时分配和管理寄存器的使用。

##### 多线程和多核芯片

近似的说，多线程允许cpu保持两个不同的线程状态，然后在纳秒级的时间尺度内来回切换。多线程不提供真正的并行处理，在一个时刻只有一个进程在运行，但是线程的切换时间则减少到纳秒数量级。

