# 笔记

## 顶层const与底层const

顶层const表明对象本身是const，不能进行修改。而底层const表示对象指向了一个const类型的数据（或者说指针指向的值为const）。

<font color="red">底层const的概念仅仅针对指针或引用类型，因为对于非指针、非引用类型的变量，不存在"指向const类型的数据"的概念。</font>

简而言之，如果`const`出现在指针或引用的`*`或`&`符号左边，说明被指的无法通过指针或引用修改。如果出现在右边则说明指针指向的变量不能修改（指向了A就不能再指向B了）。

## auto关键字

`auto`关键字是用来自动推断类型的，使用它可以让编译器自行推断类型并使用该类型来定义变量。

在使用`auto`关键字涉及到`const`时，例如:

```cpp
int i = 0;
const int ci, &cr = ci;
auto b = ci;
auto c = cr;
auto d = &i;
auto e = &ci;
```

<font color="red">`auto`关键字通常会忽略掉顶层`const`，而保留底层`const`。</font>简单点来说，就是`auto`关键字不会因为表达式右边为`const`类型就将自身推断为`const`类型。而如果表达式右边指向了一个`const`（在上面这个例子中，&ci可以看作是一个匿名的指针，该指针指向了一个`const int`类型的常量`ci`），则`auto`关键字在推断时会保留该特征。

> 这部分其实还是有点没理清楚

## decltype

和`auto`类似，`decltype`的作用也是用来确定变量类型，它的参数可以说是一个表达式。类似这样的形式:

```cpp
decltype(expression) variable_name;
```

如果多给表达式加上一层括号，则无论表达式的结果是什么类型，由`decltype`确定的变量的类型都为引用。也就是说:

```cpp
decltype((expression)) variable_name;
```

该语句确定的变量类型必定是引用，如果表达式结果为`int`类型，则`variable_name`就是对`int`变量的引用。

<font color="red">值得注意的是，`decltype`只是帮助变量确定了类型，如果需要使用还需要进行赋值或者初始化。如果是引用类型的变量，在定义时就必须要进行初始化。</font>

<font color="red">此外，如果表达式的内容是解引用操作，例如`decltype(*p) a;`，那么得到的结果是引用类型，而非常规的变量类型。</font>

## constexpr

它的全称是`const expression`，即常量表达式。该关键字用在变量定义并进行初始化时，如果能够确定初始化的值一定是一个常量表达式，则可以使用该关键字让表达式的值在编译时就得到计算，从而提高程序的效率。

## 显式类型转换

有时候我们需要对类型进行强制转换，比如我们希望得到两个整数相除后的浮点数结果。

```cpp
int i = 5, j = 3;
double result = i / j;
```

之前一种常用的做法就是添加浮点数运算使其进行自动类型提升，例如将`i / j`改写为`1.0 * i / j`。但是我们可以使用关键字来进行转换使得语义更加明显，常用的用于转换的关键字包含4种。

### static_cast

任何具有明确定义的类型转换，只要不包含底层const，都可以使用`static_cast`。例如:

```
double result = static_cast<double>(i) / j;
```

### const_cast

该关键字仅针对具有底层`const`的对象使用，使得可以将常量对象转换为非常量对象。例如:

```cpp
const char *pc;
char *p = const_cast<char *>(pc);
```

尽管`pc`未分配内存，这样的转换依然是有效的。这样的转换使得`p`指针可以修改`pc`指针指向的可能不被希望修改的内容。因此需要小心使用。

### reinterpret_cast

`reinterpret_cast`通常为运算对象在二进制位上的形式提供较低层次上的重新解释。

`reinterpret_cast` 是 C++ 中的一种类型转换运算符，用于执行低级别的类型转换，特别是在不同类型之间进行位级别的重新解释。它允许将一个指针或引用类型转换为另一个指针或引用类型，甚至可以将不相关的类型之间进行转换，但这种转换通常是危险的，需要非常谨慎使用。

`reinterpret_cast` 的语法如下：

```cpp
new_type = reinterpret_cast<new_type>(expression);
```

其中，`new_type` 是要转换的目标类型，`expression` 是要转换的表达式。这个运算符的主要用途是在不同类型之间执行位级别的转换，但并不会进行任何类型的检查或转换，因此需要开发者保证转换是安全的。

一些情况下可以使用 `reinterpret_cast`，例如：

- 将指针类型转换为整数类型，以便执行位运算。
- 将整数类型转换为指针类型，用于与底层内存交互。
- 在一些特殊的硬件操作中，需要将数据强制转换为特定的格式。

但需要强调的是，使用 `reinterpret_cast` 往往会绕过类型系统的保护，可能会导致未定义行为、访问非法内存以及安全漏洞。在绝大多数情况下，应该避免使用 `reinterpret_cast`，而是选择更安全和合适的类型转换方式，如 `static_cast` 或 `dynamic_cast`。

### dynamic_cast

> 该部分暂未介绍，后续补充

## initializer_list

如果事先不知道要向一个函数传递几个实参，且该函数所有形参的类型相同。则可以使用该类型来保存某种特定类型的值的数组。

相较于传统的使用数组传递可变数量参数的形式，它的优势在于:

`initializer_list` 的确是一种用于传递可变数量的值的机制，特别适用于在函数参数中传递一组值。除了语义上更清晰外，`initializer_list` 还有以下优势：

1. **类型安全：** `initializer_list` 会强制确保传递给函数的值具有相同的类型。这可以防止不同类型的值被混淆或错误地传递给函数。

2. **隐式转换：** `initializer_list` 支持隐式转换，因此可以将不同类型的值传递给接受 `initializer_list` 的函数，而不需要显式地进行类型转换。

3. **适用于构造函数和初始化列表：** 除了函数参数，`initializer_list` 也可以用于构造函数的初始化列表，使得在对象的初始化过程中可以方便地传递多个值。

4. **语法简洁：** 使用 `initializer_list` 可以使代码更加简洁，不需要手动创建数组并传递大小等信息。

5. **支持范围循环：** `initializer_list` 具有可迭代性，因此您可以使用范围循环（range-based for loop）来遍历其中的值。

6. **与标准库容器兼容：** `initializer_list` 与标准库容器（如 `std::vector`、`std::array` 等）的初始化语法类似，使得在函数参数和容器初始化时具有一致的语法。

总的来说，`initializer_list` 提供了一种更方便、类型安全、语义清晰的方式来传递和初始化多个值，尤其适用于需要传递一组值的场景。

## 代码调试

### assert 与 NDEBUG

在 C++ 中，`assert` 是一个宏，用于在程序中插入断言，用于在运行时检查某个条件是否为真。如果断言条件为假，则 `assert` 宏会导致程序终止并生成一个错误消息，以帮助开发者在调试过程中找到问题所在。`assert` 宏定义在 `<cassert>` 头文件中。

`assert` 宏的语法如下：

```cpp
#include <cassert>

void someFunction(int value) {
    assert(value > 0); // 如果 value 不大于 0，程序终止并输出错误消息
}
```

在上面的示例中，如果 `value` 不大于 0，那么程序将会终止，并在标准错误输出中显示一条错误消息，指示在哪个文件、行数以及断言失败的条件。

使用 `assert` 有以下几点要注意：

1. **仅用于调试：** `assert` 应该仅在调试阶段使用，用于检查开发过程中的假设和条件，以帮助发现错误。在发布版本中，`assert` 默认是被禁用的。

2. **不要影响程序逻辑：** `assert` 的条件应该是可以被确定的，而不是取决于用户输入或不稳定的环境因素。

3. **避免副作用：** 在 `assert` 的条件中不要包含会改变程序状态的表达式，因为在发布版本中这些表达式将不会被执行。

4. **自定义错误消息：** 可以在条件后添加自定义错误消息，以提供更具体的信息。

5. **编译选项控制：** 在发布版本中，默认情况下，`assert` 会被禁用。您可以通过在编译时定义 `NDEBUG` 宏来显式禁用 `assert`。

```cpp
#define NDEBUG
#include <cassert>
```

总之，`assert` 是一个在调试时用于快速检查条件是否为真的有用工具，但在发布版本中应该被禁用，以避免不必要的开销。

## 类

###  = default

该方式用于类的构造函数，当我们定义了自己的构造函数，但是又希望提供对于默认构造函数的实现时，可以通过如下的方式要求编译器提供默认构造函数的实现。

```cpp
class Test{
	Test() = default;
	//something...
}
```

### this

- 在类内调用对象本身时，可以使用this指针来表示对象本身
- 在类的函数的实现中，无论是在类内部还是外部，同样可以通过this指针调用对象本身。
- 如果要在类的函数中返回这个对象本身，则只需要对该对象的this指针解引用即可返回对象本身。即`return *this`

### 友元

如果我们希望类以外的函数或者其他类可以访问该类中的非公有成员，则可以使用`friend`关键字来将函数或者类定义为友元的。

```cpp
class Test_Friend{
	//something...
}
class Test{
	friend class Test_Friend;
	//something...
}
```

友元声明只能出现在类的内部，但是不限定类中的具体位置。类似的，友元声明不受到`private`以及其他访问修饰符的干涉，不会干扰到友元函数或类的声明。

友元函数是在类的定义中声明的一个函数，它可以访问类的私有成员和保护成员。友元函数不是类的成员函数，但它可以在类的作用域内访问类的非公有成员。

友元函数的利与弊如下：

利：

1. **访问私有成员：** 友元函数允许在类的外部访问类的私有成员，从而在某些情况下提供了更灵活的权限控制。

2. **增强封装性：** 友元函数可以被用来实现一些与类相关但不适合成为类的成员函数的操作，从而更好地封装类的数据和行为。

3. **提高可读性：** 在一些情况下，友元函数可以提高代码的可读性和理解性，尤其是当它涉及类内部的复杂数据结构时。

4. **继续使用非成员函数：** 有时，已经存在的非成员函数需要访问类的私有成员，而将其设置为友元函数可以避免修改原有代码。

弊：

1. **破坏封装性：** 友元函数允许访问私有成员，这可能破坏类的封装性和信息隐藏，导致代码难以维护和理解。

2. **降低代码可维护性：** 由于友元函数可以在类的外部修改类的私有成员，这可能增加代码的复杂性和难以维护性。

3. **破坏继承关系：** 友元函数在继承体系中的行为可能不够直观，因为它不受派生类的继承影响。

4. **限制封装的效果：** 使用友元函数可能会限制封装的效果，因为这样的函数可以在类的外部操作内部数据。

在使用友元函数时，应权衡其利弊，并确保仔细考虑访问权限和封装性的需要。虽然友元函数可以提供一些灵活性，但过度使用可能导致代码的复杂性和不稳定性。

<font color="red">类似的，友元类可以访问它的友元的包括非公有成员在内的所有成员</font>

<font color="red">注意，友元关系是单向的。B是A的友元，B可以访问A的所有属性。但是这不意味着A可以访问B的所有属性。但是可以在B中声明A为友元，实现双向的友元关系。</font>

除了可以使B的类成为A的友元以外，也可以使A中的某个成员函数作为B的友元，而不需要将整个类声明为友元。方法是在B类中添加对于A中友元函数的声明。<font color="red">前提是，A中的该成员函数已在A中声明。</font>

如果一个类想把一组重载函数声明为友元，它仍然需要对这组函数中的每一个分别声明。

```cpp
class B{
	friend void A::function_name(parameters);
	//something...
};
```

<font color="red">只需要记住一个原则，每个类负责控制自己的友元类或友元函数。</font>

### 可变数据成员

在类的成员函数中，有时候我们会在形参列表后面加上const使得该函数中类的成员为const，即在该函数中不能修改类的对象及其属性。

然而有时候（少数）我们仍然希望能够修改对象的某个属性，即便在包含const声明的函数中（比如，我们想通过对象属性记录某个或者某些函数的调用次数）。

此时，我们可以通过`mutable`关键字将该属性声明为可变的，可变数据成员永远都不是const。

```cpp
class Test{
	private:
		mutable int count = 0;
		int data = 666;
	public:
		void something() const{
			this.count++; // this is legal
			this.data++; // this is illegal
		}
}
```

### 委托构造函数

听上去高大上，实际上就是用成员初始值列表的方法让构造函数调用另一个构造函数来初始化部分或全部的成员。有点像Java中的在构造函数中调用super方法来帮助初始化一些属性。

```cpp
class Test{
	//something...
	Test(int a, int b, int c){}
	Test(int b, int c): Test(0, b, c){}
}
```

### 隐式的类类型转换

如果在定义构造函数时提供了仅包含一个参数的构造函数，则实际上也提供了该类的隐式转换机制。例如:

```cpp
class Test{
	private:
		string name;
	public:
		Test(){}
		Test(string name): name(name){
			//something...
		}
};
int main(){
	string str = "123";
	Test t = str;
}
```

值得注意的是，这样的隐式类型转换是一步的。也就是说，如果将字符串`"123"`改成数字`123`。则无法进行从`int`到`Test`的类型转换。

隐式类型转换并不是总是我们想要的，例如我们在类A中定义了一个接受类A对象作为参数的函数fun，同时类A中定义了一个从int到A类型的隐式转换构造函数。现在假设我们调用了函数fun，并提供了参数`123`。由于隐式转换构造函数的存在，fun参数中的对象会使用`123`来创建一个临时的A类型对象并执行操作。然而这并不一定是我们想要的，fun函数中可能需要用到A对象的其他属性，因此错误的隐式类型转换将会导致我们不希望的错误发生。

因此，我们可以使用关键字`explicit`关闭构造函数的隐式类型转换，该关键字仅对包含一个参数的构造函数有效。

使用了`explicit`关键字的构造函数将不能通过任何隐式方式构造（例如使用`=`赋值运算符，实质上是隐式的调用了构造函数并将创建的临时对象拷贝给了左值），只能通过直接初始化的方式创建（例如`Test test("123");`）

## lambda表达式

一个lambda表达一个匿名的函数，或者说一个可调用的代码单元。它可以理解成一个未命名的内联函数。

通常的lambda表达式具有一个返回类型、一个参数列表和一个函数体。通常形式为:

```cpp
[capture list](parameters) -> return type{
	//function body
}
```

其中，`capture list`称为捕获列表，当lambda表达式中需要用到定义它的函数中的局部变量时，应当在捕获列表中声明它。

其他部分与普通的函数相同，只是lambda必须使用尾置返回来指定返回类型。

<font color="blue">参数列表和返回类型这两项是可省略的。</font>也就是说可以写成这样的形式:

```cpp
[]{return;};
```

### 值捕获与引用捕获

与常规函数中的参数传递类似，lambda表达式的捕获列表中既可以传值也可以传引用。传值的前提条件是变量是可拷贝的。相较于常规函数不同的一点时，lambda表达式捕获列表中被捕获的变量值是在lambda表达式创建时拷贝，而不是调用时拷贝。

### 隐式捕获

如果我们希望由编译器来推断我们在lambda表达式中使用了哪些变量，可以在捕获列表中使用`&`或`=`符号来表示使用引用捕获或者值捕获的方式来隐式捕获局部变量。

```cpp
[&]{
//something
};
[=]{
//something
};
```

也可以使用隐式捕获与显式捕获混合的方式，下面的代码表示了隐式引用捕获，但是显式的值捕获了某个变量`c`

```cpp
[&, c]{
//something...
};
```

需要注意的是，混合使用隐式和显式捕获时，隐式捕获和显式捕获必须是不同的捕获方式。比如隐式捕获使用引用捕获，则显式捕获只能值捕获，反之亦然。

### 可变lambda

有时候我们如果想要在lambda表达式中修改使用<font color="red">值捕获</font>方式捕获到的变量值，则需要在参数列表后使用关键字`mutable`。

```cpp
[v1]() mutable{ return v1++;};
```

### 指定lambda的返回类型

如果一个lambda仅包含`return`语句，则该lambda表达式的返回类型可以自动推断，此时我们可以省略lambda表达式的尾置返回部分。

然而，如果一个lambda中包含了其他语句，则编译器默认lambda返回void。如果我们需要返回值，则必须显式的使用尾置返回的方式指定返回类型。

### lambda的类型

当我们编写一个lambda表达式是，实际上编译器会将其翻译成一个未命名类的未命名对象，其重载了函数调用运算符`operator()`，并可以看作是将lambda表达式中的内容作为函数的内容进行调用。

## 智能指针

智能指针大约可以分为两类，`shared_ptr`和`unique_ptr`。智能指针的作用在于动态管理创建的对象，但是它可以自动释放创建的对象。

`shared_ptr`允许多个指针指向同一个对象，而`unique_ptr`则“独占”指向的对象。

通常我们使用如下方式来创建一个`shared_ptr`:

```cpp
make_shared<T>(args)
```

其中，`T`为泛型模板，`args`则用于初始化`T`类型的对象。

### 引用计数

我们可以认为每个`shared_ptr`都包含一个引用计数，它的作用在于计算有多少个`shared_ptr`指向同一个对象。一旦一个`shared_ptr`的计数器变成0，则它会释放自己所管理的对象。

<font color="red">通常情况下，`shared_ptr`会在作用域结束后销毁由其创建的对象（当然，前提是该对象的引用计数为0）。或者在作用域内显式的调用`reset()`函数，也会达到同样的效果。然而，如果我们在一个函数中return了一个`shared_ptr`，而在调用函数处没有设置接收这个返回值的语句。则`shared_ptr`会在函数返回完毕后被销毁，但是由其创建的对象不会被销毁。且由于没有指针指向该对象，该对象会无法调用直到程序结束。</font>

### 悬垂指针

悬垂指针指的是，如果我们使用`new`和`delete`关键字来动态分配内存。即使一个指针在`delete`后指向的内存被正确的释放了，该指针本身仍然可能保存着它原来所分配的内存的地址（即使里面的内存已经不可用）。可以通过显式的使得指针指向`nullptr`来解决这个问题。

### 自定义的删除器

当我们是使用智能指针管理内存时，通常智能指针在作用域结束后会负责调用指向对象的析构函数并销毁自身。然而，如果对象中包含了<font color="red">非堆内存资源</font>（例如数据库连接、文件句柄等）的话，假设在调用析构函数过程中抛出了异常，可能无法正确释放掉对象所占用的资源。

在这样的情况下，我们可以通过自定义一个函数的方式来作为删除器，用于删除对象或其中的资源。例如：

智能指针通常用于管理动态分配的资源，如堆上的内存、文件句柄、数据库连接等。在这种情况下，智能指针的析构函数会自动调用对象的析构函数，从而释放资源。

自定义删除器通常在以下情况下使用：

1. **管理非堆内存资源**：当智能指针管理的对象包含了非堆内存资源（如文件句柄、数据库连接、自定义资源等）时，对象的析构函数无法自动释放这些资源。此时，可以使用自定义删除器来确保资源在对象销毁时被正确释放。

2. **动态分配的数组**：如果智能指针管理的对象是动态分配的数组，而不是单一对象，且这个数组是通过 `new[]` 分配的，那么默认的 `delete` 操作不能正确释放它。在这种情况下，可以使用自定义删除器来使用 `delete[]`。

3. **特殊资源管理需求**：有时，您可能需要进行自定义资源管理，例如使用特殊的释放函数或资源管理库。自定义删除器允许您完全控制资源的释放。

以下是一个示例，演示了在自定义删除器中管理文件句柄资源的情况：

```cpp
#include <iostream>
#include <memory>
#include <cstdio>

// 自定义的文件关闭删除器
struct FileCloser {
    void operator()(FILE* file) const {
        std::cout << "Custom file closer is called." << std::endl;
        if (file) {
            fclose(file); // 关闭文件
        }
    }
};

int main() {
    // 使用自定义删除器创建 shared_ptr，管理文件句柄资源
    std::shared_ptr<FILE> filePtr(fopen("example.txt", "w"), FileCloser());

    // 使用 shared_ptr 写入文件
    if (filePtr) {
        fprintf(filePtr.get(), "Hello, Custom Deleter!");
    }

    // 文件句柄将在 shared_ptr 超出作用域时自动关闭
    return 0;
}
```

在上述示例中，`FileCloser` 是一个自定义删除器，用于确保文件句柄在 `shared_ptr` 管理的对象销毁时自动关闭。这是一种处理非堆内存资源的常见方式。

### weak_ptr

`weak_ptr`是另一种智能指针，它指向一个由`shared_ptr`所管理的对象。

`std::weak_ptr` 是 C++11 引入的智能指针，用于解决 `std::shared_ptr` 可能导致的循环引用问题。`std::weak_ptr` 允许您创建一个指向 `std::shared_ptr` 管理的对象的“弱引用”，而不会增加该对象的引用计数。主要作用如下：

1. **避免循环引用**：在某些情况下，两个或多个对象彼此引用，导致它们的 `std::shared_ptr` 的引用计数永远不会降为零，因此对象永远不会被销毁。这种情况下，使用 `std::weak_ptr` 可以打破循环引用，允许对象在不再需要时正确地释放。

2. **安全地访问对象**：通过 `std::weak_ptr`，您可以安全地检查被管理对象是否仍然存在，而无需增加其引用计数。这可以防止访问已经被销毁的对象，从而提高了程序的安全性。

3. **协助 `std::shared_ptr`**：`std::weak_ptr` 通常与 `std::shared_ptr` 一起使用。通过 `std::weak_ptr`，您可以创建一个临时的“观察者”，观察一个由 `std::shared_ptr` 管理的对象，而不会阻止其被销毁。当需要使用被管理对象时，可以将 `std::weak_ptr` 转换为 `std::shared_ptr`（通过 `lock()` 成员函数），从而安全地访问被管理对象。

下面是一个示例，演示了 `std::weak_ptr` 的用法：

```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> shared = std::make_shared<int>(42);
    std::weak_ptr<int> weak = shared;

    // 使用 weak_ptr 检查对象是否存在
    if (auto locked = weak.lock()) {
        std::cout << "Value: " << *locked << std::endl;
    } else {
        std::cout << "Object has been destroyed." << std::endl;
    }

    // 当 shared_ptr 被销毁后，weak_ptr 仍然可以安全地使用
    shared.reset();

    if (auto locked = weak.lock()) {
        std::cout << "Value: " << *locked << std::endl;
    } else {
        std::cout << "Object has been destroyed." << std::endl;
    }

    return 0;
}
```

？在这个示例中，`std::weak_ptr` 用于观察 `std::shared_ptr` 所管理的对象，并且能够安全地检查对象的存在状态。如果 `std::shared_ptr` 被销毁，`std::weak_ptr` 仍然可以检测到对象的销毁情况，而不会导致未定义行为。这有助于避免循环引用问题和提高程序的健壮性。

## allocator类

通常，我们使用`new`和`delete`关键字或智能指针来动态管理内存。然而，在这样的情况下我们仍然可能造成内存的浪费，例如:

```cpp
string *str = new string[n];
```

如果我们实际上用不到`n`个字符串，那么在多分配的内存上构造`string`对象无疑是一种浪费。因此，标准库提供了`allocator`类，将分配内存与构造对象分离开来。例如：

```cpp
allocator<string> alloc;
auto const p = alloc.allocate(n); //分配n个未初始化的string
```

这两条语句仅仅是为`n个string`类型分配了内存，起始地址为`p`，并没有实际构建`string`对象，因此此时如果调用`*p`来得到对象是错误的。

## 拷贝控制

### 拷贝构造函数

如果一个构造函数的第一个参数是自身类型的引用，而其他额外参数都有默认值。则此函数为拷贝构造函数。

```cpp
class Test{
	Test();	// 默认构造函数
	Test(const Test&); //拷贝构造函数
}
```

拷贝构造函数通常在拷贝对象时进行调用，例如`string b = "99999";`就是对于拷贝构造函数的隐式调用。因此，拷贝构造函数通常不应该声明为`explicit`的。

如果我们没有为一个类定义拷贝构造函数，则编译器会默认定义一个。<font color="red">如同编译器会为自定义类生成默认的构造函数（该构造函数也称为合成构造函数）。</font>

然而，与编译器生成默认的合成构造函数的方式不同的是，默认的合成构造函数仅当我们没有定义默认的构造函数时才会生成。对于拷贝构造函数来说，即使我们没有定义拷贝构造函数，但是我们在定义了其他构造函数的情况下，编译器会为我们生成<font color="red">合成的拷贝构造函数</font>，它的作用在于将类对象的每个非static对象逐个拷贝到另一个对象中。

拷贝初始化，指的是要求编译器将拷贝中的右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换。

如果一个类有移动构造函数，则拷贝初始化有时候会使用移动构造函数而不是拷贝构造函数。

### 拷贝赋值运算符

类似于拷贝构造函数，如果类未定义自己的拷贝赋值运算符，编译器会为其合成一个合成拷贝赋值运算符。

自定义拷贝赋值运算符通过重载`=`运算符来实现，其目的在于正确的进行拷贝。考虑一个场景，假设某类对象中包含了一个指针，我们拷贝该对象中希望得到指针指向的对象副本而不是指向相同对象的两个指针。默认的由编译器生成的拷贝赋值运算符仅会简单的将指针指向同一对象，而不会为对象生成副本。自定义拷贝赋值运算符可以避免这一缺陷。<font color="red">这里也说明了深拷贝和浅拷贝的区别。</font>

以下是GPT的解释：

自定义拷贝赋值运算符的主要目的是确保对象在赋值时能够正确复制其内部状态，以避免错误的赋值行为。以下是一些常见的情况，其中您可能希望自定义拷贝赋值运算符：

1. **深拷贝 vs. 浅拷贝**：如果您的类包含指针成员或资源管理（如动态分配内存、文件句柄等），默认的拷贝赋值运算符将执行浅拷贝，这可能导致多个对象共享相同的资源，而不是复制资源本身。自定义拷贝赋值运算符允许您执行深拷贝，确保每个对象有其自己的资源副本。

2. **资源管理**：如果您的类负责管理某些资源（如内存、文件等），自定义拷贝赋值运算符可以确保在赋值时正确处理资源的释放和复制。

3. **自我赋值检查**：自定义的赋值运算符通常会包含自我赋值检查，以避免在对象自身赋值给自己时发生问题。例如，在 `if (this != &other)` 中检查对象是否自身赋值。

4. **异常安全性**：自定义赋值运算符可以提供更好的异常安全性。如果在赋值过程中发生异常，自定义的运算符可以确保不会泄漏资源，并将对象恢复到赋值前的状态。

5. **用户定义类型的特殊需求**：某些用户定义类型可能需要特定的赋值行为，与默认的浅拷贝行为不同。

总之，通过自定义拷贝赋值运算符，您可以更精确地控制对象的复制行为，确保其适用于您的特定类和用例，以提高代码的正确性和安全性。

### 析构函数

析构函数发生在类的对象被销毁时，对象的属性按照初始化顺序的相反顺序进行销毁。如果属性是类的对象，则执行对应的析构函数。如果是内置类型，则什么也不做。由`new`关键字进行动态内存分配的普通指针在析构函数中不会`delete`，因此需要手动`delete`来释放内存。而智能指针则由于是类，因此会自动执行类的析构函数来释放其管理的对象占用的内存。

### 补充说明

对于普通的构造函数、拷贝赋值函数等函数，我们都可以使用`=default;`要求编译器生成默认的合成版本。

### 阻止拷贝

对于某些特定的类（例如`iostream`类等），我们可能不希望拷贝操作发生，因为我们不希望多个对象读写相同的IO缓冲。

然而，即使我们不重写拷贝构造函数等，编译器也会生成默认的版本。因此要阻止拷贝操作的发生，我们应该使用`=delete;`来将函数声明为删除的。删除的函数即便经过了声明，也不能通过任何方法使用。

```cpp
class Test{
	Test();
	Test(const Test&) = delete;
	Test& operator=(const Test&) = delete;
}
```

<font color="blue">析构函数不能被定义为删除的，因为没有析构函数的话对象就无法销毁了。</font>

### 拷贝控制和资源管理

通常，管理类以外的资源的类必须定义拷贝控制成员（拷贝控制成员指的就是拷贝构造函数、拷贝控制运算符等）。而我们定义拷贝控制成员，则需要确定其语义。

简单点来说，我们是否希望在拷贝类的对象的时候，共享类对象中所包含的资源？还是为每个对象所包含的资源创建一个拷贝？

比如标准库中常见的`string`类，我们通过拷贝赋值运算符创建其拷贝时，实质上创建了一个对象的副本。尽管其中字符串的内容相同，实际上分配到的内存仍然是不同的。

而如果我们假设自定义了一个类，该类中用到了关于数据库的资源。通常情况下我们如果要创建两个对象，一个专门用于向数据库添加数据，另外一个专门用于删除数据库中的数据。我们可以使得两个对象共享一个数据库链接，此时拷贝赋值运算符中就可以将第二个对象中的数据库链接设置为第一个对象数据库链接的引用。

综上所述，拷贝控制成员的语义通常分为两类。一类是行为类似于值的，此时拷贝会得到其副本。另一类是行为类似于引用的，此时拷贝会得到一个共享同一对象的引用。

#### 行为像值的类

为了提供类似值的行为，对于类管理的资源，每个对象都应该拥有一份自己的拷贝。

### 行为像指针的类

对于行为类似于指针的类，我们同样需要为其定义拷贝构造函数以及拷贝赋值运算符，通过这样的方式来拷贝指针指向的内存地址而不是对应的地址中的对象的副本。

然而，存在着一个潜在的问题。

假设我们定义了一个对象并将其拷贝了两次，那么我们就得到了3个对象，对象中的指针属性指向了同一个内存地址。

通常情况下我们需要手动管理动态分配的内存，那么当第1个对象被回收的时候，显然我们的析构函数中应该包含了针对指针的`delete`。

但是这样产生的问题就是，第2和第3个对象仍然指向了第1个对象`new`出来的内存地址，此时由于`delete`的原因该地址已无效。继续使用该指针会引发问题。

一种最简单的方法就是在类的对象属性中需要用到指针的地方使用智能指针`shared_ptr`，这样不需要再在析构函数中显式调用`delete`，销毁第1个对象的时候也不会回收指针指向的内存地址。

第二种方法就是自定义引用计数，为了得到针对当前对象有多少个拷贝，我们需要使用一个`int *`类型的指针来得到针对当前对象的拷贝数量。具体如下：

- 创建第1个对象时，为引用计数指针分配内存，并将其值设置为1。
- 每次调用拷贝构造函数或使用拷贝赋值运算符时，将新的对象中的引用计数指针指向被拷贝的对象中引用计数指针的地址，实现计数的共享。
- 每次调用析构函数时，需要将引用计数-1。-1后如果引用计数为0，则将对象中动态分配的内存（包括为引用计数指针分配的内存）进行`delete`。

## 右值引用

所谓右值引用，就是与右值进行绑定的引用。通过`&&`符号来表示一个右值引用。右值引用只能绑定到一个即将销毁的对象上。

<font color="red">一旦某个右值，有了名字，也就在内存中有了位置，它就变成了一个左值。</font>

一般而言，一个左值表达式表达的是一个变量（或者说对象）本身这样的一重身份（或者说可变的性质）。而一个右值表达的是一个固定的变量值或对象的值。

右值引用（Rvalue reference）是C++11引入的一种引用类型，用于表示对临时对象（右值）的引用。与左值引用（Lvalue reference）不同，右值引用允许我们修改临时对象，以及通过移动语义来实现高效的资源管理。

右值引用的语法是在类型名后面加上两个“&&”，例如：

```cpp
int&& rvalue_ref = 42; // 右值引用绑定到临时对象
```

右值引用的主要意义和用途包括：

1. **移动语义（Move Semantics）**：右值引用的引入是为了支持移动语义，它允许将资源（例如内存）从一个对象移动到另一个对象，而不是复制。这在容器类如std::vector和std::string等的实现中非常有用，可以提高性能。

2. **完美转发（Perfect Forwarding）**：右值引用可以在函数参数中使用，用于完美转发参数，将参数原封不动地传递给其他函数。这在实现通用函数模板时非常有用，允许传递不同类型的参数，并保持它们的值类别（左值或右值）。

```cpp
template <typename T>
void forward(T&& arg) {
    some_function(std::forward<T>(arg));
}
```

3. **减少临时对象的创建和销毁**：右值引用可以用于绑定临时对象，避免创建不必要的临时对象，从而提高性能。

4. **移动构造函数和移动赋值运算符**：右值引用通常与移动构造函数和移动赋值运算符一起使用，以实现高效的资源管理，如动态内存分配和释放。

总之，右值引用在C++中引入了一些强大的特性，能够提高代码的性能和表达能力，特别是在处理大型数据结构和资源管理时。然而，正确使用右值引用需要谨慎，因为它们与左值引用有不同的行为，可能导致潜在的问题，如悬空引用和不必要的移动操作。因此，要在适当的场合和情境下使用右值引用，并遵循最佳实践以确保代码的正确性和性能。

---



理解移动语义和完美转发的概念可能需要一些具体的例子来帮助解释。让我用更具体的方式来解释它们。

**移动语义（Move Semantics）**：

移动语义是一种机制，允许将资源（例如内存或文件句柄）从一个对象转移到另一个对象，而不是进行复制。这可以显著提高程序的性能，尤其是在处理大量数据或复杂对象时。移动语义通常与右值引用一起使用。

考虑一个简单的示例，假设有一个类 `MyString` 代表字符串，它包含一个动态分配的字符数组。传统的复制操作会创建一个新的字符数组并复制数据，而移动操作可以将原来的字符数组的所有权转移到新对象上，从而避免不必要的复制：

```cpp
class MyString {
public:
    MyString(const char* str) {
        // 分配内存并复制字符串
    }

    // 移动构造函数，使用右值引用
    MyString(MyString&& other) {
        // 转移资源的所有权
    }
};

MyString CreateString() {
    MyString temp("Hello");
    return temp; // 移动语义将temp的资源转移到返回的对象上
}
```

在上面的示例中，`CreateString` 函数返回一个临时对象，但由于使用了移动语义，不会复制字符串数据，而是将其所有权转移到返回的对象上，从而提高了性能。

**完美转发（Perfect Forwarding）**：

完美转发是一种技术，允许函数将其接收到的参数原封不动地传递给其他函数，而不会引入不必要的额外复制或修改。这在编写通用函数模板时非常有用。

考虑以下示例，其中有一个通用函数模板 `Wrapper`，它接收一个参数并将其传递给另一个函数 `Process`：

```cpp
template <typename T>
void Process(T value) {
    // 处理参数
}

template <typename T>
void Wrapper(T&& value) {
    Process(std::forward<T>(value)); // 完美转发参数
}
```

在这里，`Wrapper` 函数使用了右值引用和 `std::forward` 来实现完美转发。不论传递给 `Wrapper` 的参数是左值还是右值，它都能将参数原封不动地传递给 `Process` 函数，而不会引入额外的复制或修改。这有助于保持参数的值类别，并提高了代码的灵活性。

---



完美转发是一种高级的C++技术，用于将函数接收到的参数原封不动地传递给其他函数，同时保留参数的值类别（左值或右值）。这允许编写通用的函数模板，能够处理各种类型的参数，并确保不会引入不必要的复制或修改。下面我将使用更具体的示例来解释完美转发。

首先，让我们看一个简单的函数模板 `Wrapper`，它接收一个参数并将其传递给另一个函数 `Process`：

```cpp
template <typename T>
void Process(T value) {
    // 处理参数
}

template <typename T>
void Wrapper(T value) {
    Process(value); // 将参数传递给Process
}
```

上述代码中，`Wrapper` 接收一个参数 `value`，然后将其传递给 `Process` 函数。这看起来很简单，但有一个问题：它会复制传递给 `Wrapper` 的参数，无论传递的是左值还是右值，都会生成一个新的对象。这可能不是我们想要的行为。

现在，让我们使用完美转发来改进这个示例：

```cpp
template <typename T>
void Process(T&& value) {
    // 处理参数
}

template <typename T>
void Wrapper(T&& value) {
    Process(std::forward<T>(value)); // 完美转发参数
}
```

在这里，我们对 `Process` 函数的参数使用了右值引用 `T&&`，并在 `Wrapper` 中使用 `std::forward` 来将参数 `value` 原封不动地传递给 `Process`。这就是完美转发的核心思想。

现在，无论我们将左值还是右值传递给 `Wrapper`，`Process` 函数都能以适当的方式接收参数，不会引入额外的复制，同时保持参数的值类别。这就是完美转发的用途之一：编写通用函数，能够处理各种参数类型，并在传递参数时保持参数的原始性质。

示例中的 `std::forward` 模板函数的作用是根据参数的值类别（左值或右值）来选择将参数作为左值引用或右值引用传递给 `Process` 函数，从而实现完美转发。

总之，完美转发是一种高级技术，用于编写通用函数，能够处理各种类型的参数，同时保持参数的原始性质，避免不必要的复制和修改。这在实现通用库或模板时非常有用。

---

`std::forward` 是C++标准库中的一个模板函数，它的主要作用是在函数模板中实现完美转发（perfect forwarding）。它的用途是根据传递给它的参数的值类别（左值还是右值）来选择将参数作为左值引用或右值引用传递给其他函数，从而保留参数的原始性质。

在完美转发的场景中，我们通常有一个模板函数，该函数接受一个参数并将其传递给另一个函数，但我们希望确保传递参数的同时不引入不必要的复制或修改。`std::forward` 在这种情况下非常有用，因为它可以帮助我们保留参数的值类别，即使参数是左值或右值。

```cpp
template <typename T>
void Process(T&& value) {
    // 处理参数
}

template <typename T>
void Wrapper(T&& value) {
    Process(std::forward<T>(value)); // 使用std::forward来实现完美转发
}
```

在上述示例中，`Wrapper` 函数接收一个参数 `value`，然后使用 `std::forward` 将参数 `value` 原封不动地传递给 `Process` 函数。`std::forward` 的作用是根据 `value` 的值类别来确定是将其作为左值引用还是右值引用传递给 `Process`。

- 如果 `value` 是左值，`std::forward` 将其作为左值引用传递给 `Process`，保持了参数的左值性质。
- 如果 `value` 是右值，`std::forward` 将其作为右值引用传递给 `Process`，保持了参数的右值性质。

这样，`Process` 函数能够正确地接收参数，并在传递参数的同时保持参数的原始性质，不会引入额外的复制或修改。

总之，`std::forward` 的主要作用是在完美转发的情况下，根据参数的值类别来选择正确的引用类型，以确保参数能够被原封不动地传递给其他函数，从而实现高效的参数传递。它是C++中实现通用代码和模板的重要工具之一。

## 虚函数

其实就是`Java`中定义的接口，只不过C++中采用的方式是在函数声明之前加上`virtual`，表明这个函数并不由类本身来实现，而是由其派生出来的子类进行自定义。

### 纯虚函数

有时候，对于基类中的某些成员函数，在缺乏必要信息的情况调用基类的该函数是没有意义的。且该函数依赖于派生类的各自实现。此时应该将函数定义为纯虚的，方法是在函数声明的后面加上`=0`。

纯虚函数和虚函数的区别主要在于，虚函数可以定义。而纯虚函数只有在类的外部可以定义，也就是说在类内的部分是不能进行定义的。

<font color="red">如果一个类含有（或者继承了但是没有重载）纯虚函数的类是抽象基类，抽象基类不能实例化对象，因为它包含了未经过定义的函数。</font>

## 模板

我更喜欢称其为泛型，通常用法是:

```cpp
template <typename T>
T function_name(T& ){
	//body
}
```

通过这样的方式，当实际调用该函数时，编译器会根据函数的实参类型来实例化相应的函数。

其中，T被称为模板的类型参数。

### 非类型模板参数

除了可以定义模板类型参数以外，还可以定义非类型的模板参数。通过一个特定的类型名而不是关键字`class`或`typename`来指定一个非类型模板参数。

非类型模板参数和类型模板参数的区别在于，非类型模板参数表示一个值，而不是一个类型。例如：

```cpp
template<unsigned N, unsigned M>
int compare(const char (&p1)[N], const char (&p2)[M]){
	return strcmp(p1, p2);
}
```

在实际调用该函数时，`N`和`M`将会根据实参的大小来代替。例如:

```cpp
compare("Hi", "Hello");
```

将会使用字面值3和6来代替N和M（别忘了`\0`）



