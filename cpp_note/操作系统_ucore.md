# 笔记

## 第一章 操作系统概述

本课程为清华大学操作系统课程，主要讲述以下模块：

- 中断和系统调用：中断是软件和硬件的联结，而系统调用是应用软件和系统软件的联结。
- 内存管理：负责调度内存资源，包括物理内存和虚存。
- 进程和线程：负责程序运行过程的调度
- CPU调度：进程共用处理器时的时间共享
- 进程间通信：同步互斥
- 文件系统：组织文件，便于读写和查找
- I/O子系统：使用较为统一性的接口对不同的外设兼容

### 1.1 操作系统定义

- 操作系统可以看作是一种控制程序，控制各个程序的执行，以防止不当的使用并为使用者提供服务。
- 操作系统可以看作是软件和硬件之间的中间层，它协调软硬件之间的通信并完成相应的任务。

操作系统是一种系统软件，它对外提供的接口是`Shell`和`GUI`。

操作系统的内核包含以下特征：

- 并发：多个程序同时运行
- 共享：宏观上程序共享CPU，微观上它们之间是互斥的，CPU不存在真正的意义上的同步。
- 虚拟：使用多道程序技术，让每个用户都感到自己被单独服务。
- 异步：保证异步程序执行的正确性（比如，当一个程序在运行过程中时间片耗尽而进入等待，操作系统需要保存它当前的状态并能够在下次执行时能在正确的状态下）。

### 1.2 操作系统的难点

- 代码量大
- 并发性和琐碎的调度算法的挑战。
- 高效性、低耗性、稳定性需求，具有一定的硬件编程的性质。
- 锁的问题：操作系统底层必须互斥
- 权衡：时间-空间、性能和可预测性、公平和性能等
- 管理**原始**硬件：中断、异常、上下文切换、TLB和页表、汇编语言

### 1.3~1.5 重点

这部分描述了操作系统的发展流程，具体百度即可。

操作系统的结构也分为好几种：

- 分层结构，逐层向上进行封装。
- 微内核结构，应用程序直接和内核功能进行交互。
- 外核结构，将部分物理资源分给多个程序，让每个程序决定如何处理这些资源。（虚拟机就是一种外核结构）

### 额外知识：CPU的运行模式

实模式（Real Mode）和保护模式（Protected Mode）是指中央处理器（CPU）的两种不同的运行模式，主要存在于Intel x86架构的处理器中。

**实模式：**
实模式是最初的8086和8088处理器所运行的模式，也是所有x86处理器在启动时的默认模式。在实模式下，CPU寻址是直接的，它使用20位地址总线，可以直接访问1MB的内存空间。实模式不支持高级的内存管理功能，如分页或内存保护。由于没有内存保护，任何程序都可以访问任何内存地址，这就意味着一个程序可以轻易地干扰另一个程序的运行，导致系统不稳定。

**保护模式：**
保护模式首次出现在80286处理器中，它提供了更高级的内存管理能力。在保护模式下，CPU使用32位（或在更现代的处理器中使用64位）地址总线，可以访问超过1MB的内存。保护模式引入了分段和分页机制，允许操作系统实现进程间的内存隔离，从而提高了系统的稳定性和安全性。此外，保护模式支持多任务处理，允许多个程序同时运行，而不会互相干扰。

**其他模式：**

- **虚拟8086模式：** 这是保护模式下的一个特殊模式，允许保护模式的操作系统在一个受保护的环境中运行实模式程序。这种模式常用于运行旧的DOS程序。

- **长模式（Long Mode）：** 这是在64位x86处理器上运行的模式，它支持64位的内存寻址，可以访问更大的内存空间。长模式同时支持运行32位和64位的应用程序。

- **系统管理模式（System Management Mode, SMM）：** 这是一种特殊的操作模式，用于处理系统级的功能，如电源管理和硬件控制。这个模式通常对操作系统是不可见的。

- **无管理模式（Unreal Mode）：** 这不是官方的CPU模式，而是通过对实模式的一些操作来扩展访问超过1MB内存的非正式模式。

每种模式都有其特定的用途和操作环境，随着计算机硬件的发展，新的模式和功能不断被引入以满足现代计算的需求。

## 第二章 启动、中断、异常和系统调用

### 2.1 计算机系统的启动过程

<font color="red">cpu加电后，执行的第一条指令在**内存**中。</font>

但是作为一个随机读写存储器（RAM），我们早就学过它的特点就是断电后丢失数据，那么哪来的指令让cpu去读呢？cpu为什么知道要去内存读呢？

这里课程里讲的真没听太懂，完整介绍流程在<[BIOS固件-电脑开机的启动流程 - tyong - 博客园 (cnblogs.com)](https://www.cnblogs.com/tyong/articles/10141205.html)>。这里给出个人理解的流程：
$$
BIOS\rightarrow硬件自检\rightarrow启动顺序\rightarrow存储设备
\\
\rightarrow主引导记录\rightarrow分区表\rightarrow活动分区\rightarrow卷引导记录
\\
\rightarrow启动管理器\rightarrow列出可启动的操作系统供用户选择\rightarrow加载操作系统
$$
计算机的整个启动过程分为四个阶段：

#### 第一阶段：BIOS

上个世纪70年代初，"只读内存"（read-only memory，缩写为ROM）发明，开机程序被刷入ROM芯片，计算机通电后，第一件事就是读取它。

这块芯片里的程序叫做"基本输入输出系統"（Basic Input/Output System），简称为BIOS。

##### 硬件自检

BIOS程序首先检查，计算机硬件能否满足运行的基本条件，这叫做"硬件自检"（Power-On Self-Test），缩写为POST。

如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止。如果没有问题，屏幕就会显示出CPU、内存、硬盘等信息。

##### 启动顺序

硬件自检完成后，BIOS把控制权转交给下一阶段的启动程序。

这时，BIOS需要知道，"下一阶段的启动程序"具体存放在哪一个设备。也就是说，BIOS需要有一个外部储存设备的排序，排在前面的设备就是优先转交控制权的设备。这种排序叫做"启动顺序"（Boot Sequence）。

打开BIOS的操作界面，里面有一项就是"设定启动顺序"。

#### 第二阶段：主引导记录


BIOS按照"启动顺序"，把控制权转交给排在第一位的储存设备。

这时，计算机读取该设备的第一个扇区，也就是读取最前面的512个字节。如果这512个字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给"启动顺序"中的下一个设备。

这最前面的512个字节，就叫做"主引导记录"（Master boot record，缩写为MBR）。

> 0x55 和 0xAA 是两个十六进制数，分别对应于十进制的 85 和 170。在计算机中，这两个数通常作为主引导记录（MBR，Master Boot Record）的最后两个字节，用来标识一个有效的引导扇区。
>
> MBR 是硬盘的第一个扇区（通常是 512 字节），它包含了启动计算机操作系统所需的代码和分区表。MBR 的结构通常如下：
>
> - 引导代码（Boot code）：这部分包含了一些基本的代码，用于启动计算机。
> - 分区表（Partition table）：描述硬盘分区的信息。
> - 签名字节（Signature bytes）：0x55 和 0xAA，位于扇区的最后两个字节（第 511 和第 512 字节）。
>
> 使用 0x55 和 0xAA 作为标识符的原因主要是历史和传统。这两个字节作为“魔术数字”（magic numbers），在早期的IBM PC 兼容机中被用来标识一个扇区是否是可引导的。这个约定被广泛接受，并成为了行业标准。选择这两个特定的值可能是因为它们的位模式（0x55 = 01010101b，0xAA = 10101010b）在某种程度上是互补的，这种模式可能有助于错误检测。
>
> 在计算机引导过程中，BIOS（基本输入输出系统）会检查连接的存储设备的第一个扇区的最后两个字节，如果这两个字节是 0x55 和 0xAA，BIOS 就会认为这是一个有效的引导扇区，并从中加载引导代码来启动操作系统。如果这两个字节不是 0x55 和 0xAA，BIOS 将认为该扇区不是一个有效的引导扇区，将不会从该设备启动，并会继续检查其他设备。
>
> <font color="blue">Question:</font>    假如我的启动顺序最前面是光盘，然后是硬盘。但是在启动计算机时，我并没有放入光盘。那计算机究竟是跳过光盘启动还是说有什么办法知道没有光盘，接着从硬盘尝试读主引导记录并启动？
>
> <font color="green">Answer:</font>    当计算机启动时，BIOS（基本输入输出系统）会根据设置的启动顺序来检查每个设备是否包含可启动的媒体。如果您的启动顺序中光盘驱动器排在硬盘之前，BIOS会首先检查光盘驱动器。
>
> 如果光盘驱动器中没有光盘，或者光盘不是一个启动盘，BIOS会检测到光盘驱动器中没有可启动的媒体。这通常是通过尝试读取光盘的启动扇区来完成的。如果读取失败或者启动扇区不包含有效的启动签名（例如，不包含0x55和0xAA这样的魔术数字），BIOS会认为光盘驱动器不包含有效的启动记录。
>
> 在确认光盘驱动器中没有可启动媒体之后，BIOS会继续按照启动顺序检查下一个设备，也就是硬盘。然后，BIOS会尝试从硬盘的主引导记录（MBR）读取启动信息。如果硬盘的MBR是有效的（即包含正确的启动签名），BIOS会从硬盘加载MBR中的引导代码，并开始操作系统的启动过程。
>
> 如果所有配置的启动设备都没有找到可启动的媒体，BIOS通常会显示一条错误消息，例如“No bootable device”或“Insert boot media in selected boot device and press a key”，提示用户没有找到可启动的设备。

##### 主引导记录的结构

"主引导记录"只有512个字节，放不了太多东西。它的主要作用是，告诉计算机到硬盘的哪一个位置去找操作系统。

主引导记录了由三个部分组成：

1. 第1~446字节：446字节，调用操作系统的机器码
2. 第447~510字节：64字节，分区表（Partition table）
3. 第511~512字节：主引导记录签名（0x55和0xAA）

其中，第二部分"分区表"的作用，是将硬盘分成若干个区。

##### 分区表

考虑到每个区可以安装不同的操作系统，"主引导记录"因此必须知道将控制权转交给哪个区。

分区表的长度只有64个字节，里面又分成四项，每项16个字节。所以，一个硬盘最多只能分四个一级分区，又叫做"主分区"。

每个主分区大小均为16字节，分为6个部分：

1.  第1个字节：如果为0x80，就代表该主分区是激活分区，控制权要转交给这个分区。四个主分区里面只能有一个是激活的。
2.  第2~4字节：主分区第一个扇区的物理位置（柱面、磁头、扇区号等）。
3.  第5个字节：主分区类型。
4.  第6~8字节：主分区最后一个扇区的物理位置。
5.  第9~12字节：该主分区的第一个扇区的逻辑地址。
6.  第13~16字节：主分区的扇区总数。

最后的四个字节（"主分区的扇区总数"），决定了这个主分区的长度。也就是说，一个主分区的扇区总数最多不超过2的32次方。

如果每个扇区为512个字节，就意味着单个分区最大不超过2TB。再考虑到扇区的逻辑地址也是32位，所以单个硬盘可利用的空间最大也不超过2TB。如果想使用更大的硬盘，只有2个方法：一是提高每个扇区的字节数，二是增加扇区总数。

> 你提到的内容是关于传统的MBR（Master Boot Record）分区表的结构和限制。MBR是硬盘的一种分区方案，它存在于硬盘的最前面，是硬盘启动的关键所在。MBR中包含了启动代码和分区表信息，而分区表就是用来记录硬盘分区情况的数据结构。
>
> 你的描述非常准确，MBR分区表中确实只有64个字节用于描述分区，分成四个16字节的分区表项，每个表项描述一个主分区。这里的限制是每个硬盘最多只能有四个主分区，或者三个主分区加一个扩展分区。扩展分区可以被进一步分割成多个逻辑分区。
>
> 关于MBR的限制，你提到了两个主要的点：
>
> 1. 单个分区大小的限制：由于分区表中记录扇区总数的字段是一个32位的数，所以最大值是$2^{32-1}$个扇区。如果每个扇区大小为512字节，那么最大数量分区情况下总大小为$512 * 2^{32}$字节，即`2TB`。
>
> 2. 硬盘大小的限制：由于MBR使用32位地址来记录扇区位置，所以它最多只能寻址到2^32个扇区，这同样限制了硬盘的最大大小为2TB（如果扇区大小为512字节）。
>
> 为了解决这些限制，现代计算机系统通常使用GPT（GUID Partition Table）分区方案。GPT不受MBR的这些限制，因为它使用64位的地址来记录扇区位置，这使得理论上的最大分区和硬盘大小可以达到ZB（Zettabytes）级别，远远超过了当前硬盘技术的容量。
>
> 此外，GPT分区表存储在硬盘的前面和后面，提供了冗余保护，即使一部分数据损坏，也能恢复分区信息。GPT还包含了对分区的名称和类型的描述，以及其他的一些先进特性，使得它成为了大容量硬盘的首选分区方案。

在硬盘上，分区格式的信息是存储在硬盘的前面几个扇区中的。对于MBR和GPT分区格式，这些信息的存储方式有所不同：

1. **MBR（Master Boot Record）**：在MBR分区格式中，分区信息存储在硬盘的第一个扇区（通常称为扇区0）。这个扇区包含了启动代码（Bootstrap Code）、分区表和一个有效性标志（通常是0x55AA）。BIOS在启动过程中会读取这个扇区，并根据其中的代码和分区表来加载操作系统。

2. **GPT（GUID Partition Table）**：GPT分区格式采用了不同的方式。它在硬盘的第一个扇区也存储了一个保护性MBR（Protective MBR），这是为了向后兼容那些只能识别MBR的工具。保护性MBR的分区表只包含一个条目，这个条目占据了整个硬盘，但实际上并不用于分区。真正的GPT头部信息是存储在硬盘的第二个扇区，它包含了GPT分区表的位置、大小和循环冗余校验（CRC）校验值等信息。GPT分区表本身则紧随GPT头部信息之后。

对于BIOS和GPT的兼容性问题，事实上传统的BIOS并不支持GPT分区格式。BIOS是在UEFI之前的固件标准，它只能识别MBR分区表。如果你的计算机使用的是传统的BIOS固件，那么它无法直接从GPT分区的硬盘启动操作系统。

相反，UEFI（Unified Extensible Firmware Interface）是一种现代的固件接口标准，它支持GPT分区格式。UEFI在启动时会读取GPT的头部信息，确定分区表的位置，然后根据分区表加载EFI系统分区（ESP），ESP包含了用于启动操作系统的EFI应用程序（如引导加载程序）。

因此，如果你的硬盘使用GPT分区，并且你希望从该硬盘启动操作系统，你需要确保你的计算机使用的是UEFI固件，而不是传统的BIOS。现代计算机通常都支持UEFI，并且默认使用UEFI模式。在UEFI模式下，计算机可以识别GPT分区格式，并从中启动操作系统。

> <font color="blue">question:</font>    "保护性MBR的分区表只包含一个条目，这个条目占据了整个硬盘"，这是什么意思？
>
> <font color="green">answer:</font>    保护性MBR（Protective MBR）是GPT（GUID Partition Table）分区方案的一部分，它位于硬盘的第一个扇区，也就是传统MBR的位置。保护性MBR的目的是为了保护GPT分区的硬盘免受不支持GPT的旧式系统和工具的干扰。
>
> 在保护性MBR中，分区表通常只包含一个条目，这个条目的类型被设置为0xEE，这是一个特殊的分区类型，用来指示整个硬盘或者一个很大的区域已经被GPT占用。这个条目并不指向实际的文件系统或数据分区，而是作为一个标记存在，告诉任何可能读取MBR的软件：“这个硬盘使用的是GPT分区方案，你不应该试图用MBR的方式来管理它。”
>
> 这个条目通常会从硬盘的第一个可用扇区开始，直到硬盘的最后一个扇区，覆盖整个硬盘的范围。这样做的目的是为了防止不支持GPT的系统和工具错误地认为硬盘未分区，并试图在硬盘上创建新的MBR分区，这可能会导致数据丢失。
>
> 因此，保护性MBR是一种兼容性措施，确保了GPT分区的硬盘在旧系统中不会被误操作，同时允许支持GPT的系统正确识别和使用硬盘。真正的GPT分区信息存储在硬盘的其他位置，通常是从第二个扇区开始的GPT头部，紧接着是分区表本身。
>
> 
>
> <font color="blue">question:</font>    也就是说，假设我在旧式的BIOS上读取了一块硬盘，而这块硬盘采取的是GPT格式的分区方式。BIOS会尝试读取扇区0，然后读取到0xEE，它会认为这不是一个激活分区。因此它会跳过这个硬盘尝试去别的硬件上寻找系统。
>
> <font color="green">answer:</font>    是的，您的理解基本正确。在旧式的BIOS系统中，当BIOS尝试读取采用GPT格式分区的硬盘时，它会首先检查扇区0，也就是MBR所在的位置。在这种情况下，它会发现保护性MBR，其中包含一个类型为0xEE的分区条目，这个条目覆盖整个硬盘。
>
> BIOS会识别到这个特殊的分区类型，但由于BIOS不支持GPT，它不会理解这个分区条目的真实含义。BIOS可能会认为这个硬盘不包含任何有效的可启动分区，因为0xEE类型的分区不是一个可启动的分区类型。因此，BIOS不会从这个硬盘启动操作系统，而是会继续搜索其他可能包含有效MBR和可启动分区的硬盘或启动设备。
>
> 这就是保护性MBR的作用：它防止了BIOS基于错误的假设（即硬盘使用MBR分区表）对硬盘进行操作，同时也向BIOS表明这个硬盘使用了一种它不理解的分区方案。这样可以减少数据损坏的风险，并确保只有支持GPT的系统（如UEFI固件）才能管理和启动这个硬盘上的操作系统。