# 笔记

## 第一章 操作系统概述

本课程为清华大学操作系统课程，主要讲述以下模块：

- 中断和系统调用：中断是软件和硬件的联结，而系统调用是应用软件和系统软件的联结。
- 内存管理：负责调度内存资源，包括物理内存和虚存。
- 进程和线程：负责程序运行过程的调度
- CPU调度：进程共用处理器时的时间共享
- 进程间通信：同步互斥
- 文件系统：组织文件，便于读写和查找
- I/O子系统：使用较为统一性的接口对不同的外设兼容

### 1.1 操作系统定义

- 操作系统可以看作是一种控制程序，控制各个程序的执行，以防止不当的使用并为使用者提供服务。
- 操作系统可以看作是软件和硬件之间的中间层，它协调软硬件之间的通信并完成相应的任务。

操作系统是一种系统软件，它对外提供的接口是`Shell`和`GUI`。

操作系统的内核包含以下特征：

- 并发：多个程序同时运行
- 共享：宏观上程序共享CPU，微观上它们之间是互斥的，CPU不存在真正的意义上的同步。
- 虚拟：使用多道程序技术，让每个用户都感到自己被单独服务。
- 异步：保证异步程序执行的正确性（比如，当一个程序在运行过程中时间片耗尽而进入等待，操作系统需要保存它当前的状态并能够在下次执行时能在正确的状态下）。

### 1.2 操作系统的难点

- 代码量大
- 并发性和琐碎的调度算法的挑战。
- 高效性、低耗性、稳定性需求，具有一定的硬件编程的性质。
- 锁的问题：操作系统底层必须互斥
- 权衡：时间-空间、性能和可预测性、公平和性能等
- 管理**原始**硬件：中断、异常、上下文切换、TLB和页表、汇编语言

### 1.3~1.5 重点

这部分描述了操作系统的发展流程，具体百度即可。

操作系统的结构也分为好几种：

- 分层结构，逐层向上进行封装。
- 微内核结构，应用程序直接和内核功能进行交互。
- 外核结构，将部分物理资源分给多个程序，让每个程序决定如何处理这些资源。（虚拟机就是一种外核结构）

### 额外知识：CPU的运行模式

实模式（Real Mode）和保护模式（Protected Mode）是指中央处理器（CPU）的两种不同的运行模式，主要存在于Intel x86架构的处理器中。

**实模式：**
实模式是最初的8086和8088处理器所运行的模式，也是所有x86处理器在启动时的默认模式。在实模式下，CPU寻址是直接的，它使用20位地址总线，可以直接访问1MB的内存空间。实模式不支持高级的内存管理功能，如分页或内存保护。由于没有内存保护，任何程序都可以访问任何内存地址，这就意味着一个程序可以轻易地干扰另一个程序的运行，导致系统不稳定。

**保护模式：**
保护模式首次出现在80286处理器中，它提供了更高级的内存管理能力。在保护模式下，CPU使用32位（或在更现代的处理器中使用64位）地址总线，可以访问超过1MB的内存。保护模式引入了分段和分页机制，允许操作系统实现进程间的内存隔离，从而提高了系统的稳定性和安全性。此外，保护模式支持多任务处理，允许多个程序同时运行，而不会互相干扰。

**其他模式：**

- **虚拟8086模式：** 这是保护模式下的一个特殊模式，允许保护模式的操作系统在一个受保护的环境中运行实模式程序。这种模式常用于运行旧的DOS程序。

- **长模式（Long Mode）：** 这是在64位x86处理器上运行的模式，它支持64位的内存寻址，可以访问更大的内存空间。长模式同时支持运行32位和64位的应用程序。

- **系统管理模式（System Management Mode, SMM）：** 这是一种特殊的操作模式，用于处理系统级的功能，如电源管理和硬件控制。这个模式通常对操作系统是不可见的。

- **无管理模式（Unreal Mode）：** 这不是官方的CPU模式，而是通过对实模式的一些操作来扩展访问超过1MB内存的非正式模式。

每种模式都有其特定的用途和操作环境，随着计算机硬件的发展，新的模式和功能不断被引入以满足现代计算的需求。

## 第二章 启动、中断、异常和系统调用

### 2.1 计算机系统的启动过程

<font color="red">cpu加电后，执行的第一条指令在**内存**中。</font>

但是作为一个随机读写存储器（RAM），我们早就学过它的特点就是断电后丢失数据，那么哪来的指令让cpu去读呢？cpu为什么知道要去内存读呢？

这里课程里讲的真没听太懂，完整介绍流程在<[BIOS固件-电脑开机的启动流程 - tyong - 博客园 (cnblogs.com)](https://www.cnblogs.com/tyong/articles/10141205.html)>。这里给出个人理解的流程：
$$
BIOS\rightarrow硬件自检\rightarrow启动顺序\rightarrow存储设备
\\
\rightarrow主引导记录\rightarrow分区表\rightarrow活动分区\rightarrow卷引导记录
\\
\rightarrow启动管理器\rightarrow列出可启动的操作系统供用户选择\rightarrow加载操作系统
$$
计算机的整个启动过程分为四个阶段：

#### 第一阶段：BIOS

上个世纪70年代初，"只读内存"（read-only memory，缩写为ROM）发明，开机程序被刷入ROM芯片，计算机通电后，第一件事就是读取它。

这块芯片里的程序叫做"基本输入输出系統"（Basic Input/Output System），简称为BIOS。

##### 硬件自检

BIOS程序首先检查，计算机硬件能否满足运行的基本条件，这叫做"硬件自检"（Power-On Self-Test），缩写为POST。

如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止。如果没有问题，屏幕就会显示出CPU、内存、硬盘等信息。

##### 启动顺序

硬件自检完成后，BIOS把控制权转交给下一阶段的启动程序。

这时，BIOS需要知道，"下一阶段的启动程序"具体存放在哪一个设备。也就是说，BIOS需要有一个外部储存设备的排序，排在前面的设备就是优先转交控制权的设备。这种排序叫做"启动顺序"（Boot Sequence）。

打开BIOS的操作界面，里面有一项就是"设定启动顺序"。

#### 第二阶段：主引导记录


BIOS按照"启动顺序"，把控制权转交给排在第一位的储存设备。

这时，计算机读取该设备的第一个扇区，也就是读取最前面的512个字节。如果这512个字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给"启动顺序"中的下一个设备。

这最前面的512个字节，就叫做"主引导记录"（Master boot record，缩写为MBR）。

> 0x55 和 0xAA 是两个十六进制数，分别对应于十进制的 85 和 170。在计算机中，这两个数通常作为主引导记录（MBR，Master Boot Record）的最后两个字节，用来标识一个有效的引导扇区。
>
> MBR 是硬盘的第一个扇区（通常是 512 字节），它包含了启动计算机操作系统所需的代码和分区表。MBR 的结构通常如下：
>
> - 引导代码（Boot code）：这部分包含了一些基本的代码，用于启动计算机。
> - 分区表（Partition table）：描述硬盘分区的信息。
> - 签名字节（Signature bytes）：0x55 和 0xAA，位于扇区的最后两个字节（第 511 和第 512 字节）。
>
> 使用 0x55 和 0xAA 作为标识符的原因主要是历史和传统。这两个字节作为“魔术数字”（magic numbers），在早期的IBM PC 兼容机中被用来标识一个扇区是否是可引导的。这个约定被广泛接受，并成为了行业标准。选择这两个特定的值可能是因为它们的位模式（0x55 = 01010101b，0xAA = 10101010b）在某种程度上是互补的，这种模式可能有助于错误检测。
>
> 在计算机引导过程中，BIOS（基本输入输出系统）会检查连接的存储设备的第一个扇区的最后两个字节，如果这两个字节是 0x55 和 0xAA，BIOS 就会认为这是一个有效的引导扇区，并从中加载引导代码来启动操作系统。如果这两个字节不是 0x55 和 0xAA，BIOS 将认为该扇区不是一个有效的引导扇区，将不会从该设备启动，并会继续检查其他设备。
>
> <font color="blue">Question:</font>    假如我的启动顺序最前面是光盘，然后是硬盘。但是在启动计算机时，我并没有放入光盘。那计算机究竟是跳过光盘启动还是说有什么办法知道没有光盘，接着从硬盘尝试读主引导记录并启动？
>
> <font color="green">Answer:</font>    当计算机启动时，BIOS（基本输入输出系统）会根据设置的启动顺序来检查每个设备是否包含可启动的媒体。如果您的启动顺序中光盘驱动器排在硬盘之前，BIOS会首先检查光盘驱动器。
>
> 如果光盘驱动器中没有光盘，或者光盘不是一个启动盘，BIOS会检测到光盘驱动器中没有可启动的媒体。这通常是通过尝试读取光盘的启动扇区来完成的。如果读取失败或者启动扇区不包含有效的启动签名（例如，不包含0x55和0xAA这样的魔术数字），BIOS会认为光盘驱动器不包含有效的启动记录。
>
> 在确认光盘驱动器中没有可启动媒体之后，BIOS会继续按照启动顺序检查下一个设备，也就是硬盘。然后，BIOS会尝试从硬盘的主引导记录（MBR）读取启动信息。如果硬盘的MBR是有效的（即包含正确的启动签名），BIOS会从硬盘加载MBR中的引导代码，并开始操作系统的启动过程。
>
> 如果所有配置的启动设备都没有找到可启动的媒体，BIOS通常会显示一条错误消息，例如“No bootable device”或“Insert boot media in selected boot device and press a key”，提示用户没有找到可启动的设备。

##### 主引导记录的结构

"主引导记录"只有512个字节，放不了太多东西。它的主要作用是，告诉计算机到硬盘的哪一个位置去找操作系统。

主引导记录了由三个部分组成：

1. 第1~446字节：446字节，调用操作系统的机器码
2. 第447~510字节：64字节，分区表（Partition table）
3. 第511~512字节：主引导记录签名（0x55和0xAA）

其中，第二部分"分区表"的作用，是将硬盘分成若干个区。

##### 分区表

考虑到每个区可以安装不同的操作系统，"主引导记录"因此必须知道将控制权转交给哪个区。

分区表的长度只有64个字节，里面又分成四项，每项16个字节。所以，一个硬盘最多只能分四个一级分区，又叫做"主分区"。

每个主分区在分区表中的大小均为16字节，分为6个部分：

1.  第1个字节：如果为0x80，就代表该主分区是激活分区，控制权要转交给这个分区。四个主分区里面只能有一个是激活的。
2.  第2~4字节：主分区第一个扇区的物理位置（柱面、磁头、扇区号等）。
3.  第5个字节：主分区类型。
4.  第6~8字节：主分区最后一个扇区的物理位置。
5.  第9~12字节：该主分区的第一个扇区的逻辑地址。
6.  第13~16字节：主分区的扇区总数。

最后的四个字节（"主分区的扇区总数"），决定了这个主分区的长度。也就是说，一个主分区的扇区总数最多不超过2的32次方。

如果每个扇区为512个字节，就意味着单个分区最大不超过2TB。再考虑到扇区的逻辑地址也是32位，所以单个硬盘可利用的空间最大也不超过2TB。如果想使用更大的硬盘，只有2个方法：一是提高每个扇区的字节数，二是增加扇区总数。

> 你提到的内容是关于传统的MBR（Master Boot Record）分区表的结构和限制。MBR是硬盘的一种分区方案，它存在于硬盘的最前面，是硬盘启动的关键所在。MBR中包含了启动代码和分区表信息，而分区表就是用来记录硬盘分区情况的数据结构。
>
> 你的描述非常准确，MBR分区表中确实只有64个字节用于描述分区，分成四个16字节的分区表项，每个表项描述一个主分区。这里的限制是每个硬盘最多只能有四个主分区，或者三个主分区加一个扩展分区。扩展分区可以被进一步分割成多个逻辑分区。
>
> 关于MBR的限制，你提到了两个主要的点：
>
> 1. 单个分区大小的限制：由于分区表中记录扇区总数的字段是一个32位的数，所以最大值是$2^{32-1}$个扇区。如果每个扇区大小为512字节，那么最大数量分区情况下总大小为$512 * 2^{32}$字节，即`2TB`。
>
> 2. 硬盘大小的限制：由于MBR使用32位地址来记录扇区位置，所以它最多只能寻址到2^32个扇区，这同样限制了硬盘的最大大小为2TB（如果扇区大小为512字节）。
>
> 为了解决这些限制，现代计算机系统通常使用GPT（GUID Partition Table）分区方案。GPT不受MBR的这些限制，因为它使用64位的地址来记录扇区位置，这使得理论上的最大分区和硬盘大小可以达到ZB（Zettabytes）级别，远远超过了当前硬盘技术的容量。
>
> 此外，GPT分区表存储在硬盘的前面和后面，提供了冗余保护，即使一部分数据损坏，也能恢复分区信息。GPT还包含了对分区的名称和类型的描述，以及其他的一些先进特性，使得它成为了大容量硬盘的首选分区方案。

在硬盘上，分区格式的信息是存储在硬盘的前面几个扇区中的。对于MBR和GPT分区格式，这些信息的存储方式有所不同：

1. **MBR（Master Boot Record）**：在MBR分区格式中，分区信息存储在硬盘的第一个扇区（通常称为扇区0）。这个扇区包含了启动代码（Bootstrap Code）、分区表和一个有效性标志（通常是0x55AA）。BIOS在启动过程中会读取这个扇区，并根据其中的代码和分区表来加载操作系统。

2. **GPT（GUID Partition Table）**：GPT分区格式采用了不同的方式。它在硬盘的第一个扇区也存储了一个保护性MBR（Protective MBR），这是为了向后兼容那些只能识别MBR的工具。保护性MBR的分区表只包含一个条目，这个条目占据了整个硬盘，但实际上并不用于分区。真正的GPT头部信息是存储在硬盘的第二个扇区，它包含了GPT分区表的位置、大小和循环冗余校验（CRC）校验值等信息。GPT分区表本身则紧随GPT头部信息之后。

对于BIOS和GPT的兼容性问题，事实上传统的BIOS并不支持GPT分区格式。BIOS是在UEFI之前的固件标准，它只能识别MBR分区表。如果你的计算机使用的是传统的BIOS固件，那么它无法直接从GPT分区的硬盘启动操作系统。

相反，UEFI（Unified Extensible Firmware Interface）是一种现代的固件接口标准，它支持GPT分区格式。UEFI在启动时会读取GPT的头部信息，确定分区表的位置，然后根据分区表加载EFI系统分区（ESP），ESP包含了用于启动操作系统的EFI应用程序（如引导加载程序）。

因此，如果你的硬盘使用GPT分区，并且你希望从该硬盘启动操作系统，你需要确保你的计算机使用的是UEFI固件，而不是传统的BIOS。现代计算机通常都支持UEFI，并且默认使用UEFI模式。在UEFI模式下，计算机可以识别GPT分区格式，并从中启动操作系统。

> <font color="blue">question:</font>    "保护性MBR的分区表只包含一个条目，这个条目占据了整个硬盘"，这是什么意思？
>
> <font color="green">answer:</font>    保护性MBR（Protective MBR）是GPT（GUID Partition Table）分区方案的一部分，它位于硬盘的第一个扇区，也就是传统MBR的位置。保护性MBR的目的是为了保护GPT分区的硬盘免受不支持GPT的旧式系统和工具的干扰。
>
> 在保护性MBR中，分区表通常只包含一个条目，这个条目的类型被设置为0xEE，这是一个特殊的分区类型，用来指示整个硬盘或者一个很大的区域已经被GPT占用。这个条目并不指向实际的文件系统或数据分区，而是作为一个标记存在，告诉任何可能读取MBR的软件：“这个硬盘使用的是GPT分区方案，你不应该试图用MBR的方式来管理它。”
>
> 这个条目通常会从硬盘的第一个可用扇区开始，直到硬盘的最后一个扇区，覆盖整个硬盘的范围。这样做的目的是为了防止不支持GPT的系统和工具错误地认为硬盘未分区，并试图在硬盘上创建新的MBR分区，这可能会导致数据丢失。
>
> 因此，保护性MBR是一种兼容性措施，确保了GPT分区的硬盘在旧系统中不会被误操作，同时允许支持GPT的系统正确识别和使用硬盘。真正的GPT分区信息存储在硬盘的其他位置，通常是从第二个扇区开始的GPT头部，紧接着是分区表本身。
>
> 
>
> <font color="blue">question:</font>    也就是说，假设我在旧式的BIOS上读取了一块硬盘，而这块硬盘采取的是GPT格式的分区方式。BIOS会尝试读取扇区0，然后读取到0xEE，它会认为这不是一个激活分区。因此它会跳过这个硬盘尝试去别的硬件上寻找系统。
>
> <font color="green">answer:</font>    是的，您的理解基本正确。在旧式的BIOS系统中，当BIOS尝试读取采用GPT格式分区的硬盘时，它会首先检查扇区0，也就是MBR所在的位置。在这种情况下，它会发现保护性MBR，其中包含一个类型为0xEE的分区条目，这个条目覆盖整个硬盘。
>
> BIOS会识别到这个特殊的分区类型，但由于BIOS不支持GPT，它不会理解这个分区条目的真实含义。BIOS可能会认为这个硬盘不包含任何有效的可启动分区，因为0xEE类型的分区不是一个可启动的分区类型。因此，BIOS不会从这个硬盘启动操作系统，而是会继续搜索其他可能包含有效MBR和可启动分区的硬盘或启动设备。
>
> 这就是保护性MBR的作用：它防止了BIOS基于错误的假设（即硬盘使用MBR分区表）对硬盘进行操作，同时也向BIOS表明这个硬盘使用了一种它不理解的分区方案。这样可以减少数据损坏的风险，并确保只有支持GPT的系统（如UEFI固件）才能管理和启动这个硬盘上的操作系统。

#### 第三阶段： 硬盘启动

到了这个时期，计算机的控制权就要转交给硬盘的某个分区了，这里又分成三种情况。

##### **情况1：卷引导记录**

上一节提到，四个主分区里面，只有一个是激活的。计算机会读取激活分区的第一个扇区，叫做"卷引导记录"（Volume boot record，缩写为VBR）。

"卷引导记录"的主要作用是，告诉计算机，操作系统在这个分区里的位置。然后，计算机就会加载操作系统了。

##### **情况2：扩展分区和逻辑分区**

随着硬盘越来越大，四个主分区已经不够了，需要更多的分区。但是，分区表只有四项，因此规定有且仅有一个区可以被定义成"扩展分区"（Extended partition）。

所谓"扩展分区"，就是指这个区里面又分成多个区。这种分区里面的分区，就叫做"逻辑分区"（logical partition）。

计算机先读取扩展分区的第一个扇区，叫做"扩展引导记录"（Extended boot record，缩写为EBR）。它里面也包含一张64字节的分区表，但是最多只有两项（也就是两个逻辑分区）。

计算机接着读取第二个逻辑分区的第一个扇区，再从里面的分区表中找到第三个逻辑分区的位置，以此类推，直到某个逻辑分区的分区表只包含它自身为止（即只有一个分区项）。因此，扩展分区可以包含无数个逻辑分区。

但是，似乎很少通过这种方式启动操作系统。如果操作系统确实安装在扩展分区，一般采用下一种方式启动。

##### **情况3：启动管理器**

在这种情况下，计算机读取"主引导记录"前面446字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的"启动管理器"（boot loader），由用户选择启动哪一个操作系统。

#### 第四阶段：操作系统

控制权转交给操作系统后，操作系统的内核首先被载入内存。

以Linux系统为例，先载入/boot目录下面的kernel。内核加载成功后，第一个运行的程序是/sbin/init。它根据配置文件（Debian系统是/etc/initab）产生init进程。这是Linux启动后的第一个进程，pid进程编号为1，其他进程都是它的后代。

然后，init线程加载系统的各个模块，比如窗口程序和网络程序，直至执行/bin/login程序，跳出登录界面，等待用户输入用户名和密码。

**至此，全部启动过程完成。**

<font color="red">总结上述内容，一个计算机的启动过程大致描述为：首先，在cpu通电后，它会初始化一些自身包含的寄存器以及主板上的一些ROM，这些内容共同构成了BIOS（基本输入输出系统）。然后，BIOS会进行硬件自检，检查必要的硬件设备（内存、显卡）是否正常工作，计算机是否满足基本的运行条件。<br><br>然后，BIOS中保存了一个"启动顺序"，它按照启动顺序从外部硬件设备中尝试读入操作系统内核。例如，启动顺序第一位的是硬盘，BIOS会尝试读取硬盘的第一个扇区（扇区0），检查其是否以`0x55`、`0xAA`结尾（判断它是不是主引导记录。注意，这是MBR格式分区的硬盘的读取方式。新的GPT分区格式读取又有区别）。<br><br>在它找到主引导记录后，BIOS又需要读主引导记录中保存的分区表的信息，确定哪个主分区是以`0x80`为第一个字节，这个分区称为激活分区。计算机的控制权转交给这个分区。<br><br>随后，又要根据不同的情况（卷引导记录、扩展分区和逻辑分区、启动管理器等）选择不同的启动方式。<br><br>最后，成功找到了操作系统在外部存储设备中的位置。首先加载操作系统内核，随后启动进程以及各个模块。整个操作系统至此就成功启动了。</font>

> 上述描述对操作系统启动流程的概述是正确的，但可以进一步细化和补充一些细节：
>
> 1. **CPU复位和自检**：在通电后，CPU会执行一个复位操作，这通常涉及到读取内存地址0xFFFFFFF0处的内容，这是因为在x86架构中，这个地址映射到BIOS的起始位置。CPU从这个位置开始执行指令，进入BIOS。
>
> 2. **BIOS初始化**：BIOS会进行POST（Power-On Self Test，加电自检），检查系统硬件配置，如CPU、内存、键盘、驱动器等，并可能显示一些基本的系统信息。
>
> 3. **启动设备检测**：BIOS会根据预设的启动顺序检查各个启动设备，如硬盘、光驱、USB设备等。
>
> 4. **MBR或GPT读取**：对于MBR（Master Boot Record）格式的硬盘，BIOS会读取硬盘的第一个扇区，检查`0x55`和`0xAA`这两个字节来确认MBR的有效性。对于GPT（GUID Partition Table）格式的硬盘，启动流程稍有不同，BIOS或UEFI（Unified Extensible Firmware Interface，统一的可扩展固件接口）会读取EFI系统分区来加载操作系统。
>
> 5. **引导加载器**：在MBR中，BIOS会加载并执行主引导记录中的代码，这通常会引导到一个引导加载器，如GRUB或Windows Boot Manager。对于GPT分区表，UEFI会加载EFI系统分区中的EFI应用程序（如引导加载器）。
>
> 6. **操作系统加载**：引导加载器会加载操作系统内核到内存中，并将控制权交给操作系统。操作系统接管后，会继续加载系统驱动和服务，最终进入用户界面。
>
> 补充说明：
>
> - 在现代计算机中，BIOS已经逐渐被UEFI所取代，UEFI提供了更加丰富的界面和功能，支持更大的硬盘以及更快的启动速度。
> - 在UEFI模式下，通常使用GPT分区表，而在传统的BIOS模式下，使用MBR分区表。
> - 在某些系统中，还可能有一个快速启动的功能，这通常是通过将系统状态保存到一个文件中，在下一次启动时直接读取该文件来实现快速启动的。
>
> 这些补充信息提供了更全面的视角来理解计算机启动的过程。

#### 额外知识：cpu的代码段寄存器和当前指令指针

根据俗成的约定，在cpu完成初始化加载后。它的代码段寄存器（CS）和当前指令指针（IP，32位称EIP，64位称RIP）指向预设的物理地址。

根据传统的BIOS启动流程，当cpu复位时，CS寄存器为`0xffff`，IP寄存器为`0x00`。这个组合会将cpu的执行指向物理内存地址`0xFFFF0`（CS寄存器的值乘以16加上IP寄存器的值，即`0xFFFF0 = 0XFFFF * 16 + 0X0000`）.

这个地址位于系统的ROM BIOS中，紧靠1MB地址空间的顶端（在一个1MB的地址空间中，最高的16字节）。这里通常存放的是BIOS启动代码的跳转指令，它会将CPU的控制权转移到BIOS的主体部分，开始执行系统的自检和初始化过程。

这样设计的原因是为了确保计算机在启动时能够找到一个固定的位置开始执行代码，因为在计算机启动时内存中还没有加载操作系统或其他程序。通过将控制权交给BIOS，计算机可以进行硬件初始化和引导过程，最终加载操作系统。

在UEFI（统一可扩展固件接口）系统中，启动过程有所不同，但基本原理相似：UEFI固件存储在主板上的一个芯片中，计算机启动时会执行该固件中的代码来初始化硬件并引导操作系统。

> 我还有一些疑问，为什么"这个组合会将cpu的执行指向物理内存地址`0xFFFF0`（CS寄存器的值乘以16加上IP寄存器的值，即`0xFFFF0 = 0XFFFF * 16 + 0X0000`）"为什么要将CS寄存器的值乘以16再相加？
> 还有一个问题是，它指向了1MB地址空间的顶端，这个1MB地址空间是做什么用的？指令的执行是自顶向下的吗？
>
> 
>
> 您的问题涉及到x86架构的实模式内存寻址方式，以及BIOS在系统启动时的内存布局。我来逐一解答：
>
> ### 为什么要将CS寄存器的值乘以16再相加？
>
> 在x86架构的实模式下，物理地址是通过段地址和偏移地址组合而成的。段地址（存储在段寄存器中）需要乘以16（或左移4位）来得到基础地址，然后加上偏移地址（存储在指令指针寄存器中）来得到最终的物理地址。这种寻址方式称为段:偏移寻址。
>
> 这样设计的初衷是为了在16位处理器上扩展内存寻址能力。在16位处理器中，一个寄存器只能存储16位的值，最大只能直接寻址64KB的内存。通过将16位的段地址乘以16，再加上16位的偏移地址，可以寻址高达1MB的内存空间（2^20字节）。
>
> 所以，当CS寄存器为0xFFFF时，乘以16（或左移4位）得到的基础地址是0xFFFF0。加上IP寄存器的值0x0000，得到的物理地址仍然是0xFFFF0。
>
> ### 这个1MB地址空间是做什么用的？
>
> 在实模式下，CPU可以寻址的最大内存空间是1MB。这个1MB的内存空间不仅包括RAM，还包括了其他类型的内存，如BIOS ROM、视频内存、以及其他I/O设备的内存映射区域。这个空间的布局大致如下：
>
> - 0x00000 - 0x9FFFF：常规RAM（640KB）
> - 0xA0000 - 0xBFFFF：视频内存区域
> - 0xC0000 - 0xFFFFF：系统BIOS和其他固件（包括视频BIOS、网络卡BIOS等）
>
> 在这1MB的空间中，顶端的区域（通常是0xF0000 - 0xFFFFF）被保留给系统BIOS使用。这是因为在早期的PC设计中，BIOS需要在一个固定的位置，以便CPU在启动时可以找到并执行它的代码。
>
> ### 指令的执行是自顶向下的吗？
>
> 指令的执行顺序并不是由物理地址的高低决定的，而是由程序的控制流决定的。CPU从BIOS固件的预设入口点（0xFFFF0）开始执行指令，然后按照指令本身的逻辑顺序执行。这些指令可能会跳转到BIOS中的其他部分，或者在执行完必要的初始化后，跳转到引导扇区的代码，最终引导操作系统的加载。
>
> 
>
> 
>
> 那么也就是说，代码段寄存器和当前指令指针初始化时得到的并不是物理地址。而是段地址加偏移地址，因此需要计算将其还原为物理地址。第二个问题我的理解是，现代工业厂家设计的内存条大多都符合了这个约定，预留了1MB的地址空间（实际上这个空间中并不一定有数据，只是把地址预留出来）。这些地址指向了一些外部的硬件设备，cpu直接执行它们的代码并跳转或将控制权移交。第三个问题我的理解是，虽然0xffff0是第一条指令所在的地址。但是这条指令的作用可能是将cpu控制权移交给bios，接下来去什么地址读取执行命令由bios决定。
> 我的理解对吗？
>
> 
>
>
> 您的理解基本上是正确的，但让我稍微澄清一下：
>
> ### 关于物理地址和段:偏移地址
>
> 在x86实模式下，物理地址确实是由段地址和偏移地址组合而成的。CPU在启动时，代码段寄存器（CS）和指令指针（IP）提供了一个初始的段:偏移组合，这需要转换成物理地址才能访问内存。这个转换是通过将段地址乘以16（或左移4位），然后加上偏移地址来完成的。因此，物理地址是由这个计算得到的，而不是直接由CS和IP的值决定的。
>
> ### 关于1MB地址空间的预留
>
> 在早期的PC设计中，1MB地址空间的布局是由工业标准决定的，确实预留了一部分空间给系统BIOS和其他固件。这个空间中的一些区域可能没有物理RAM对应，但它们被映射到了其他类型的存储器或设备。例如，BIOS固件存储在主板上的非易失性存储器中，而不是在RAM内存条中。因此，当CPU访问这些特定的地址时，它实际上是在读取或写入这些设备的存储器，而不是RAM。
>
> ### 关于BIOS的控制权
>
> 当CPU在启动时执行位于物理地址0xFFFF0的指令时，这通常是一个跳转指令，它会将CPU的控制权转移到BIOS固件中的其他位置，开始执行BIOS的初始化代码。BIOS代码负责进行硬件检测、初始化，并最终找到启动设备（如硬盘）上的引导扇区，从而加载引导代码并最终引导操作系统。因此，BIOS决定了在完成自身初始化后，CPU应该去哪个地址继续执行指令。
>
> 您对这些概念的理解是正确的。这些细节对于理解计算机如何从零开始启动到加载操作系统是非常重要的。

### 2.2 中断、异常和系统调用

#### 2.2.1 背景

当操作系统内核被加载到内存中，cpu控制权移交给操作系统内核后，用户和硬件设备之间的交互就由操作系统全权负责了。

这也意味着**操作系统内核是受到硬件设备信任的第三方**，只有内核可以执行特权指令（比如Win中的Admin，Linux中的root、sudo）。

CPU执行操作系统代码时，CPU处于内核态（又称管态），2.2介绍的三种机制都是在内核态下运行的。

但是既然我们需要和硬件设备打交道（比如我们要从磁盘读写文件），那么不可避免的就需要让应用程序**（用户态）**和内核**（内核态）**打交道。这也就意味着应用程序需要通过内核来与硬件交互，内核在保证安全的同时应该向应用程序提供这些系统服务。

与此同时，提供系统服务可能带来错误的行为。比如，应用程序访问了一个不存在的文件，或者访问了一个以其权限来说不够的文件。操作系统也需要对这些事情做出反应。

此外，硬件设备可能也需要一些服务。比如键盘输入，这也需要通过内核来进行响应。

上述内容就是我们这部分要介绍的内容，即：

- 中断：处理外设回调类的事件，比如键盘按键等。
- 异常：在应用程序出现问题时处理意外情况，保证内核安全。
- 系统调用：应用程序正常使用系统服务，比如发出读文件指令，实际上会调用磁盘I/O的系统调用。

#### 2.2.2 定义

上述内容正规的定义如下：

- **系统调用**（system call）：应用程序**主动**向操作系统发出的服务请求
- **异常**（exception）：非法指令或者其他原因导致当前**指令执行失败**
- **中断**（hardware interrupt）：来自硬件**外设**的处理请求

![img](.\images\中断、异常和系统调用关系图.png)

这里详细解释一下这三个定义具体的流程：

- 中断：首先，外部设备在需要处理时（例如键盘被按下按键）向操作系统内核发出一个中断请求，内核会将该中断请求加入到中断向量表等待处理。随后，内核处理该中断时，发现它是一个来自某外部源的中断请求。因此交由中断服务例程，中断服务例程要求相应的设备驱动程序与外部设备进行交互，进而完成外部设备要做的事。在处理中断后，控制权返回给操作系统，操作系统继续执行之前的任务。

> 您对中断的基本理解是正确的。中断是计算机硬件和操作系统之间的一种重要通信机制。当硬件设备需要CPU的注意时，它会发送一个中断信号。这里是一个简化的中断处理流程：
>
> 1. **中断请求（IRQ）**：当外部设备（如键盘、鼠标或网络适配器）需要处理时，它会向CPU发送一个中断请求。
>
> 2. **中断向量表**：CPU接收到中断请求后，会根据中断向量表（一个包含中断服务例程地址的表）确定如何处理该中断。
>
> 3. **中断服务例程（ISR）**：CPU将控制权交给对应的中断服务例程，这是一个预先定义好的函数，用于处理特定的中断类型。
>
> 4. **设备驱动程序**：中断服务例程通常会与相应的设备驱动程序交互，设备驱动程序负责管理与硬件设备的直接通信。
>
> 5. **处理和响应**：设备驱动程序处理来自硬件的数据或请求，并采取相应的行动，比如读取键盘输入或接收网络数据包。
>
> 6. **中断返回**：一旦中断被处理，控制权返回给操作系统，操作系统继续执行之前的任务。
>
> 这个过程确保了CPU可以高效地响应多个设备的请求，而不需要轮询每个设备以查看是否有需要处理的事件。这种机制使得操作系统能够同时处理多任务，提高了计算机的效率和响应速度。
>
> 
>
> 我有一点不明白的是，假如我的应用程序中有一个输入框。此时我按下键盘输入，按照中断的理解，我的键盘输入被读到了设备驱动程序中，设备驱动程序是怎么把我输入的内容发送给输入框的？还是说由于输入焦点的存在，所有键盘输入都会被发送到这个输入焦点的位置。
> 
>
>
> 您的理解是正确的，输入焦点在这里起到了关键作用。当您在应用程序中的输入框中键入时，操作系统和应用程序的事件处理机制会确保您的按键输入被正确地传递到具有输入焦点的控件。以下是详细的步骤：
>
> 1. **按键中断**：当您按下键盘上的键时，键盘硬件生成一个中断信号发送给CPU。
>
> 2. **中断处理**：操作系统的内核接收到中断信号，并将控制权交给键盘的中断服务例程。
>
> 3. **设备驱动程序**：中断服务例程通知键盘设备驱动程序处理按键事件。
>
> 4. **操作系统事件队列**：设备驱动程序将按键事件转换为操作系统理解的事件，并将其放入操作系统的事件队列中。
>
> 5. **消息传递**：操作系统的窗口管理器或事件处理系统会从事件队列中取出事件，并根据当前的输入焦点将事件传递给相应的应用程序。
>
> 6. **应用程序事件处理**：应用程序接收到事件后，会在其事件循环中处理该事件。如果输入焦点在输入框上，应用程序会将按键事件转换为字符输入，并显示在输入框中。
>
> 7. **输入框更新**：输入框接收到字符后，会更新其内容，并在界面上显示新输入的字符。
>
> 这个过程涉及到操作系统的多个层面，包括硬件中断处理、设备驱动程序、操作系统的事件处理机制、以及应用程序的事件循环。输入焦点确保了只有当前用户正在交互的控件会接收到键盘输入，这样用户就可以预期输入会出现在他们期望的位置。

- 异常：异常通常是来自应用程序的，当应用程序代码做出了某件错误的事（例如，做出了除零操作、访问了不存在的文件等）。由于我们编写的应用程序代码**在系统底层实际上是一条条的指令**，这就意味着某条指令执行失败了。此时中断向量表中也会接收到该异常请求，中断向量表识别到它是一个异常后将其发送给异常服务例程。异常服务例程可能会解决这个问题，也可能终止应用程序的执行，在最坏的情况下会导致内核出错。

> 您对异常的理解基本上是正确的，但有一些细节可以进一步澄清。异常和中断都是中央处理器（CPU）的响应机制，但它们的来源和目的不同。中断通常是由外部事件（如硬件设备的信号）触发的，而异常通常是由CPU执行指令过程中遇到的问题触发的。
>
> 以下是异常处理的一般流程：
>
> 1. **异常发生**：当CPU在执行应用程序代码时遇到问题（如除零操作、无效内存访问、指令执行错误等），它会产生一个异常。
>
> 2. **异常分类**：异常可以分为同步异常和异步异常。同步异常是由当前执行的指令直接引起的，例如除零或访问违规。异步异常可能由于外部事件引起，与当前执行的指令不直接相关，例如硬件故障。
>
> 3. **中断向量表**：CPU使用一个内部的中断向量表（或异常向量表）来决定如何处理异常。每种类型的异常都有一个对应的入口，称为异常处理程序或异常服务例程。
>
> 4. **异常处理程序**：CPU将控制权转交给对应的异常处理程序。这个处理程序是操作系统预先定义好的，用于处理特定类型的异常。
>
> 5. **处理或终止**：异常处理程序会尝试修复问题，例如通过提供默认值或清理资源。如果问题无法修复，它可能会决定终止引起异常的应用程序。
>
> 6. **用户通知**：在某些情况下，操作系统可能会向用户报告异常，例如通过错误消息或日志条目。
>
> 7. **恢复或终止**：如果异常被处理并且系统能够从异常中恢复，程序可能会继续执行。如果异常无法处理，应用程序可能会被终止，严重的异常（如内核级异常）可能会导致系统崩溃。
>
> 异常处理是操作系统稳定性和安全性的关键组成部分，它确保了单个应用程序的错误不会影响整个系统的稳定性。

- 系统调用：应用程序主动向内核发出的服务请求，实际上应用程序通过函数库中的函数调用来间接的进行系统调用。比如应用程序调用`open()`函数进行一个读写文件的操作，底层实际上进行了磁盘IO的系统调用。应用程序发出的系统调用同样会发送到对应的系统调用表，系统调用表会查找对应的系统调用操作，完成相应的操作并将结果返回给系统调用处。

> 您对系统调用的理解是正确的。系统调用是应用程序与操作系统内核之间的接口，它允许应用程序请求操作系统提供的服务，例如文件操作、进程控制、网络通信等。这里是系统调用的一般过程：
>
> 1. **函数库调用**：应用程序通过调用标准库中的函数（如C语言中的`open()`）来发起一个系统调用。这些库函数为应用程序提供了一个简化和统一的接口来执行复杂的系统调用。
>
> 2. **触发系统调用**：库函数内部会设置必要的参数，并使用特定的机制（如软件中断或特殊的CPU指令）来通知操作系统需要服务。
>
> 3. **上下文切换**：当系统调用被触发时，CPU从用户模式切换到内核模式，因为系统调用需要操作系统内核的权限来访问硬件和管理资源。
>
> 4. **系统调用表**：操作系统内核使用一个系统调用表来确定如何处理来自应用程序的请求。每个系统调用在这个表中都有一个唯一的编号和对应的内核函数。
>
> 5. **执行系统调用**：内核查找系统调用表，找到对应的内核服务例程，并执行相应的操作。
>
> 6. **返回结果**：操作完成后，结果会被返回给应用程序。如果是读写文件操作，例如`open()`，内核会处理文件的打开，并返回一个文件描述符给应用程序。
>
> 7. **恢复用户模式**：系统调用完成后，CPU从内核模式切换回用户模式，控制权返回给应用程序。
>
> 系统调用是一种受控的机制，它确保了用户程序不能直接执行可能会破坏系统稳定性或安全性的操作。通过系统调用，操作系统能够提供必要的隔离和控制，同时还能提供对硬件资源的抽象，使得应用程序编写更为简单和可移植。

#### 2.2.3 三种机制对比

**从源头上来说：**

- 中断：来自外设
- 异常：来自应用程序意想不到的行为
- 系统调用：来自应用程序主动请求

**从响应方式来说：**

- **中断**：**中断是异步的**，当外部设备发出一个中断请求时。操作系统可能正在处理其他任务（比如正在执行某应用程序），应用程序是感受不到中断的存在的。操作系统可能会在应用程序暂停（比如时间片耗尽）时再来处理中断请求，完成中断请求相应操作后再继续执行应用程序或其他操作。

  <font color="red">**上述对中断的理解不够准确。**</font>

  > 您的说法基本准确，但需要一点澄清。中断确实是异步的，它们可以在任何时候发生，通常是由外部设备触发的。但是，中断处理通常具有很高的优先级，因为它们往往对应着需要立即处理的硬件事件。
  >
  > 当中断发生时，以下是处理流程的概述：
  >
  > 1. **中断请求**：外部设备发出中断请求到CPU。
  >
  > 2. **当前指令完成**：CPU通常会完成当前执行的指令之后，再响应中断请求。
  >
  > 3. **上下文保存**：在响应中断之前，CPU会保存当前任务的状态，这通常包括寄存器和程序计数器的值，以便中断处理完成后能够恢复到当前任务。
  >
  > 4. **中断处理**：CPU根据中断向量表跳转到相应的中断服务例程（ISR）进行处理。
  >
  > 5. **上下文恢复**：中断处理完成后，CPU会恢复之前保存的任务状态，继续执行被中断的任务。
  >
  > 在多任务操作系统中，中断处理通常是优先于当前运行的应用程序的。这意味着，如果一个中断发生了，操作系统会立即暂停当前的应用程序（即使它的时间片尚未耗尽），保存其状态，处理中断，然后再恢复应用程序的执行。这个过程对于应用程序来说是透明的，应用程序通常感知不到中断的发生和处理。
  >
  > 然而，操作系统设计者可能会在中断处理策略中引入一些灵活性。例如，在某些情况下，操作系统可能会延迟处理非关键的中断，直到当前任务达到一个安全的中断点。这种设计可以减少上下文切换的开销，但是在大多数情况下，中断处理是尽可能快地执行以确保系统的响应性。

- **异常**：**异常是同步的**，当应用程序代码出现问题，导致执行了一个错误的指令时。操作系统会接收到异常请求，然后应用程序就在那等待操作系统的响应了。如果操作系统能够处理该异常，且应用程序可以从错误的状态恢复过来，那么就能够继续执行应用程序。否则，操作系统将回收应用程序占用的资源并关闭应用程序。

  > 您对异常的理解基本上是准确的。异常确实是同步发生的，它们是由CPU执行指令时检测到的问题触发的。这些问题可能包括除以零、访问无效的内存地址、执行非法指令等。以下是异常处理的一般流程：
  >
  > 1. **异常发生**：当CPU在执行应用程序时遇到一个问题，它会产生一个异常。
  >
  > 2. **异常分类**：异常通常是同步的，它们可以是由于程序错误（如除零、越界访问、非法指令等）引起的，也可以是由于程序执行的操作需要进一步的操作系统介入才能完成（如页面错误）。
  >
  > 3. **上下文保存**：操作系统接收到异常后，会保存当前任务的状态，这样就可以在处理完异常后恢复任务的执行。
  >
  > 4. **异常处理程序**：CPU使用异常向量表来确定如何处理异常，并跳转到对应的异常处理程序。
  >
  > 5. **决定命运**：异常处理程序会尝试修复问题，如果可以修复并且应用程序可以从错误状态恢复，则处理程序会结束异常处理，恢复应用程序的执行。如果问题无法修复，操作系统可能会决定终止应用程序。
  >
  > 6. **资源回收**：如果应用程序被终止，操作系统会回收它占用的资源，如内存、文件句柄等。
  >
  > 7. **用户通知**：在某些情况下，操作系统可能会向用户报告异常，例如通过错误消息。
  >
  > 8. **恢复或终止**：如果异常被处理并且系统能够从异常中恢复，程序可能会继续执行。如果异常无法处理，应用程序可能会被终止。
  >
  > 异常处理是操作系统的一个重要功能，它确保了单个应用程序的错误不会影响整个系统的稳定性，并且提供了一种机制来安全地处理程序运行时的错误。

- **系统调用**：系统调用可能是同步的，也可能是异步的。例如，应用程序对文件进行了读写操作，这将导致磁盘IO的系统调用产生。然而，由于应用程序可能需要在读写完成后才能进行下一步操作（比如上传文件到网络），因此应用程序就不得不等待系统调用完成，内容被完全写入到文件后才能继续下一步操作。
  相应的，如果应用程序读写文件后就不再使用该文件了。那么系统调用与应用程序之间可能是异步的，应用程序可能继续执行去处理别的任务，发送下一个系统调用给操作系统，即便当前的磁盘IO系统调用还未完成。

  > 您对系统调用的理解是基本准确的，但需要一些澄清。系统调用本身是同步的，但它们可以被用于启动异步操作。
  >
  > 当一个应用程序执行系统调用，如文件读写操作时，这通常是一个同步操作。这意味着系统调用会导致应用程序等待操作系统完成请求的服务。在文件IO的例子中，应用程序会发出读或写的系统调用，并且在该操作完成之前，应用程序的执行通常会被阻塞。这确保了在文件内容被完全读取或写入之后，应用程序才继续执行。
  >
  > 然而，操作系统也提供了异步IO的机制。在异步IO模型中，应用程序可以发起一个读写操作，并且无需等待该操作完成就可以继续执行其他任务。在这种情况下，应用程序会在之后的某个时间点收到一个通知，告知它IO操作已经完成。这样，应用程序就可以在等待磁盘IO的同时执行其他工作，从而提高效率。
  >
  > 总结来说：
  >
  > - **同步系统调用**：应用程序在系统调用完成之前会被阻塞。应用程序必须等待操作系统完成服务才能继续执行。
  >
  > - **异步系统调用**：应用程序发起系统调用后可以继续执行其他任务，不需要等待系统调用完成。操作系统会在后台处理系统调用，并在完成后通知应用程序。
  >
  > 在现代操作系统中，两种模型都是可用的，具体使用哪一种取决于应用程序的需求和设计。

**从处理机制上来说：**

- **中断：**中断对应用程序来说是透明的，因此中断处理时，应用程序是**持续运行**的。
- **异常：**异常是应用程序发出意想不到的指令（或者导致错误的指令）时发生的，因此应用程序只能暂停等待异常处理完成，导致资源回收或重新执行发生错误的指令。
- **系统调用：**系统调用本身是同步或者异步的，因此从处理机制上来说应用程序可能是被阻塞等待的，也可能是持续运行别的任务的。

#### 2.2.4 中断（这里的中断是中断、异常、系统调用统称）

要想识别中断请求，cpu必须进行一些初始化。这就是CPU的硬件处理：**在CPU初始化时设置中断使能标志。**

- 依据内部或外部事件设置中断标志（比如键盘就对应着一个阵列通断对应的高低电平）
- 依据中断向量调用相应中断服务例程（相当于是一个回调机制）

**中断发生时，软件也需要进行一些处理：**

- **现场保存**：中断发生时，我们需要知道应用程序的上下文，保存应用程序当前的状态。
- **中断服务处理**：保存完状态后，我们从中断向量表中得到这个中断的类型（中断、异常还是系统调用），然后交给对应的服务例程进行处理。
- **清除中断标记**：交给对应服务例程进行处理后，这个中断标记就不再被需要了（它已经或者正在被处理了），服务例程也负责清除中断标记。
- **现场恢复**：恢复应用程序的上下文。

<font color="red">还有一个问题是，当操作系统正在处理某个请求时，又出现了一个请求怎么办？</font>

比如我通过键盘输入，向操作系统发出了键盘源中断请求。此时我同时移动鼠标，相当于让鼠标源发送了一个中断请求。

那么我们需要知道的就是：

- **硬件中断服务例程可以被打断：**也就是说，当我们键盘输入同时移动鼠标时，可能发生的情况就是，键盘源的中断请求发送给了中断服务例程，中断服务例程调用了键盘设备驱动程序，键盘设备驱动程序从键盘中读取输入。此时鼠标源中断请求发送给了操作系统，操作系统**可能**会将键盘设备驱动程序暂停，执行该中断并交给中断服务例程调用鼠标设备驱动程序，等待鼠标设备驱动程序完成任务后继续之前的键盘设备驱动程序的任务。但是由于这个过程实在是太快了，所以我们人是感觉不到的。

  > 这段描述基本上是准确的，但需要一些澄清和补充。
  >
  > 在现代操作系统中，硬件中断服务例程（ISR）确实可以被其他更高优先级的中断打断，这个过程被称为中断嵌套。当一个中断发生时，CPU会暂停当前正在执行的任务，保存其状态，并跳转到相应的中断服务例程来处理中断。如果在处理一个中断的时候，另一个更高优先级的中断到来，CPU会再次暂停当前的中断处理，保存状态，并处理新的中断。
  >
  > 在你的例子中，当键盘和鼠标几乎同时产生中断请求时，操作系统的中断控制器会根据优先级来决定处理顺序。如果鼠标中断的优先级高于键盘中断，那么操作系统确实会先处理鼠标中断。一旦鼠标中断处理完毕，操作系统会恢复处理键盘中断。
  >
  > 这个过程通常是非常快速的，以至于用户几乎感觉不到延迟。但是，这也取决于中断服务例程的效率和复杂性，以及系统的整体负载。如果中断服务例程非常简短并且高效，那么即使在高负载下，用户也不太可能感觉到明显的延迟。
  >
  > 需要注意的是，现代操作系统通常使用了多种机制来优化中断处理，例如中断共享、中断线程化、以及对于多核处理器的中断亲和性分配等，这些都有助于提高系统在处理多个硬件中断时的效率和响应性。

- **硬件中断服务例程中可能临时禁止中断请求**：这和中断的优先级有一定的关系，当我们正在处理一个较高优先级的中断（例如，电源设备发出了一个中断请求），而此时我们通过键盘输入（键盘设备发出中断请求）。那么操作系统可能认为电源设备是一个更高优先级的，我们必须马上处理电源设备的问题。那么在处理电源中断时，就会临时禁止中断请求以免处理过程被打断。

  > 这个描述是基本准确的。在中断服务例程（ISR）执行期间，确实可能会临时禁用其他中断，这通常是为了防止当前正在处理的中断被其他中断打断，尤其是在处理一些需要快速响应的高优先级中断时。
  >
  > 这种机制通常被称为“禁止中断”（Disable Interrupts）或“屏蔽中断”（Mask Interrupts）。在处理关键的中断服务例程时，操作系统或中断控制器可能会暂时屏蔽掉其他低优先级的中断，直到关键的中断处理完成。这样做的目的是确保中断处理的原子性和一致性，避免数据竞争和状态不一致的问题。
  >
  > 例如，如果电源设备发出了一个中断请求，这通常意味着需要立即采取行动（比如电池电量低或电源故障），因此系统可能会优先处理这个中断，并在处理期间禁止其他中断，确保电源相关的处理不会被其他活动打断。
  >
  > 一旦高优先级的中断处理完成，系统会重新启用中断，允许其他中断请求被处理。这个过程是由操作系统和硬件紧密协作完成的，以确保系统的稳定性和响应性。

- **中断请求会保持到CPU做出响应：**正如上面所说的，临时禁止的中断请求并不意味着中断向量表不接收，只是暂时不处理。中断请求会保持到CPU对其做出响应。
- **异常服务例程可被打断**：
  - 异常服务例程执行时可能被硬件中断： 例如，当操作系统处理应用程序异常时，异常处理导致磁盘IO，此时会发生磁盘源的硬件中断。异常服务例程会被打断，保存状态后先执行磁盘硬件中断。
  - 异常服务例程可嵌套： 例如，当操作系统处理应用程序异常时，在处理异常的过程中再度发生了异常（假设异常处理需要访问某个存储单元，而这个存储单元又有问题）。那么就会发生异常的嵌套。

#### 2.2.5 系统调用

**背景**：应用程序一般无法直接访问硬件，也无法执行特权指令。所以，需要通过操作系统来间接完成相关的工作。而基于安全和可靠性的需求，应用程序运行在用户态，操作系统内核运行在内核态，导致应用程序无法通过函数调用来访问操作系统提供的各种服务，于是通过系统调用的方式就成了应用程序向OS发出请求并获得服务反馈的唯一通道和接口。

**定义**：

- 操作系统服务的编程接口
- 通常由高级语言编写
- 程序访问通常是通过高层次的**API接口**（函数调用），而不是直接进行系统调用。

三种最常访问的API：

- Win32 API
- POSIX API用于POSIX-based systems（类UNIX，包括Linux和MacOS X的所有版本）
- Java API用于Java虚拟机（JVM）

**实现**：

- 每个系统调用对应一个系统调用编号：来维护**系统调用表**的索引
- 调用内核态中的**系统调用功能**实现，并返回系统调用的**状态和结果**
- **黑盒性**，用户不需要知道系统调用的实现

##### 系统调用和函数调用的不同

- INT和IRET用于系统调用：堆栈切换和特权级转换
- CALL和RET用于常规调用（**不用堆栈切换**）

##### 系统调用的开销

系统调用的开销是超过函数调用的，因为有一个从用户态到内核态的切换。

> 系统调用的开销大于函数调用，这主要是因为系统调用涉及到从用户态到内核态的上下文切换，而函数调用则通常在用户态内完成。具体体现在以下几个方面：
>
> 1. **上下文切换**：系统调用需要操作系统从用户态切换到内核态，这个过程需要保存用户态的状态，并加载内核态的状态。完成系统调用后，还需要再次切换回用户态。这个上下文切换过程涉及到寄存器和内存状态的保存与恢复，是一个相对耗时的操作。
>
> 2. **安全性检查**：系统调用通常涉及到资源的管理或者敏感操作，因此每次系统调用都需要进行权限检查和安全性验证，以确保调用是合法的。这些检查是必要的，但也增加了额外的开销。
>
> 3. **指令开销**：执行系统调用通常需要特殊的指令，如x86架构中的`int`（中断）或`syscall`/`sysenter`指令，这些指令本身的执行时间就比普通的函数调用指令要长。
>
> 4. **内核态资源访问**：系统调用通常需要访问内核资源，比如文件系统、网络堆栈、设备驱动等。这些资源可能涉及到锁定机制、队列等待等同步操作，这些都可能导致延迟。
>
> 5. **数据复制**：系统调用可能涉及到用户空间和内核空间之间的数据传输。例如，读写文件时，数据需要从用户空间复制到内核缓冲区，或者相反。这种复制操作也会增加开销。
>
> 相比之下，普通的函数调用只是在用户态的程序内部跳转，不需要上下文切换，也没有安全性检查和数据复制到内核空间的需求。因此，函数调用的开销相对较小。

## lab_1

### 练习一

1. 操作系统镜像文件ucore.img是如何一步一步生成的？(需要比较详细地解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果)

   为了解释这一问题，必须贴上Makefile的代码和执行结果。

   ```makefile
   PROJ	:= challenge
   EMPTY	:=
   SPACE	:= $(EMPTY) $(EMPTY)
   SLASH	:= /
   
   V       := @
   # PROJ := challenge：这个变量用于定义一个项目名或标识符，将它设为challenge。
   
   # EMPTY :=：定义了一个空变量，即没有赋值给它。
   
   # SPACE := $(EMPTY) $(EMPTY)：这里使用了之前定义的空变量，将两个空变量拼接在一起，实际上就是定义了一个包含两个空格的变量。这种技巧在 Makefile 中有时用于创建间隔或空格。
   
   # SLASH := /：定义了一个变量SLASH，将其设为/，即斜杠符号。可能用于指示路径分隔符。
   
   # V := @：这个变量将V设为@。在 Makefile 中，@符号通常用于抑制命令的输出，即在命令前加上@，使得执行命令时不显示这个命令本身。
   
   # 这些变量的作用是在后续的规则、命令或其他部分中引用，比如使用V来执行命令时不显示命令本身，或者在某些地方需要一个空格或斜杠时可以直接引用SPACE、SLASH等变量。这些变量的定义是为了在整个 Makefile 中统一管理、方便维护和修改。
   
   # try to infer the correct GCCPREFX
   ifndef GCCPREFIX
   GCCPREFIX := $(shell if i386-elf-objdump -i 2>&1 | grep '^elf32-i386$$' >/dev/null 2>&1; \
   	then echo 'i386-elf-'; \
   	elif objdump -i 2>&1 | grep 'elf32-i386' >/dev/null 2>&1; \
   	then echo ''; \
   	else echo "***" 1>&2; \
   	echo "*** Error: Couldn't find an i386-elf version of GCC/binutils." 1>&2; \
   	echo "*** Is the directory with i386-elf-gcc in your PATH?" 1>&2; \
   	echo "*** If your i386-elf toolchain is installed with a command" 1>&2; \
   	echo "*** prefix other than 'i386-elf-', set your GCCPREFIX" 1>&2; \
   	echo "*** environment variable to that prefix and run 'make' again." 1>&2; \
   	echo "*** To turn off this error, run 'gmake GCCPREFIX= ...'." 1>&2; \
   	echo "***" 1>&2; exit 1; fi)
   endif
   # 这部分代码是一个条件判断语句，用于设置变量 GCCPREFIX。让我逐步解释它的作用：
   
   # ifndef GCCPREFIX：这是一个条件判断语句，检查变量 GCCPREFIX 是否已经被定义。如果 GCCPREFIX 没有被定义，那么执行接下来的操作。
   
   # GCCPREFIX := $(shell ...)：这是一个赋值操作，使用 shell 函数执行一系列命令。它的作用是尝试推断出合适的 GCCPREFIX。具体的操作如下：
   
   # 首先，它尝试执行 i386-elf-objdump -i 命令，并检查输出是否包含 elf32-i386。如果找到了，它将 GCCPREFIX 设置为 'i386-elf-'。
   
   # 如果上面的尝试失败了，它接着尝试执行 objdump -i 命令，并检查输出是否包含 elf32-i386。如果找到了，它将 GCCPREFIX 设置为空字符串 ''。
   
   #如果两次尝试都失败了，它会输出一条错误信息，并提供一些可能的解决方案。最后，如果检测失败了，它会退出并返回错误码 1。
   
   # endif：结束条件判断的语句块。
   
   # 总体来说，这段代码的目的是根据当前系统环境尝试推断合适的 GCCPREFIX，以便在后续的编译过程中使用。它会检查是否存在特定的工具链，如果找到了就设置对应的 GCCPREFIX，如果找不到则给出错误提示。
   
   # try to infer the correct QEMU
   ifndef QEMU
   QEMU := $(shell if which qemu-system-i386 > /dev/null; \
   	then echo 'qemu-system-i386'; exit; \
   	elif which i386-elf-qemu > /dev/null; \
   	then echo 'i386-elf-qemu'; exit; \
   	else \
   	echo "***" 1>&2; \
   	echo "*** Error: Couldn't find a working QEMU executable." 1>&2; \
   	echo "*** Is the directory containing the qemu binary in your PATH" 1>&2; \
   	echo "***" 1>&2; exit 1; fi)
   endif
   # 和上面的内容类似，检查是否存在合适的qemu
   
   # eliminate default suffix rules
   .SUFFIXES: .c .S .h
   # 这个规则告诉 Make 不要使用默认的后缀规则来生成文件。通常，Make 会根据后缀来识别文件类型并确定如何编译它们。在这里，通过清空默认的后缀规则，用户可以自定义更灵活的规则来处理 .c、.S 和 .h 类型的文件，而不受默认规则的影响。
   
   # delete target files if there is an error (or make is interrupted)
   .DELETE_ON_ERROR:
   # 这个规则告诉 Make 在执行过程中，如果发生错误或者中断，应该删除那些正在构建的目标文件。这有助于确保在发生错误时，不会保留部分构建成功的目标文件，以免造成后续的问题。
   
   # define compiler and flags
   
   HOSTCC		:= gcc
   HOSTCFLAGS	:= -g -Wall -O2
   # 这两行定义了用于主机编译的编译器和编译选项。HOSTCC 设定为 gcc，表示使用 gcc 作为主机编译器。HOSTCFLAGS 设置了一系列编译选项，包括 -g（生成调试信息）、-Wall（显示所有警告信息）、-O2（启用优化级别2）。这些选项可以根据需要进行修改，用于在主机上编译源文件。
   
   CC		:= $(GCCPREFIX)gcc
   CFLAGS	:= -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc $(DEFS)
   CFLAGS	+= $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
   CTYPE	:= c S
   # 这几行代码定义了一些用于编译的变量，并为编译器和编译选项赋值。让我逐行解释：
   
   #1. `CC := $(GCCPREFIX)gcc`：这里定义了一个变量 `CC`，它用于存储编译器的名称。这里采用了 `GCCPREFIX` 变量作为前缀，并附加 `gcc`，表示在编译时使用特定前缀的 `gcc` 编译器。
   
   # 2. `CFLAGS := -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc $(DEFS)`：这个变量定义了编译时的一系列选项。解释如下：
   #   - `-fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc` 是一些编译选项：
   #     - `-fno-builtin`：禁用内建函数。
   #     - `-fno-PIC`：禁用位置无关代码（Position Independent Code）。
   #     - `-Wall`：启用大部分警告信息。
   #     - `-ggdb`：生成适用于 `gdb` 调试器的调试信息。
   #     - `-m32`：生成 32 位代码。
   #     - `-gstabs`：使用 `stabs` 格式的调试信息。
   #     - `-nostdinc`：不要搜索标准系统头文件目录。
   #   - `$(DEFS)` 是一个变量，可能包含一些额外的定义或标志。
   
   #3. `CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)`：这一行做了以下事情：
   #   - 使用 `shell` 命令执行一个子命令。
   #   - 子命令中使用 `$(CC)` 编译器来处理一个空的 C 文件 `/dev/null`，并试图使用 `-fno-stack-protector` 标志进行预处理。
   #   - 如果编译成功（没有报错），则添加 `-fno-stack-protector` 标志到 `CFLAGS` 变量中。
   #   - 这一步可能是为了检查编译器是否支持 `-fno-stack-protector` 标志，如果支持，则将其添加到编译选项中。
   
   #4. `CTYPE := c S`：这里定义了一个变量 `CTYPE`，它包含了源文件的类型，可能是 `c` 和 `S`，表示 `c` 源文件和 `S` 汇编文件。
   
   # 这些代码段定义了编译过程中使用的编译器、编译选项和源文件类型，确保了在构建过程中使用了特定的设置。
   
   LD      := $(GCCPREFIX)ld
   LDFLAGS	:= -m $(shell $(LD) -V | grep elf_i386 2>/dev/null | head -n 1)
   LDFLAGS	+= -nostdlib
   # 这些代码是关于链接器的设置，让我逐行解释：
   
   # 1. `LD := $(GCCPREFIX)ld`：这里定义了一个变量 `LD`，它存储了链接器的名称。`GCCPREFIX` 是之前推断的 GCC 前缀，这里使用它作为前缀，并附加 `ld`，表示在链接过程中使用特定前缀的链接器。
   
   # 2. `LDFLAGS := -m $(shell $(LD) -V | grep elf_i386 2>/dev/null | head -n 1)`：
   #   - `-m` 标志指定链接器的选项，这里是为了确定目标平台的体系结构。
   #   - `$(shell $(LD) -V | grep elf_i386 2>/dev/null | head -n 1)` 这部分是一个子命令：
   #     - `$(LD) -V` 获取链接器的版本信息。
   #     - `grep elf_i386` 过滤出包含 `elf_i386` 字符串的行。
   #     - `2>/dev/null` 将标准错误重定向到 `/dev/null`，即忽略错误输出。
   #     - `head -n 1` 只保留匹配结果的第一行。
   #   - 最终结果是，通过版本信息确定链接器的体系结构，从而设置了 `-m` 选项，可能是为了确保链接器工作在符合 `elf_i386` 格式的环境下。
   
   # 3. `LDFLAGS += -nostdlib`：`+=` 表示将 `-nostdlib` 选项追加到链接器标志中。`-nostdlib` 标志告诉链接器不使用标准系统库。
   
   # 这些代码用于定义链接器和链接器选项，在编译过程中确保了使用了指定的链接器以及相关的链接选项。
   
   OBJCOPY := $(GCCPREFIX)objcopy
   OBJDUMP := $(GCCPREFIX)objdump
   
   COPY	:= cp
   MKDIR   := mkdir -p
   MV		:= mv
   RM		:= rm -f
   AWK		:= awk
   SED		:= sed
   SH		:= sh
   TR		:= tr
   TOUCH	:= touch -c
   
   OBJDIR	:= obj
   BINDIR	:= bin
   
   ALLOBJS	:=
   ALLDEPS	:=
   TARGETS	:=
   
   include tools/function.mk
   
   listf_cc = $(call listf,$(1),$(CTYPE))
   # listf_cc = $(call listf,$(1),$(CTYPE))：这里定义了一个变量 listf_cc，它通过 $(call listf,$(1),$(CTYPE)) 的方式调用 listf 函数。listf 函数可能是在 tools/function.mk 中定义的，作用是获取特定类型的文件列表，这里使用了 $(CTYPE) 变量指示文件类型。
   
   # for cc
   add_files_cc = $(call add_files,$(1),$(CC),$(CFLAGS) $(3),$(2),$(4))
   create_target_cc = $(call create_target,$(1),$(2),$(3),$(CC),$(CFLAGS))
   
   # for hostcc
   add_files_host = $(call add_files,$(1),$(HOSTCC),$(HOSTCFLAGS),$(2),$(3))
   create_target_host = $(call create_target,$(1),$(2),$(3),$(HOSTCC),$(HOSTCFLAGS))
   # add_files_cc 和 add_files_host 是在Makefile中定义的函数，它们用于添加文件到构建过程中，但是它们的用途和上下文有所不同。
   
   # add_files_cc: 这个函数通常用于添加项目的源代码文件，这些文件将被交叉编译器（cross-compiler）编译。交叉编译器是为了生成在不同于构建环境的目标系统上运行的代码。例如，在构建操作系统或嵌入式系统时，开发者可能在x86架构的机器上编译用于ARM架构的代码。
   
   # add_files_cc 函数会根据指定的编译器（如$(CC)），编译标志（如$(CFLAGS)），和源文件列表，生成相应的编译规则和目标文件。这些目标文件最终会被链接成最终的可执行文件或库。
   
   # add_files_host: 相比之下，add_files_host 函数用于添加需要在构建环境本身运行的工具或程序的源代码文件。这些工具不是最终产品的一部分，而是辅助构建过程的工具，比如上面提到的sign工具。
   
   # add_files_host 函数会使用主机的编译器（如$(HOSTCC)），编译标志（如$(HOSTCFLAGS)），和源文件列表，生成编译这些工具所需的规则和目标文件。这些工具在构建过程中运行，通常不会被包含在最终的产品中。
   
   # 总结来说，add_files_cc 用于添加和编译最终产品的代码，而add_files_host 用于添加和编译构建过程中使用的工具代码。两者的主要区别在于它们编译的目标环境不同：一个是为了目标系统（可能是不同的架构），另一个是为了构建环境（即主机系统）。
   
   
   cgtype = $(patsubst %.$(2),%.$(3),$(1))
   objfile = $(call toobj,$(1))
   asmfile = $(call cgtype,$(call toobj,$(1)),o,asm)
   outfile = $(call cgtype,$(call toobj,$(1)),o,out)
   symfile = $(call cgtype,$(call toobj,$(1)),o,sym)
   
   # for match pattern
   match = $(shell echo $(2) | $(AWK) '{for(i=1;i<=NF;i++){if(match("$(1)","^"$$(i)"$$")){exit 1;}}}'; echo $$?)
   # 这段代码定义了一个名为 match 的变量，它通过 shell 的 echo 命令和 awk 实现了一种模式匹配的功能。具体来说，这段代码做了以下几件事：
   
   # $(shell ...)：这是一个 makefile 中的函数，它允许执行 shell 命令并返回结果给 match 变量。
   
   # echo $(2)：将传递给它的第二个参数（$(2)）作为字符串输出。
   
   #| $(AWK) '{for(i=1;i<=NF;i++){if(match("$(1)","^"$$(i)"$$")){exit 1;}}}'：使用管道将上一步的输出传递给 awk 命令进行处理。$(AWK) 是在 Makefile 中定义的 awk 工具。
   
   # $(1) 是 awk 命令中的第一个参数，^$$(i)$$ 是一个正则表达式模式。整个 awk 命令是一个循环，遍历了 $(2) 的字段（根据空格分隔的单词），然后使用 match 函数匹配 $(1) 是否以某个字段作为开头。如果匹配成功，则 exit 1 终止循环，并返回 1。
   
   # echo $$?：这个命令会输出上一个命令的返回值。$$? 是 shell 变量，代表上一个命令执行后的返回值，也就是 awk 命令中的 exit 1 的返回值。
   
   # 综合来说，这段代码的作用是检查第一个参数（$(1)）是否与第二个参数（$(2)）中的任何一个字段匹配，并返回一个布尔值作为结果。
   
   
   # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   # include kernel/user
   
   INCLUDE	+= libs/
   
   CFLAGS	+= $(addprefix -I,$(INCLUDE))
   
   LIBDIR	+= libs
   
   # 这段代码用于配置编译器的包含路径和一些编译选项。
   
   # 1. `INCLUDE += libs/`：这里将 `libs/` 目录添加到 `INCLUDE` 变量中。`INCLUDE` 可能是一个包含了头文件路径的变量，通过 `+=` 操作符，将 `libs/` 目录添加到现有的路径列表中。
   
   # 2. `CFLAGS += $(addprefix -I,$(INCLUDE))`：这行代码是将 `-I` 标志添加到 `CFLAGS` 变量中。`-I` 标志用于指定编译器查找头文件的路径。`addprefix` 函数会在 `$(INCLUDE)` 中的每个路径前面添加 `-I`，这样就将 `INCLUDE` 中的路径都转换成了编译器可识别的头文件路径。
   
   # 3. `LIBDIR += libs`：这里将 `libs` 目录添加到 `LIBDIR` 变量中。`LIBDIR` 可能是一个包含库文件路径的变量，通过 `+=` 操作符，将 `libs` 目录添加到现有的路径列表中。
   
   # 综合来看，这段代码的目的是将 `libs/` 目录添加到编译器的头文件搜索路径中（使用 `-I` 标志），并且将 `libs` 目录添加到库文件搜索路径中（这部分在提供的代码中并没有直接使用，但是有可能在后续的编译过程中会用到）。
   
   $(call add_files_cc,$(call listf_cc,$(LIBDIR)),libs,)
   
   # -------------------------------------------------------------------
   # kernel
   
   KINCLUDE	+= kern/debug/ \
   			   kern/driver/ \
   			   kern/trap/ \
   			   kern/mm/
   # 将一系列内核代码的头文件路径添加到 KINCLUDE 变量中。
   
   KSRCDIR		+= kern/init \
   			   kern/libs \
   			   kern/debug \
   			   kern/driver \
   			   kern/trap \
   			   kern/mm
   # 将一系列内核代码的源文件目录添加到 KSRCDIR 变量中。
   
   KCFLAGS		+= $(addprefix -I,$(KINCLUDE))
   # 将 KINCLUDE 中的路径通过 -I 标志添加到 KCFLAGS 变量中，这样编译器在编译时会包含这些头文件路径。
   
   $(call add_files_cc,$(call listf_cc,$(KSRCDIR)),kernel,$(KCFLAGS))
   # 调用了 add_files_cc 函数，该函数可能是一个通用的函数，用于向编译器添加一系列源文件以及相关的编译选项。这里使用了 $(call listf_cc,$(KSRCDIR)) 获取了 KSRCDIR 中的源文件列表，然后使用 $(KCFLAGS) 作为编译选项传递给 add_files_cc 函数，最终把这些源文件编译成了一个名为 kernel 的目标。
   
   KOBJS	= $(call read_packet,kernel libs)
   # 这里可能是定义了一个变量 KOBJS，用于存储编译后的目标文件，它通过 read_packet 函数将 kernel 和 libs 作为参数，可能会处理这些目标文件。
   
   # create kernel target
   kernel = $(call totarget,kernel)
   # 定义了一个名为 kernel 的变量，通过 totarget 函数可能会返回一个特定的目标文件名，这里是 kernel。
   
   $(kernel): tools/kernel.ld
   # 这是一个生成 kernel 目标文件的规则。表示 kernel 依赖于 tools/kernel.ld 文件。
   
   $(kernel): $(KOBJS)
   	@echo + ld $@
   	$(V)$(LD) $(LDFLAGS) -T tools/kernel.ld -o $@ $(KOBJS)
   	@$(OBJDUMP) -S $@ > $(call asmfile,kernel)
   	@$(OBJDUMP) -t $@ | $(SED) '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $(call symfile,kernel)
   # 接下来的命令是编译链接内核，通过 $(LD) 将目标文件链接成最终的 kernel，然后使用 OBJDUMP 生成汇编文件和符号表文件。
   
   $(call create_target,kernel)
   # 可能是调用一个函数 create_target 来创建名为 kernel 的目标。
   
   # -------------------------------------------------------------------
   
   # create bootblock
   bootfiles = $(call listf_cc,boot)
   # 通过 listf_cc 函数获取了引导块（boot）的文件列表，存储在 bootfiles 变量中。
   
   $(foreach f,$(bootfiles),$(call cc_compile,$(f),$(CC),$(CFLAGS) -Os -nostdinc))
   # 对于 bootfiles 中的每个文件 f，调用了 cc_compile 函数（可能是一个通用的编译函数），编译这些文件。这里使用了 $(CC) 作为编译器，$(CFLAGS) -Os -nostdinc 作为编译选项。
   
   bootblock = $(call totarget,bootblock)
   # 定义了一个名为 bootblock 的变量，通过 totarget 函数获取了目标文件名。
   
   $(bootblock): $(call toobj,$(bootfiles)) | $(call totarget,sign)
   	@echo + ld $@
   	$(V)$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 $^ -o $(call toobj,bootblock)
   	@$(OBJDUMP) -S $(call objfile,bootblock) > $(call asmfile,bootblock)
   	@$(OBJDUMP) -t $(call objfile,bootblock) | $(SED) '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $(call symfile,bootblock)
   	@$(OBJCOPY) -S -O binary $(call objfile,bootblock) $(call outfile,bootblock)
   	@$(call totarget,sign) $(call outfile,bootblock) $(bootblock)
   # 这是一个规则，表示生成 bootblock 这个目标文件。它依赖于 $(call toobj,$(bootfiles)) 返回的文件列表和另一个名为 sign 的目标。| 符号表示 bootblock 的构建还依赖于 sign 这个目标。
   # 接下来的命令是链接操作。使用 $(LD) 链接器将目标文件链接成最终的 bootblock。然后使用 OBJDUMP 生成汇编文件和符号表文件，最后使用 OBJCOPY 将目标文件转换为二进制文件。
   
   
   $(call create_target,bootblock)
   # 可能是调用一个函数 create_target 来创建名为 bootblock 的目标。
   # -------------------------------------------------------------------
   
   # create 'sign' tools
   $(call add_files_host,tools/sign.c,sign,sign)
   $(call create_target_host,sign,sign)
   
   # -------------------------------------------------------------------
   
   # create ucore.img
   UCOREIMG	:= $(call totarget,ucore.img)
   # 定义了一个名为 UCOREIMG 的变量，使用 totarget 函数生成了 ucore.img 的目标文件路径或名称。
   
   # 定义了构建 ucore.img 目标文件的规则。这个规则表明 ucore.img 文件依赖于 kernel 和 bootblock 这两个目标文件。
   $(UCOREIMG): $(kernel) $(bootblock)
   	$(V)dd if=/dev/zero of=$@ count=10000
   	$(V)dd if=$(bootblock) of=$@ conv=notrunc
   	$(V)dd if=$(kernel) of=$@ seek=1 conv=notrunc
   # $(V)dd if=/dev/zero of=$@ count=10000：创建一个大小为10000块的空文件，用 /dev/zero 的内容填充，其中 $@ 表示目标文件的名称 ucore.img。
   # $(V)dd if=$(bootblock) of=$@ conv=notrunc：将 bootblock 的内容复制到 ucore.img 文件中，conv=notrunc 表示不截断输出文件。这个命令会将 bootblock 的内容写入 ucore.img 的开头。
   # $(V)dd if=$(kernel) of=$@ seek=1 conv=notrunc：将 kernel 的内容追加到 ucore.img 文件中，seek=1 表示跳过文件开头，从第1个块开始写入，conv=notrunc 表示不截断输出文件。
   
   $(call create_target,ucore.img)
   # $(call create_target,ucore.img)：这可能是调用一个函数 create_target 来创建名为 ucore.img 的目标。
   
   # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   
   $(call finish_all)
   
   # 后面的内容应该就是一些命令行参数的定义，不是特别重要就暂时不写注释了。
   IGNORE_ALLDEPS	= clean \
   				  dist-clean \
   				  grade \
   				  touch \
   				  print-.+ \
   				  handin
   
   ifeq ($(call match,$(MAKECMDGOALS),$(IGNORE_ALLDEPS)),0)
   -include $(ALLDEPS)
   endif
   
   # files for grade script
   
   TARGETS: $(TARGETS)
   all: $(TARGETS)
   .DEFAULT_GOAL := TARGETS
   
   .PHONY: qemu qemu-nox debug debug-nox
   lab1-mon: $(UCOREIMG)
   	$(V)$(TERMINAL) -e "$(QEMU) -S -s -d in_asm -D $(BINDIR)/q.log -monitor stdio -hda $< -serial null"
   	$(V)sleep 2
   	$(V)$(TERMINAL) -e "gdb -q -x tools/lab1init"
   debug-mon: $(UCOREIMG)
   #	$(V)$(QEMU) -S -s -monitor stdio -hda $< -serial null &
   	$(V)$(TERMINAL) -e "$(QEMU) -S -s -monitor stdio -hda $< -serial null"
   	$(V)sleep 2
   	$(V)$(TERMINAL) -e "gdb -q -x tools/moninit"
   qemu-mon: $(UCOREIMG)
   	$(V)$(QEMU) -monitor stdio -hda $< -serial null
   qemu: $(UCOREIMG)
   	$(V)$(QEMU) -parallel stdio -hda $< -serial null
   
   qemu-nox: $(UCOREIMG)
   	$(V)$(QEMU) -serial mon:stdio -hda $< -nographic
   TERMINAL        :=gnome-terminal
   gdb: $(UCOREIMG)
   	$(V)$(QEMU) -S -s -parallel stdio -hda $< -serial null
   debug: $(UCOREIMG)
   	$(V)$(QEMU) -S -s -parallel stdio -hda $< -serial null &
   	$(V)sleep 2
   	$(V)$(TERMINAL)  -e "cgdb -q -x tools/gdbinit"
   	
   debug-nox: $(UCOREIMG)
   	$(V)$(QEMU) -S -s -serial mon:stdio -hda $< -nographic &
   	$(V)sleep 2
   	$(V)$(TERMINAL) -e "gdb -q -x tools/gdbinit"
   
   debug-nogdb: $(UCOREIMG)
   	$(V)$(QEMU) -S -s -parallel stdio -hda $< -serial null
   
   .PHONY: grade touch
   
   GRADE_GDB_IN	:= .gdb.in
   GRADE_QEMU_OUT	:= .qemu.out
   HANDIN			:= proj$(PROJ)-handin.tar.gz
   
   TOUCH_FILES		:= kern/trap/trap.c
   
   MAKEOPTS		:= --quiet --no-print-directory
   
   grade:
   	$(V)$(MAKE) $(MAKEOPTS) clean
   	$(V)$(SH) tools/grade.sh
   
   touch:
   	$(V)$(foreach f,$(TOUCH_FILES),$(TOUCH) $(f))
   
   print-%:
   	@echo $($(shell echo $(patsubst print-%,%,$@) | $(TR) [a-z] [A-Z]))
   
   .PHONY: clean dist-clean handin packall
   clean:
   	$(V)$(RM) $(GRADE_GDB_IN) $(GRADE_QEMU_OUT)
   	-$(RM) -r $(OBJDIR) $(BINDIR)
   
   dist-clean: clean
   	-$(RM) $(HANDIN)
   
   handin: packall
   	@echo Please visit http://learn.tsinghua.edu.cn and upload $(HANDIN). Thanks!
   
   packall: clean
   	@$(RM) -f $(HANDIN)
   	@tar -czf $(HANDIN) `find . -type f -o -type d | grep -v '^\.*$$' | grep -vF '$(HANDIN)'`
   ```

   这边我需要尝试解释这个`Makefile`文件：

   > 你的总结基本上是准确的，我会对你的描述进行检查和补充。
   >
   > 1. **变量定义**:
   >    你正确地指出，Makefile的头部定义了一系列变量，用于配置项目名称、路径、命令前缀等。这些变量确实为后续的编译和链接过程提供了基础配置。
   >
   > 2. **环境检查**:
   >    Makefile确实会检查系统中是否存在特定前缀的GCC工具链（`i386-elf-`），这是为了交叉编译用于不同平台的代码。如果没有找到合适的工具链，它会提示错误。
   >
   > 3. **QEMU检查**:
   >    类似地，Makefile会检查是否存在`qemu-system-i386`，这是用于模拟i386架构的QEMU虚拟机。如果没有找到，它同样会提示错误。
   >
   > 4. **Make规则配置**:
   >    你提到的“不使用默认的后缀规则”和“发生错误时删除目标文件”是Makefile的两个配置项，确保了编译过程的特定行为。
   >
   > 5. **Shell命令别称**:
   >    你正确地识别了Makefile中定义的一系列别称，它们为常用的编译、链接和其他命令提供了简化的引用方式。
   >
   > 6. **引入外部.mk文件**:
   >    `tools/function.mk`确实可能包含了一些预定义的函数，这些函数用于简化Makefile中的文件操作和编译规则的定义。
   >
   > 接下来，我会补充你后面不太明白的部分：
   >
   > 7. **编译和链接规则**:
   >    Makefile中定义了一系列的规则，用于编译源代码文件（C和汇编文件）并将它们链接成可执行文件。这些规则使用了之前定义的变量和引入的函数。
   >
   > 8. **目标文件和依赖关系**:
   >    Makefile定义了多个目标（如`kernel`, `bootblock`, `ucore.img`等），以及它们之间的依赖关系。这些目标对应于构建过程中的不同阶段，例如编译内核、创建引导块和生成完整的磁盘镜像。
   >
   > 9. **清理和辅助目标**:
   >    Makefile还包含了用于清理构建文件、打包和调试的辅助目标。这些目标使得开发者可以轻松地管理和测试他们的代码。
   >
   > 10. **条件编译**:
   >     Makefile使用条件判断来决定是否包含依赖文件，这取决于`MAKECMDGOALS`，以此来优化构建过程。
   >
   > 11. **伪目标声明**:
   >     通过`.PHONY`声明，Makefile确保了即使存在同名文件，也会执行指定的目标。
   >
   > 总的来说，这个Makefile为操作系统项目提供了一个完整的构建和管理框架，包括自动化编译、链接、生成二进制文件、清理和调试等功能。

   2. 一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？
      答：一个被系统认为是符合规范的硬盘主引导扇区的特征是，它以`0x55`和`0xAA`作为最后扇区的最后两个字节。这两个字节标识着这是一个主引导扇区，其中前面`446`个字节包含了一些指令等内容，`64`个字节包含了分区表信息（每个主分区记录大小为16字节，因此最多有4个主分区），最后剩余的`2`个字节则标识出它是一个主引导记录。<font color="red">值得注意的是，这是旧时MBR分区格式下的特征。新式的GPT分区格式会有所不同。</font>

      > 这段描述基本上是准确的，它概述了MBR（Master Boot Record）分区格式下硬盘主引导扇区的结构。确实，主引导扇区是硬盘上的第一个扇区（通常是512字节），它包含了启动计算机所需的代码和分区表。
      >
      > 这里的描述可以补充一些细节：
      >
      > 1. **引导代码**：前446个字节通常包含了引导代码，这部分代码负责在计算机启动时加载操作系统。
      >
      > 2. **分区表**：接下来的64个字节是分区表，它包含了硬盘上的分区信息。每个分区表项占用16字节，因此最多可以有4个分区表项，这些表项描述了硬盘上的主分区。
      >
      > 3. **有效标志**：最后两个字节（0x55和0xAA）是有效标志，这是用来标识一个有效的引导扇区。如果这两个字节不是0x55和0xAA，计算机的BIOS或UEFI不会认为这是一个有效的引导扇区，因此不会从该硬盘启动。
      >
      > 需要补充的是，GPT（GUID Partition Table）是一个较新的分区格式，它支持超过2TB的硬盘和多于4个的主分区。GPT分区格式的硬盘也有一个保护MBR，位于硬盘的第一个扇区，但它的结构和目的与传统MBR不同。GPT的实际分区表和引导数据位于硬盘的其他部分。
      >
      > 此外，对于GPT分区格式，引导数据通常位于EFI系统分区（ESP），这是一个特殊的分区，用于存储UEFI引导加载器和相关数据，而不是传统的MBR引导代码。
   
   ### 练习二
   
   为了熟悉使用qemu和gdb进行的调试工作，我们进行如下的小练习：
   
   1. 从CPU加电后执行的第一条指令开始，单步跟踪BIOS的执行。
   2. 在初始化位置0x7c00设置实地址断点,测试断点正常。
   3. 从0x7c00开始跟踪代码运行,将单步跟踪反汇编得到的代码与bootasm.S和 bootblock.asm进行比较。
   4. 自己找一个bootloader或内核中的代码位置，设置断点并进行测试。
   
   在这里，我会逐个解释这些任务是如何完成的。
   
   1. CPU加电后的第一条指令，指的就是CPU加电时它的代码段寄存器（CS）和当前指令指针（EIP）指向的段：偏移地址，这是一个线性地址，在没有启动页机制的情况下它也是一个物理地址。这个物理地址指向了`0xffff0`这个地址，这是加电后执行的第一条指令的位置。
   
      那么，如何进行单步跟踪呢？首先我们需要注意到，在`Makefile`中有这么一段：
   
      ```makefile
      debug: $(UCOREIMG)
      	$(V)$(QEMU) -S -s -parallel stdio -hda $< -serial null &
      	$(V)sleep 2
      	$(V)$(TERMINAL)  -e "cgdb -q -x tools/gdbinit"
      
      这段代码是一个Makefile脚本的一部分，通常用于自动化编译和调试过程。它定义了一个名为`debug`的目标，该目标用于启动QEMU模拟器以运行和调试一个名为`$(UCOREIMG)`的操作系统镜像。下面是每一行代码的详细解释：
      
      1. `debug: $(UCOREIMG)`
         这行定义了一个Makefile规则的目标`debug`，它依赖于变量`$(UCOREIMG)`。这通常意味着在执行`debug`目标之前，`$(UCOREIMG)`需要被创建或是最新的。
      
      2. `$(V)$(QEMU) -S -s -parallel stdio -hda $< -serial null &`
         这行代码执行QEMU命令来启动一个虚拟机：
         - `$(V)`和`$(QEMU)`是Makefile变量，它们可能被定义为控制命令的可视化输出和QEMU的路径。
         - `-S`参数告诉QEMU在启动时暂停CPU的执行，等待调试器的连接。
         - `-s`参数是一个便捷选项，它创建了一个GDB服务器监听在默认的TCP端口1234上。
         - `-parallel stdio`可能是将QEMU的并行端口重定向到标准输入输出。
         - `-hda $<`指定了要使用的硬盘镜像，`$<`是Makefile的自动变量，它代表规则依赖中的第一个项，在这里是`$(UCOREIMG)`。
         - `-serial null`将串行端口输出重定向到null，这样可以避免在QEMU中显示额外的信息。
         - `&`将QEMU进程放到后台执行。
      
      3. `$(V)sleep 2`
         这行代码使得Makefile脚本暂停执行2秒钟。这通常是为了给QEMU足够的时间启动并等待调试器的连接。
      
      4. `$(V)$(TERMINAL) -e "cgdb -q -x tools/gdbinit"`
         这行代码打开一个新的终端窗口并执行`cgdb`，一个图形化的GDB前端：
         - `$(TERMINAL)`是一个变量，指向用户的终端程序。
         - `-e`参数指定终端执行的命令。
         - `"cgdb -q -x tools/gdbinit"`启动`cgdb`并告诉它使用`tools/gdbinit`作为GDB的初始化脚本。`-q`参数使`cgdb`在启动时不显示任何欢迎信息。
      
      综上所述，这段代码的作用是为了调试`$(UCOREIMG)`操作系统镜像。它启动了一个QEMU虚拟机实例，并设置了GDB调试器，允许开发者在图形界面中调试操作系统代码。
      ```
   
      这里是定义了一个类似`make`命令的参数形式，当我们执行`make debug`时，`shell`中会执行`debug`这个块中的所有命令。
   
      注意到，这些命令中包含了`"cgdb -q -x tools/gdbinit"`，也就是说需要用到`tools/gdbinit`这个文件用来初始化`gdb`，`gdbinit`的初始内容如下：
   
      ```shell
      file obj/bootblock.o
      target remote :1234
      break bootmain
      continue
      ```
   
      在不修改这个文件的情况下，它会输出关于目标文件`bootblock`的一些基本信息，然后链接到`qemu`，在`bootmain`这个函数的起始位置设置一个断点，随后启动程序。
   
      因此，为了我们的单步调试，我们将这个文件内容修改为：
   
      ```shell
      file obj/bootblock.o
      set architecture i8086
      break *0xffff0	# 这句没用
      target remote :1234
      break *0x7c00
      ```
   
      这将调试环境设置为`i8086`，并链接到`qemu`以及在两个内存地址处设置断点。一个问题在于，在`0xffff0`这个位置设置的断点似乎并不能被触发，暂时没明白原因。至于`0x7c00`这个地址是`bios`找到了主引导记录后将操作系统内核加载到内存中的位置，也是我们下一个问题要做的。
   
   2. 这个问题在上面已经得到解答。
   
   3. 单步机器代码执行的指令是`si`，在`gdb`调试器中输入即可。输入`x /10i $pc`可以查看接下来十条反汇编的代码，在执行`bootmain`函数之前，它的内容和`bootasm.S`和`bootblock.asm`的内容都是相同的。

