# 笔记

## 第一章 操作系统概述

本课程为清华大学操作系统课程，主要讲述以下模块：

- 中断和系统调用：中断是软件和硬件的联结，而系统调用是应用软件和系统软件的联结。
- 内存管理：负责调度内存资源，包括物理内存和虚存。
- 进程和线程：负责程序运行过程的调度
- CPU调度：进程共用处理器时的时间共享
- 进程间通信：同步互斥
- 文件系统：组织文件，便于读写和查找
- I/O子系统：使用较为统一性的接口对不同的外设兼容

### 1.1 操作系统定义

- 操作系统可以看作是一种控制程序，控制各个程序的执行，以防止不当的使用并为使用者提供服务。
- 操作系统可以看作是软件和硬件之间的中间层，它协调软硬件之间的通信并完成相应的任务。

操作系统是一种系统软件，它对外提供的接口是`Shell`和`GUI`。

操作系统的内核包含以下特征：

- 并发：多个程序同时运行
- 共享：宏观上程序共享CPU，微观上它们之间是互斥的，CPU不存在真正的意义上的同步。
- 虚拟：使用多道程序技术，让每个用户都感到自己被单独服务。
- 异步：保证异步程序执行的正确性（比如，当一个程序在运行过程中时间片耗尽而进入等待，操作系统需要保存它当前的状态并能够在下次执行时能在正确的状态下）。

### 1.2 操作系统的难点

- 代码量大
- 并发性和琐碎的调度算法的挑战。
- 高效性、低耗性、稳定性需求，具有一定的硬件编程的性质。
- 锁的问题：操作系统底层必须互斥
- 权衡：时间-空间、性能和可预测性、公平和性能等
- 管理**原始**硬件：中断、异常、上下文切换、TLB和页表、汇编语言

### 1.3~1.5 重点

这部分描述了操作系统的发展流程，具体百度即可。

操作系统的结构也分为好几种：

- 分层结构，逐层向上进行封装。
- 微内核结构，应用程序直接和内核功能进行交互。
- 外核结构，将部分物理资源分给多个程序，让每个程序决定如何处理这些资源。（虚拟机就是一种外核结构）

### 额外知识：CPU的运行模式

实模式（Real Mode）和保护模式（Protected Mode）是指中央处理器（CPU）的两种不同的运行模式，主要存在于Intel x86架构的处理器中。

**实模式：**
实模式是最初的8086和8088处理器所运行的模式，也是所有x86处理器在启动时的默认模式。在实模式下，CPU寻址是直接的，它使用20位地址总线，可以直接访问1MB的内存空间。实模式不支持高级的内存管理功能，如分页或内存保护。由于没有内存保护，任何程序都可以访问任何内存地址，这就意味着一个程序可以轻易地干扰另一个程序的运行，导致系统不稳定。

**保护模式：**
保护模式首次出现在80286处理器中，它提供了更高级的内存管理能力。在保护模式下，CPU使用32位（或在更现代的处理器中使用64位）地址总线，可以访问超过1MB的内存。保护模式引入了分段和分页机制，允许操作系统实现进程间的内存隔离，从而提高了系统的稳定性和安全性。此外，保护模式支持多任务处理，允许多个程序同时运行，而不会互相干扰。

**其他模式：**

- **虚拟8086模式：** 这是保护模式下的一个特殊模式，允许保护模式的操作系统在一个受保护的环境中运行实模式程序。这种模式常用于运行旧的DOS程序。

- **长模式（Long Mode）：** 这是在64位x86处理器上运行的模式，它支持64位的内存寻址，可以访问更大的内存空间。长模式同时支持运行32位和64位的应用程序。

- **系统管理模式（System Management Mode, SMM）：** 这是一种特殊的操作模式，用于处理系统级的功能，如电源管理和硬件控制。这个模式通常对操作系统是不可见的。

- **无管理模式（Unreal Mode）：** 这不是官方的CPU模式，而是通过对实模式的一些操作来扩展访问超过1MB内存的非正式模式。

每种模式都有其特定的用途和操作环境，随着计算机硬件的发展，新的模式和功能不断被引入以满足现代计算的需求。

## 第二章 启动、中断、异常和系统调用

### 2.1 计算机系统的启动过程

<font color="red">cpu加电后，执行的第一条指令在**内存**中。</font>

但是作为一个随机读写存储器（RAM），我们早就学过它的特点就是断电后丢失数据，那么哪来的指令让cpu去读呢？cpu为什么知道要去内存读呢？

这里课程里讲的真没听太懂，完整介绍流程在<[BIOS固件-电脑开机的启动流程 - tyong - 博客园 (cnblogs.com)](https://www.cnblogs.com/tyong/articles/10141205.html)>。这里给出个人理解的流程：
$$
BIOS\rightarrow硬件自检\rightarrow启动顺序\rightarrow存储设备
\\
\rightarrow主引导记录\rightarrow分区表\rightarrow活动分区\rightarrow卷引导记录
\\
\rightarrow启动管理器\rightarrow列出可启动的操作系统供用户选择\rightarrow加载操作系统
$$
计算机的整个启动过程分为四个阶段：

#### 第一阶段：BIOS

上个世纪70年代初，"只读内存"（read-only memory，缩写为ROM）发明，开机程序被刷入ROM芯片，计算机通电后，第一件事就是读取它。

这块芯片里的程序叫做"基本输入输出系統"（Basic Input/Output System），简称为BIOS。

##### 硬件自检

BIOS程序首先检查，计算机硬件能否满足运行的基本条件，这叫做"硬件自检"（Power-On Self-Test），缩写为POST。

如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止。如果没有问题，屏幕就会显示出CPU、内存、硬盘等信息。

##### 启动顺序

硬件自检完成后，BIOS把控制权转交给下一阶段的启动程序。

这时，BIOS需要知道，"下一阶段的启动程序"具体存放在哪一个设备。也就是说，BIOS需要有一个外部储存设备的排序，排在前面的设备就是优先转交控制权的设备。这种排序叫做"启动顺序"（Boot Sequence）。

打开BIOS的操作界面，里面有一项就是"设定启动顺序"。

#### 第二阶段：主引导记录


BIOS按照"启动顺序"，把控制权转交给排在第一位的储存设备。

这时，计算机读取该设备的第一个扇区，也就是读取最前面的512个字节。如果这512个字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给"启动顺序"中的下一个设备。

这最前面的512个字节，就叫做"主引导记录"（Master boot record，缩写为MBR）。

> 0x55 和 0xAA 是两个十六进制数，分别对应于十进制的 85 和 170。在计算机中，这两个数通常作为主引导记录（MBR，Master Boot Record）的最后两个字节，用来标识一个有效的引导扇区。
>
> MBR 是硬盘的第一个扇区（通常是 512 字节），它包含了启动计算机操作系统所需的代码和分区表。MBR 的结构通常如下：
>
> - 引导代码（Boot code）：这部分包含了一些基本的代码，用于启动计算机。
> - 分区表（Partition table）：描述硬盘分区的信息。
> - 签名字节（Signature bytes）：0x55 和 0xAA，位于扇区的最后两个字节（第 511 和第 512 字节）。
>
> 使用 0x55 和 0xAA 作为标识符的原因主要是历史和传统。这两个字节作为“魔术数字”（magic numbers），在早期的IBM PC 兼容机中被用来标识一个扇区是否是可引导的。这个约定被广泛接受，并成为了行业标准。选择这两个特定的值可能是因为它们的位模式（0x55 = 01010101b，0xAA = 10101010b）在某种程度上是互补的，这种模式可能有助于错误检测。
>
> 在计算机引导过程中，BIOS（基本输入输出系统）会检查连接的存储设备的第一个扇区的最后两个字节，如果这两个字节是 0x55 和 0xAA，BIOS 就会认为这是一个有效的引导扇区，并从中加载引导代码来启动操作系统。如果这两个字节不是 0x55 和 0xAA，BIOS 将认为该扇区不是一个有效的引导扇区，将不会从该设备启动，并会继续检查其他设备。
>
> <font color="blue">Question:</font>    假如我的启动顺序最前面是光盘，然后是硬盘。但是在启动计算机时，我并没有放入光盘。那计算机究竟是跳过光盘启动还是说有什么办法知道没有光盘，接着从硬盘尝试读主引导记录并启动？
>
> <font color="green">Answer:</font>    当计算机启动时，BIOS（基本输入输出系统）会根据设置的启动顺序来检查每个设备是否包含可启动的媒体。如果您的启动顺序中光盘驱动器排在硬盘之前，BIOS会首先检查光盘驱动器。
>
> 如果光盘驱动器中没有光盘，或者光盘不是一个启动盘，BIOS会检测到光盘驱动器中没有可启动的媒体。这通常是通过尝试读取光盘的启动扇区来完成的。如果读取失败或者启动扇区不包含有效的启动签名（例如，不包含0x55和0xAA这样的魔术数字），BIOS会认为光盘驱动器不包含有效的启动记录。
>
> 在确认光盘驱动器中没有可启动媒体之后，BIOS会继续按照启动顺序检查下一个设备，也就是硬盘。然后，BIOS会尝试从硬盘的主引导记录（MBR）读取启动信息。如果硬盘的MBR是有效的（即包含正确的启动签名），BIOS会从硬盘加载MBR中的引导代码，并开始操作系统的启动过程。
>
> 如果所有配置的启动设备都没有找到可启动的媒体，BIOS通常会显示一条错误消息，例如“No bootable device”或“Insert boot media in selected boot device and press a key”，提示用户没有找到可启动的设备。

##### 主引导记录的结构

"主引导记录"只有512个字节，放不了太多东西。它的主要作用是，告诉计算机到硬盘的哪一个位置去找操作系统。

主引导记录了由三个部分组成：

1. 第1~446字节：446字节，调用操作系统的机器码
2. 第447~510字节：64字节，分区表（Partition table）
3. 第511~512字节：主引导记录签名（0x55和0xAA）

其中，第二部分"分区表"的作用，是将硬盘分成若干个区。

##### 分区表

考虑到每个区可以安装不同的操作系统，"主引导记录"因此必须知道将控制权转交给哪个区。

分区表的长度只有64个字节，里面又分成四项，每项16个字节。所以，一个硬盘最多只能分四个一级分区，又叫做"主分区"。

每个主分区在分区表中的大小均为16字节，分为6个部分：

1.  第1个字节：如果为0x80，就代表该主分区是激活分区，控制权要转交给这个分区。四个主分区里面只能有一个是激活的。
2.  第2~4字节：主分区第一个扇区的物理位置（柱面、磁头、扇区号等）。
3.  第5个字节：主分区类型。
4.  第6~8字节：主分区最后一个扇区的物理位置。
5.  第9~12字节：该主分区的第一个扇区的逻辑地址。
6.  第13~16字节：主分区的扇区总数。

最后的四个字节（"主分区的扇区总数"），决定了这个主分区的长度。也就是说，一个主分区的扇区总数最多不超过2的32次方。

如果每个扇区为512个字节，就意味着单个分区最大不超过2TB。再考虑到扇区的逻辑地址也是32位，所以单个硬盘可利用的空间最大也不超过2TB。如果想使用更大的硬盘，只有2个方法：一是提高每个扇区的字节数，二是增加扇区总数。

> 你提到的内容是关于传统的MBR（Master Boot Record）分区表的结构和限制。MBR是硬盘的一种分区方案，它存在于硬盘的最前面，是硬盘启动的关键所在。MBR中包含了启动代码和分区表信息，而分区表就是用来记录硬盘分区情况的数据结构。
>
> 你的描述非常准确，MBR分区表中确实只有64个字节用于描述分区，分成四个16字节的分区表项，每个表项描述一个主分区。这里的限制是每个硬盘最多只能有四个主分区，或者三个主分区加一个扩展分区。扩展分区可以被进一步分割成多个逻辑分区。
>
> 关于MBR的限制，你提到了两个主要的点：
>
> 1. 单个分区大小的限制：由于分区表中记录扇区总数的字段是一个32位的数，所以最大值是$2^{32-1}$个扇区。如果每个扇区大小为512字节，那么最大数量分区情况下总大小为$512 * 2^{32}$字节，即`2TB`。
>
> 2. 硬盘大小的限制：由于MBR使用32位地址来记录扇区位置，所以它最多只能寻址到2^32个扇区，这同样限制了硬盘的最大大小为2TB（如果扇区大小为512字节）。
>
> 为了解决这些限制，现代计算机系统通常使用GPT（GUID Partition Table）分区方案。GPT不受MBR的这些限制，因为它使用64位的地址来记录扇区位置，这使得理论上的最大分区和硬盘大小可以达到ZB（Zettabytes）级别，远远超过了当前硬盘技术的容量。
>
> 此外，GPT分区表存储在硬盘的前面和后面，提供了冗余保护，即使一部分数据损坏，也能恢复分区信息。GPT还包含了对分区的名称和类型的描述，以及其他的一些先进特性，使得它成为了大容量硬盘的首选分区方案。

在硬盘上，分区格式的信息是存储在硬盘的前面几个扇区中的。对于MBR和GPT分区格式，这些信息的存储方式有所不同：

1. **MBR（Master Boot Record）**：在MBR分区格式中，分区信息存储在硬盘的第一个扇区（通常称为扇区0）。这个扇区包含了启动代码（Bootstrap Code）、分区表和一个有效性标志（通常是0x55AA）。BIOS在启动过程中会读取这个扇区，并根据其中的代码和分区表来加载操作系统。

2. **GPT（GUID Partition Table）**：GPT分区格式采用了不同的方式。它在硬盘的第一个扇区也存储了一个保护性MBR（Protective MBR），这是为了向后兼容那些只能识别MBR的工具。保护性MBR的分区表只包含一个条目，这个条目占据了整个硬盘，但实际上并不用于分区。真正的GPT头部信息是存储在硬盘的第二个扇区，它包含了GPT分区表的位置、大小和循环冗余校验（CRC）校验值等信息。GPT分区表本身则紧随GPT头部信息之后。

对于BIOS和GPT的兼容性问题，事实上传统的BIOS并不支持GPT分区格式。BIOS是在UEFI之前的固件标准，它只能识别MBR分区表。如果你的计算机使用的是传统的BIOS固件，那么它无法直接从GPT分区的硬盘启动操作系统。

相反，UEFI（Unified Extensible Firmware Interface）是一种现代的固件接口标准，它支持GPT分区格式。UEFI在启动时会读取GPT的头部信息，确定分区表的位置，然后根据分区表加载EFI系统分区（ESP），ESP包含了用于启动操作系统的EFI应用程序（如引导加载程序）。

因此，如果你的硬盘使用GPT分区，并且你希望从该硬盘启动操作系统，你需要确保你的计算机使用的是UEFI固件，而不是传统的BIOS。现代计算机通常都支持UEFI，并且默认使用UEFI模式。在UEFI模式下，计算机可以识别GPT分区格式，并从中启动操作系统。

> <font color="blue">question:</font>    "保护性MBR的分区表只包含一个条目，这个条目占据了整个硬盘"，这是什么意思？
>
> <font color="green">answer:</font>    保护性MBR（Protective MBR）是GPT（GUID Partition Table）分区方案的一部分，它位于硬盘的第一个扇区，也就是传统MBR的位置。保护性MBR的目的是为了保护GPT分区的硬盘免受不支持GPT的旧式系统和工具的干扰。
>
> 在保护性MBR中，分区表通常只包含一个条目，这个条目的类型被设置为0xEE，这是一个特殊的分区类型，用来指示整个硬盘或者一个很大的区域已经被GPT占用。这个条目并不指向实际的文件系统或数据分区，而是作为一个标记存在，告诉任何可能读取MBR的软件：“这个硬盘使用的是GPT分区方案，你不应该试图用MBR的方式来管理它。”
>
> 这个条目通常会从硬盘的第一个可用扇区开始，直到硬盘的最后一个扇区，覆盖整个硬盘的范围。这样做的目的是为了防止不支持GPT的系统和工具错误地认为硬盘未分区，并试图在硬盘上创建新的MBR分区，这可能会导致数据丢失。
>
> 因此，保护性MBR是一种兼容性措施，确保了GPT分区的硬盘在旧系统中不会被误操作，同时允许支持GPT的系统正确识别和使用硬盘。真正的GPT分区信息存储在硬盘的其他位置，通常是从第二个扇区开始的GPT头部，紧接着是分区表本身。
>
> 
>
> <font color="blue">question:</font>    也就是说，假设我在旧式的BIOS上读取了一块硬盘，而这块硬盘采取的是GPT格式的分区方式。BIOS会尝试读取扇区0，然后读取到0xEE，它会认为这不是一个激活分区。因此它会跳过这个硬盘尝试去别的硬件上寻找系统。
>
> <font color="green">answer:</font>    是的，您的理解基本正确。在旧式的BIOS系统中，当BIOS尝试读取采用GPT格式分区的硬盘时，它会首先检查扇区0，也就是MBR所在的位置。在这种情况下，它会发现保护性MBR，其中包含一个类型为0xEE的分区条目，这个条目覆盖整个硬盘。
>
> BIOS会识别到这个特殊的分区类型，但由于BIOS不支持GPT，它不会理解这个分区条目的真实含义。BIOS可能会认为这个硬盘不包含任何有效的可启动分区，因为0xEE类型的分区不是一个可启动的分区类型。因此，BIOS不会从这个硬盘启动操作系统，而是会继续搜索其他可能包含有效MBR和可启动分区的硬盘或启动设备。
>
> 这就是保护性MBR的作用：它防止了BIOS基于错误的假设（即硬盘使用MBR分区表）对硬盘进行操作，同时也向BIOS表明这个硬盘使用了一种它不理解的分区方案。这样可以减少数据损坏的风险，并确保只有支持GPT的系统（如UEFI固件）才能管理和启动这个硬盘上的操作系统。

#### 第三阶段： 硬盘启动

到了这个时期，计算机的控制权就要转交给硬盘的某个分区了，这里又分成三种情况。

##### **情况1：卷引导记录**

上一节提到，四个主分区里面，只有一个是激活的。计算机会读取激活分区的第一个扇区，叫做"卷引导记录"（Volume boot record，缩写为VBR）。

"卷引导记录"的主要作用是，告诉计算机，操作系统在这个分区里的位置。然后，计算机就会加载操作系统了。

##### **情况2：扩展分区和逻辑分区**

随着硬盘越来越大，四个主分区已经不够了，需要更多的分区。但是，分区表只有四项，因此规定有且仅有一个区可以被定义成"扩展分区"（Extended partition）。

所谓"扩展分区"，就是指这个区里面又分成多个区。这种分区里面的分区，就叫做"逻辑分区"（logical partition）。

计算机先读取扩展分区的第一个扇区，叫做"扩展引导记录"（Extended boot record，缩写为EBR）。它里面也包含一张64字节的分区表，但是最多只有两项（也就是两个逻辑分区）。

计算机接着读取第二个逻辑分区的第一个扇区，再从里面的分区表中找到第三个逻辑分区的位置，以此类推，直到某个逻辑分区的分区表只包含它自身为止（即只有一个分区项）。因此，扩展分区可以包含无数个逻辑分区。

但是，似乎很少通过这种方式启动操作系统。如果操作系统确实安装在扩展分区，一般采用下一种方式启动。

##### **情况3：启动管理器**

在这种情况下，计算机读取"主引导记录"前面446字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的"启动管理器"（boot loader），由用户选择启动哪一个操作系统。

#### 第四阶段：操作系统

控制权转交给操作系统后，操作系统的内核首先被载入内存。

以Linux系统为例，先载入/boot目录下面的kernel。内核加载成功后，第一个运行的程序是/sbin/init。它根据配置文件（Debian系统是/etc/initab）产生init进程。这是Linux启动后的第一个进程，pid进程编号为1，其他进程都是它的后代。

然后，init线程加载系统的各个模块，比如窗口程序和网络程序，直至执行/bin/login程序，跳出登录界面，等待用户输入用户名和密码。

**至此，全部启动过程完成。**

<font color="red">总结上述内容，一个计算机的启动过程大致描述为：首先，在cpu通电后，它会初始化一些自身包含的寄存器以及主板上的一些ROM，这些内容共同构成了BIOS（基本输入输出系统）。然后，BIOS会进行硬件自检，检查必要的硬件设备（内存、显卡）是否正常工作，计算机是否满足基本的运行条件。<br><br>然后，BIOS中保存了一个"启动顺序"，它按照启动顺序从外部硬件设备中尝试读入操作系统内核。例如，启动顺序第一位的是硬盘，BIOS会尝试读取硬盘的第一个扇区（扇区0），检查其是否以`0x55`、`0xAA`结尾（判断它是不是主引导记录。注意，这是MBR格式分区的硬盘的读取方式。新的GPT分区格式读取又有区别）。<br><br>在它找到主引导记录后，BIOS又需要读主引导记录中保存的分区表的信息，确定哪个主分区是以`0x80`为第一个字节，这个分区称为激活分区。计算机的控制权转交给这个分区。<br><br>随后，又要根据不同的情况（卷引导记录、扩展分区和逻辑分区、启动管理器等）选择不同的启动方式。<br><br>最后，成功找到了操作系统在外部存储设备中的位置。首先加载操作系统内核，随后启动进程以及各个模块。整个操作系统至此就成功启动了。</font>

> 上述描述对操作系统启动流程的概述是正确的，但可以进一步细化和补充一些细节：
>
> 1. **CPU复位和自检**：在通电后，CPU会执行一个复位操作，这通常涉及到读取内存地址0xFFFFFFF0处的内容，这是因为在x86架构中，这个地址映射到BIOS的起始位置。CPU从这个位置开始执行指令，进入BIOS。
>
> 2. **BIOS初始化**：BIOS会进行POST（Power-On Self Test，加电自检），检查系统硬件配置，如CPU、内存、键盘、驱动器等，并可能显示一些基本的系统信息。
>
> 3. **启动设备检测**：BIOS会根据预设的启动顺序检查各个启动设备，如硬盘、光驱、USB设备等。
>
> 4. **MBR或GPT读取**：对于MBR（Master Boot Record）格式的硬盘，BIOS会读取硬盘的第一个扇区，检查`0x55`和`0xAA`这两个字节来确认MBR的有效性。对于GPT（GUID Partition Table）格式的硬盘，启动流程稍有不同，BIOS或UEFI（Unified Extensible Firmware Interface，统一的可扩展固件接口）会读取EFI系统分区来加载操作系统。
>
> 5. **引导加载器**：在MBR中，BIOS会加载并执行主引导记录中的代码，这通常会引导到一个引导加载器，如GRUB或Windows Boot Manager。对于GPT分区表，UEFI会加载EFI系统分区中的EFI应用程序（如引导加载器）。
>
> 6. **操作系统加载**：引导加载器会加载操作系统内核到内存中，并将控制权交给操作系统。操作系统接管后，会继续加载系统驱动和服务，最终进入用户界面。
>
> 补充说明：
>
> - 在现代计算机中，BIOS已经逐渐被UEFI所取代，UEFI提供了更加丰富的界面和功能，支持更大的硬盘以及更快的启动速度。
> - 在UEFI模式下，通常使用GPT分区表，而在传统的BIOS模式下，使用MBR分区表。
> - 在某些系统中，还可能有一个快速启动的功能，这通常是通过将系统状态保存到一个文件中，在下一次启动时直接读取该文件来实现快速启动的。
>
> 这些补充信息提供了更全面的视角来理解计算机启动的过程。

#### 额外知识：cpu的代码段寄存器和当前指令指针

根据俗成的约定，在cpu完成初始化加载后。它的代码段寄存器（CS）和当前指令指针（IP，32位称EIP，64位称RIP）指向预设的物理地址。

根据传统的BIOS启动流程，当cpu复位时，CS寄存器为`0xffff`，IP寄存器为`0x00`。这个组合会将cpu的执行指向物理内存地址`0xFFFF0`（CS寄存器的值乘以16加上IP寄存器的值，即`0xFFFF0 = 0XFFFF * 16 + 0X0000`）.

这个地址位于系统的ROM BIOS中，紧靠1MB地址空间的顶端（在一个1MB的地址空间中，最高的16字节）。这里通常存放的是BIOS启动代码的跳转指令，它会将CPU的控制权转移到BIOS的主体部分，开始执行系统的自检和初始化过程。

这样设计的原因是为了确保计算机在启动时能够找到一个固定的位置开始执行代码，因为在计算机启动时内存中还没有加载操作系统或其他程序。通过将控制权交给BIOS，计算机可以进行硬件初始化和引导过程，最终加载操作系统。

在UEFI（统一可扩展固件接口）系统中，启动过程有所不同，但基本原理相似：UEFI固件存储在主板上的一个芯片中，计算机启动时会执行该固件中的代码来初始化硬件并引导操作系统。

> 我还有一些疑问，为什么"这个组合会将cpu的执行指向物理内存地址`0xFFFF0`（CS寄存器的值乘以16加上IP寄存器的值，即`0xFFFF0 = 0XFFFF * 16 + 0X0000`）"为什么要将CS寄存器的值乘以16再相加？
> 还有一个问题是，它指向了1MB地址空间的顶端，这个1MB地址空间是做什么用的？指令的执行是自顶向下的吗？
>
> 
>
> 您的问题涉及到x86架构的实模式内存寻址方式，以及BIOS在系统启动时的内存布局。我来逐一解答：
>
> ### 为什么要将CS寄存器的值乘以16再相加？
>
> 在x86架构的实模式下，物理地址是通过段地址和偏移地址组合而成的。段地址（存储在段寄存器中）需要乘以16（或左移4位）来得到基础地址，然后加上偏移地址（存储在指令指针寄存器中）来得到最终的物理地址。这种寻址方式称为段:偏移寻址。
>
> 这样设计的初衷是为了在16位处理器上扩展内存寻址能力。在16位处理器中，一个寄存器只能存储16位的值，最大只能直接寻址64KB的内存。通过将16位的段地址乘以16，再加上16位的偏移地址，可以寻址高达1MB的内存空间（2^20字节）。
>
> 所以，当CS寄存器为0xFFFF时，乘以16（或左移4位）得到的基础地址是0xFFFF0。加上IP寄存器的值0x0000，得到的物理地址仍然是0xFFFF0。
>
> ### 这个1MB地址空间是做什么用的？
>
> 在实模式下，CPU可以寻址的最大内存空间是1MB。这个1MB的内存空间不仅包括RAM，还包括了其他类型的内存，如BIOS ROM、视频内存、以及其他I/O设备的内存映射区域。这个空间的布局大致如下：
>
> - 0x00000 - 0x9FFFF：常规RAM（640KB）
> - 0xA0000 - 0xBFFFF：视频内存区域
> - 0xC0000 - 0xFFFFF：系统BIOS和其他固件（包括视频BIOS、网络卡BIOS等）
>
> 在这1MB的空间中，顶端的区域（通常是0xF0000 - 0xFFFFF）被保留给系统BIOS使用。这是因为在早期的PC设计中，BIOS需要在一个固定的位置，以便CPU在启动时可以找到并执行它的代码。
>
> ### 指令的执行是自顶向下的吗？
>
> 指令的执行顺序并不是由物理地址的高低决定的，而是由程序的控制流决定的。CPU从BIOS固件的预设入口点（0xFFFF0）开始执行指令，然后按照指令本身的逻辑顺序执行。这些指令可能会跳转到BIOS中的其他部分，或者在执行完必要的初始化后，跳转到引导扇区的代码，最终引导操作系统的加载。
>
> 
>
> 
>
> 那么也就是说，代码段寄存器和当前指令指针初始化时得到的并不是物理地址。而是段地址加偏移地址，因此需要计算将其还原为物理地址。第二个问题我的理解是，现代工业厂家设计的内存条大多都符合了这个约定，预留了1MB的地址空间（实际上这个空间中并不一定有数据，只是把地址预留出来）。这些地址指向了一些外部的硬件设备，cpu直接执行它们的代码并跳转或将控制权移交。第三个问题我的理解是，虽然0xffff0是第一条指令所在的地址。但是这条指令的作用可能是将cpu控制权移交给bios，接下来去什么地址读取执行命令由bios决定。
> 我的理解对吗？
>
> 
>
>
> 您的理解基本上是正确的，但让我稍微澄清一下：
>
> ### 关于物理地址和段:偏移地址
>
> 在x86实模式下，物理地址确实是由段地址和偏移地址组合而成的。CPU在启动时，代码段寄存器（CS）和指令指针（IP）提供了一个初始的段:偏移组合，这需要转换成物理地址才能访问内存。这个转换是通过将段地址乘以16（或左移4位），然后加上偏移地址来完成的。因此，物理地址是由这个计算得到的，而不是直接由CS和IP的值决定的。
>
> ### 关于1MB地址空间的预留
>
> 在早期的PC设计中，1MB地址空间的布局是由工业标准决定的，确实预留了一部分空间给系统BIOS和其他固件。这个空间中的一些区域可能没有物理RAM对应，但它们被映射到了其他类型的存储器或设备。例如，BIOS固件存储在主板上的非易失性存储器中，而不是在RAM内存条中。因此，当CPU访问这些特定的地址时，它实际上是在读取或写入这些设备的存储器，而不是RAM。
>
> ### 关于BIOS的控制权
>
> 当CPU在启动时执行位于物理地址0xFFFF0的指令时，这通常是一个跳转指令，它会将CPU的控制权转移到BIOS固件中的其他位置，开始执行BIOS的初始化代码。BIOS代码负责进行硬件检测、初始化，并最终找到启动设备（如硬盘）上的引导扇区，从而加载引导代码并最终引导操作系统。因此，BIOS决定了在完成自身初始化后，CPU应该去哪个地址继续执行指令。
>
> 您对这些概念的理解是正确的。这些细节对于理解计算机如何从零开始启动到加载操作系统是非常重要的。

### 2.2 中断、异常和系统调用

#### 2.2.1 背景

当操作系统内核被加载到内存中，cpu控制权移交给操作系统内核后，用户和硬件设备之间的交互就由操作系统全权负责了。

这也意味着**操作系统内核是受到硬件设备信任的第三方**，只有内核可以执行特权指令（比如Win中的Admin，Linux中的root、sudo）。

CPU执行操作系统代码时，CPU处于内核态（又称管态），2.2介绍的三种机制都是在内核态下运行的。

但是既然我们需要和硬件设备打交道（比如我们要从磁盘读写文件），那么不可避免的就需要让应用程序**（用户态）**和内核**（内核态）**打交道。这也就意味着应用程序需要通过内核来与硬件交互，内核在保证安全的同时应该向应用程序提供这些系统服务。

与此同时，提供系统服务可能带来错误的行为。比如，应用程序访问了一个不存在的文件，或者访问了一个以其权限来说不够的文件。操作系统也需要对这些事情做出反应。

此外，硬件设备可能也需要一些服务。比如键盘输入，这也需要通过内核来进行响应。

上述内容就是我们这部分要介绍的内容，即：

- 中断：处理外设回调类的事件，比如键盘按键等。
- 异常：在应用程序出现问题时处理意外情况，保证内核安全。
- 系统调用：应用程序正常使用系统服务，比如发出读文件指令，实际上会调用磁盘I/O的系统调用。

#### 2.2.2 定义

上述内容正规的定义如下：

- **系统调用**（system call）：应用程序**主动**向操作系统发出的服务请求
- **异常**（exception）：非法指令或者其他原因导致当前**指令执行失败**
- **中断**（hardware interrupt）：来自硬件**外设**的处理请求

![img](.\images\中断、异常和系统调用关系图.png)

这里详细解释一下这三个定义具体的流程：

- 中断：首先，外部设备在需要处理时（例如键盘被按下按键）向操作系统内核发出一个中断请求，内核会将该中断请求加入到中断向量表等待处理。随后，内核处理该中断时，发现它是一个来自某外部源的中断请求。因此交由中断服务例程，中断服务例程要求相应的设备驱动程序与外部设备进行交互，进而完成外部设备要做的事。在处理中断后，控制权返回给操作系统，操作系统继续执行之前的任务。

> 您对中断的基本理解是正确的。中断是计算机硬件和操作系统之间的一种重要通信机制。当硬件设备需要CPU的注意时，它会发送一个中断信号。这里是一个简化的中断处理流程：
>
> 1. **中断请求（IRQ）**：当外部设备（如键盘、鼠标或网络适配器）需要处理时，它会向CPU发送一个中断请求。
>
> 2. **中断向量表**：CPU接收到中断请求后，会根据中断向量表（一个包含中断服务例程地址的表）确定如何处理该中断。
>
> 3. **中断服务例程（ISR）**：CPU将控制权交给对应的中断服务例程，这是一个预先定义好的函数，用于处理特定的中断类型。
>
> 4. **设备驱动程序**：中断服务例程通常会与相应的设备驱动程序交互，设备驱动程序负责管理与硬件设备的直接通信。
>
> 5. **处理和响应**：设备驱动程序处理来自硬件的数据或请求，并采取相应的行动，比如读取键盘输入或接收网络数据包。
>
> 6. **中断返回**：一旦中断被处理，控制权返回给操作系统，操作系统继续执行之前的任务。
>
> 这个过程确保了CPU可以高效地响应多个设备的请求，而不需要轮询每个设备以查看是否有需要处理的事件。这种机制使得操作系统能够同时处理多任务，提高了计算机的效率和响应速度。
>
> 
>
> 我有一点不明白的是，假如我的应用程序中有一个输入框。此时我按下键盘输入，按照中断的理解，我的键盘输入被读到了设备驱动程序中，设备驱动程序是怎么把我输入的内容发送给输入框的？还是说由于输入焦点的存在，所有键盘输入都会被发送到这个输入焦点的位置。
> 
>
>
> 您的理解是正确的，输入焦点在这里起到了关键作用。当您在应用程序中的输入框中键入时，操作系统和应用程序的事件处理机制会确保您的按键输入被正确地传递到具有输入焦点的控件。以下是详细的步骤：
>
> 1. **按键中断**：当您按下键盘上的键时，键盘硬件生成一个中断信号发送给CPU。
>
> 2. **中断处理**：操作系统的内核接收到中断信号，并将控制权交给键盘的中断服务例程。
>
> 3. **设备驱动程序**：中断服务例程通知键盘设备驱动程序处理按键事件。
>
> 4. **操作系统事件队列**：设备驱动程序将按键事件转换为操作系统理解的事件，并将其放入操作系统的事件队列中。
>
> 5. **消息传递**：操作系统的窗口管理器或事件处理系统会从事件队列中取出事件，并根据当前的输入焦点将事件传递给相应的应用程序。
>
> 6. **应用程序事件处理**：应用程序接收到事件后，会在其事件循环中处理该事件。如果输入焦点在输入框上，应用程序会将按键事件转换为字符输入，并显示在输入框中。
>
> 7. **输入框更新**：输入框接收到字符后，会更新其内容，并在界面上显示新输入的字符。
>
> 这个过程涉及到操作系统的多个层面，包括硬件中断处理、设备驱动程序、操作系统的事件处理机制、以及应用程序的事件循环。输入焦点确保了只有当前用户正在交互的控件会接收到键盘输入，这样用户就可以预期输入会出现在他们期望的位置。

- 异常：异常通常是来自应用程序的，当应用程序代码做出了某件错误的事（例如，做出了除零操作、访问了不存在的文件等）。由于我们编写的应用程序代码**在系统底层实际上是一条条的指令**，这就意味着某条指令执行失败了。此时中断向量表中也会接收到该异常请求，中断向量表识别到它是一个异常后将其发送给异常服务例程。异常服务例程可能会解决这个问题，也可能终止应用程序的执行，在最坏的情况下会导致内核出错。

> 您对异常的理解基本上是正确的，但有一些细节可以进一步澄清。异常和中断都是中央处理器（CPU）的响应机制，但它们的来源和目的不同。中断通常是由外部事件（如硬件设备的信号）触发的，而异常通常是由CPU执行指令过程中遇到的问题触发的。
>
> 以下是异常处理的一般流程：
>
> 1. **异常发生**：当CPU在执行应用程序代码时遇到问题（如除零操作、无效内存访问、指令执行错误等），它会产生一个异常。
>
> 2. **异常分类**：异常可以分为同步异常和异步异常。同步异常是由当前执行的指令直接引起的，例如除零或访问违规。异步异常可能由于外部事件引起，与当前执行的指令不直接相关，例如硬件故障。
>
> 3. **中断向量表**：CPU使用一个内部的中断向量表（或异常向量表）来决定如何处理异常。每种类型的异常都有一个对应的入口，称为异常处理程序或异常服务例程。
>
> 4. **异常处理程序**：CPU将控制权转交给对应的异常处理程序。这个处理程序是操作系统预先定义好的，用于处理特定类型的异常。
>
> 5. **处理或终止**：异常处理程序会尝试修复问题，例如通过提供默认值或清理资源。如果问题无法修复，它可能会决定终止引起异常的应用程序。
>
> 6. **用户通知**：在某些情况下，操作系统可能会向用户报告异常，例如通过错误消息或日志条目。
>
> 7. **恢复或终止**：如果异常被处理并且系统能够从异常中恢复，程序可能会继续执行。如果异常无法处理，应用程序可能会被终止，严重的异常（如内核级异常）可能会导致系统崩溃。
>
> 异常处理是操作系统稳定性和安全性的关键组成部分，它确保了单个应用程序的错误不会影响整个系统的稳定性。

- 系统调用：应用程序主动向内核发出的服务请求，实际上应用程序通过函数库中的函数调用来间接的进行系统调用。比如应用程序调用`open()`函数进行一个读写文件的操作，底层实际上进行了磁盘IO的系统调用。应用程序发出的系统调用同样会发送到对应的系统调用表，系统调用表会查找对应的系统调用操作，完成相应的操作并将结果返回给系统调用处。

> 您对系统调用的理解是正确的。系统调用是应用程序与操作系统内核之间的接口，它允许应用程序请求操作系统提供的服务，例如文件操作、进程控制、网络通信等。这里是系统调用的一般过程：
>
> 1. **函数库调用**：应用程序通过调用标准库中的函数（如C语言中的`open()`）来发起一个系统调用。这些库函数为应用程序提供了一个简化和统一的接口来执行复杂的系统调用。
>
> 2. **触发系统调用**：库函数内部会设置必要的参数，并使用特定的机制（如软件中断或特殊的CPU指令）来通知操作系统需要服务。
>
> 3. **上下文切换**：当系统调用被触发时，CPU从用户模式切换到内核模式，因为系统调用需要操作系统内核的权限来访问硬件和管理资源。
>
> 4. **系统调用表**：操作系统内核使用一个系统调用表来确定如何处理来自应用程序的请求。每个系统调用在这个表中都有一个唯一的编号和对应的内核函数。
>
> 5. **执行系统调用**：内核查找系统调用表，找到对应的内核服务例程，并执行相应的操作。
>
> 6. **返回结果**：操作完成后，结果会被返回给应用程序。如果是读写文件操作，例如`open()`，内核会处理文件的打开，并返回一个文件描述符给应用程序。
>
> 7. **恢复用户模式**：系统调用完成后，CPU从内核模式切换回用户模式，控制权返回给应用程序。
>
> 系统调用是一种受控的机制，它确保了用户程序不能直接执行可能会破坏系统稳定性或安全性的操作。通过系统调用，操作系统能够提供必要的隔离和控制，同时还能提供对硬件资源的抽象，使得应用程序编写更为简单和可移植。

#### 2.2.3 三种机制对比

**从源头上来说：**

- 中断：来自外设
- 异常：来自应用程序意想不到的行为
- 系统调用：来自应用程序主动请求

**从响应方式来说：**

- **中断**：**中断是异步的**，当外部设备发出一个中断请求时。操作系统可能正在处理其他任务（比如正在执行某应用程序），应用程序是感受不到中断的存在的。操作系统可能会在应用程序暂停（比如时间片耗尽）时再来处理中断请求，完成中断请求相应操作后再继续执行应用程序或其他操作。

  <font color="red">**上述对中断的理解不够准确。**</font>

  > 您的说法基本准确，但需要一点澄清。中断确实是异步的，它们可以在任何时候发生，通常是由外部设备触发的。但是，中断处理通常具有很高的优先级，因为它们往往对应着需要立即处理的硬件事件。
  >
  > 当中断发生时，以下是处理流程的概述：
  >
  > 1. **中断请求**：外部设备发出中断请求到CPU。
  >
  > 2. **当前指令完成**：CPU通常会完成当前执行的指令之后，再响应中断请求。
  >
  > 3. **上下文保存**：在响应中断之前，CPU会保存当前任务的状态，这通常包括寄存器和程序计数器的值，以便中断处理完成后能够恢复到当前任务。
  >
  > 4. **中断处理**：CPU根据中断向量表跳转到相应的中断服务例程（ISR）进行处理。
  >
  > 5. **上下文恢复**：中断处理完成后，CPU会恢复之前保存的任务状态，继续执行被中断的任务。
  >
  > 在多任务操作系统中，中断处理通常是优先于当前运行的应用程序的。这意味着，如果一个中断发生了，操作系统会立即暂停当前的应用程序（即使它的时间片尚未耗尽），保存其状态，处理中断，然后再恢复应用程序的执行。这个过程对于应用程序来说是透明的，应用程序通常感知不到中断的发生和处理。
  >
  > 然而，操作系统设计者可能会在中断处理策略中引入一些灵活性。例如，在某些情况下，操作系统可能会延迟处理非关键的中断，直到当前任务达到一个安全的中断点。这种设计可以减少上下文切换的开销，但是在大多数情况下，中断处理是尽可能快地执行以确保系统的响应性。

- **异常**：**异常是同步的**，当应用程序代码出现问题，导致执行了一个错误的指令时。操作系统会接收到异常请求，然后应用程序就在那等待操作系统的响应了。如果操作系统能够处理该异常，且应用程序可以从错误的状态恢复过来，那么就能够继续执行应用程序。否则，操作系统将回收应用程序占用的资源并关闭应用程序。

  > 您对异常的理解基本上是准确的。异常确实是同步发生的，它们是由CPU执行指令时检测到的问题触发的。这些问题可能包括除以零、访问无效的内存地址、执行非法指令等。以下是异常处理的一般流程：
  >
  > 1. **异常发生**：当CPU在执行应用程序时遇到一个问题，它会产生一个异常。
  >
  > 2. **异常分类**：异常通常是同步的，它们可以是由于程序错误（如除零、越界访问、非法指令等）引起的，也可以是由于程序执行的操作需要进一步的操作系统介入才能完成（如页面错误）。
  >
  > 3. **上下文保存**：操作系统接收到异常后，会保存当前任务的状态，这样就可以在处理完异常后恢复任务的执行。
  >
  > 4. **异常处理程序**：CPU使用异常向量表来确定如何处理异常，并跳转到对应的异常处理程序。
  >
  > 5. **决定命运**：异常处理程序会尝试修复问题，如果可以修复并且应用程序可以从错误状态恢复，则处理程序会结束异常处理，恢复应用程序的执行。如果问题无法修复，操作系统可能会决定终止应用程序。
  >
  > 6. **资源回收**：如果应用程序被终止，操作系统会回收它占用的资源，如内存、文件句柄等。
  >
  > 7. **用户通知**：在某些情况下，操作系统可能会向用户报告异常，例如通过错误消息。
  >
  > 8. **恢复或终止**：如果异常被处理并且系统能够从异常中恢复，程序可能会继续执行。如果异常无法处理，应用程序可能会被终止。
  >
  > 异常处理是操作系统的一个重要功能，它确保了单个应用程序的错误不会影响整个系统的稳定性，并且提供了一种机制来安全地处理程序运行时的错误。

- **系统调用**：系统调用可能是同步的，也可能是异步的。例如，应用程序对文件进行了读写操作，这将导致磁盘IO的系统调用产生。然而，由于应用程序可能需要在读写完成后才能进行下一步操作（比如上传文件到网络），因此应用程序就不得不等待系统调用完成，内容被完全写入到文件后才能继续下一步操作。
  相应的，如果应用程序读写文件后就不再使用该文件了。那么系统调用与应用程序之间可能是异步的，应用程序可能继续执行去处理别的任务，发送下一个系统调用给操作系统，即便当前的磁盘IO系统调用还未完成。

  > 您对系统调用的理解是基本准确的，但需要一些澄清。系统调用本身是同步的，但它们可以被用于启动异步操作。
  >
  > 当一个应用程序执行系统调用，如文件读写操作时，这通常是一个同步操作。这意味着系统调用会导致应用程序等待操作系统完成请求的服务。在文件IO的例子中，应用程序会发出读或写的系统调用，并且在该操作完成之前，应用程序的执行通常会被阻塞。这确保了在文件内容被完全读取或写入之后，应用程序才继续执行。
  >
  > 然而，操作系统也提供了异步IO的机制。在异步IO模型中，应用程序可以发起一个读写操作，并且无需等待该操作完成就可以继续执行其他任务。在这种情况下，应用程序会在之后的某个时间点收到一个通知，告知它IO操作已经完成。这样，应用程序就可以在等待磁盘IO的同时执行其他工作，从而提高效率。
  >
  > 总结来说：
  >
  > - **同步系统调用**：应用程序在系统调用完成之前会被阻塞。应用程序必须等待操作系统完成服务才能继续执行。
  >
  > - **异步系统调用**：应用程序发起系统调用后可以继续执行其他任务，不需要等待系统调用完成。操作系统会在后台处理系统调用，并在完成后通知应用程序。
  >
  > 在现代操作系统中，两种模型都是可用的，具体使用哪一种取决于应用程序的需求和设计。

**从处理机制上来说：**

- **中断：**中断对应用程序来说是透明的，因此中断处理时，应用程序是**持续运行**的。
- **异常：**异常是应用程序发出意想不到的指令（或者导致错误的指令）时发生的，因此应用程序只能暂停等待异常处理完成，导致资源回收或重新执行发生错误的指令。
- **系统调用：**系统调用本身是同步或者异步的，因此从处理机制上来说应用程序可能是被阻塞等待的，也可能是持续运行别的任务的。

#### 2.2.4 中断（这里的中断是中断、异常、系统调用统称）

要想识别中断请求，cpu必须进行一些初始化。这就是CPU的硬件处理：**在CPU初始化时设置中断使能标志。**

- 依据内部或外部事件设置中断标志（比如键盘就对应着一个阵列通断对应的高低电平）
- 依据中断向量调用相应中断服务例程（相当于是一个回调机制）

**中断发生时，软件也需要进行一些处理：**

- **现场保存**：中断发生时，我们需要知道应用程序的上下文，保存应用程序当前的状态。
- **中断服务处理**：保存完状态后，我们从中断向量表中得到这个中断的类型（中断、异常还是系统调用），然后交给对应的服务例程进行处理。
- **清除中断标记**：交给对应服务例程进行处理后，这个中断标记就不再被需要了（它已经或者正在被处理了），服务例程也负责清除中断标记。
- **现场恢复**：恢复应用程序的上下文。

<font color="red">还有一个问题是，当操作系统正在处理某个请求时，又出现了一个请求怎么办？</font>

比如我通过键盘输入，向操作系统发出了键盘源中断请求。此时我同时移动鼠标，相当于让鼠标源发送了一个中断请求。

那么我们需要知道的就是：

- **硬件中断服务例程可以被打断：**也就是说，当我们键盘输入同时移动鼠标时，可能发生的情况就是，键盘源的中断请求发送给了中断服务例程，中断服务例程调用了键盘设备驱动程序，键盘设备驱动程序从键盘中读取输入。此时鼠标源中断请求发送给了操作系统，操作系统**可能**会将键盘设备驱动程序暂停，执行该中断并交给中断服务例程调用鼠标设备驱动程序，等待鼠标设备驱动程序完成任务后继续之前的键盘设备驱动程序的任务。但是由于这个过程实在是太快了，所以我们人是感觉不到的。

  > 这段描述基本上是准确的，但需要一些澄清和补充。
  >
  > 在现代操作系统中，硬件中断服务例程（ISR）确实可以被其他更高优先级的中断打断，这个过程被称为中断嵌套。当一个中断发生时，CPU会暂停当前正在执行的任务，保存其状态，并跳转到相应的中断服务例程来处理中断。如果在处理一个中断的时候，另一个更高优先级的中断到来，CPU会再次暂停当前的中断处理，保存状态，并处理新的中断。
  >
  > 在你的例子中，当键盘和鼠标几乎同时产生中断请求时，操作系统的中断控制器会根据优先级来决定处理顺序。如果鼠标中断的优先级高于键盘中断，那么操作系统确实会先处理鼠标中断。一旦鼠标中断处理完毕，操作系统会恢复处理键盘中断。
  >
  > 这个过程通常是非常快速的，以至于用户几乎感觉不到延迟。但是，这也取决于中断服务例程的效率和复杂性，以及系统的整体负载。如果中断服务例程非常简短并且高效，那么即使在高负载下，用户也不太可能感觉到明显的延迟。
  >
  > 需要注意的是，现代操作系统通常使用了多种机制来优化中断处理，例如中断共享、中断线程化、以及对于多核处理器的中断亲和性分配等，这些都有助于提高系统在处理多个硬件中断时的效率和响应性。

- **硬件中断服务例程中可能临时禁止中断请求**：这和中断的优先级有一定的关系，当我们正在处理一个较高优先级的中断（例如，电源设备发出了一个中断请求），而此时我们通过键盘输入（键盘设备发出中断请求）。那么操作系统可能认为电源设备是一个更高优先级的，我们必须马上处理电源设备的问题。那么在处理电源中断时，就会临时禁止中断请求以免处理过程被打断。

  > 这个描述是基本准确的。在中断服务例程（ISR）执行期间，确实可能会临时禁用其他中断，这通常是为了防止当前正在处理的中断被其他中断打断，尤其是在处理一些需要快速响应的高优先级中断时。
  >
  > 这种机制通常被称为“禁止中断”（Disable Interrupts）或“屏蔽中断”（Mask Interrupts）。在处理关键的中断服务例程时，操作系统或中断控制器可能会暂时屏蔽掉其他低优先级的中断，直到关键的中断处理完成。这样做的目的是确保中断处理的原子性和一致性，避免数据竞争和状态不一致的问题。
  >
  > 例如，如果电源设备发出了一个中断请求，这通常意味着需要立即采取行动（比如电池电量低或电源故障），因此系统可能会优先处理这个中断，并在处理期间禁止其他中断，确保电源相关的处理不会被其他活动打断。
  >
  > 一旦高优先级的中断处理完成，系统会重新启用中断，允许其他中断请求被处理。这个过程是由操作系统和硬件紧密协作完成的，以确保系统的稳定性和响应性。

- **中断请求会保持到CPU做出响应：**正如上面所说的，临时禁止的中断请求并不意味着中断向量表不接收，只是暂时不处理。中断请求会保持到CPU对其做出响应。
- **异常服务例程可被打断**：
  - 异常服务例程执行时可能被硬件中断： 例如，当操作系统处理应用程序异常时，异常处理导致磁盘IO，此时会发生磁盘源的硬件中断。异常服务例程会被打断，保存状态后先执行磁盘硬件中断。
  - 异常服务例程可嵌套： 例如，当操作系统处理应用程序异常时，在处理异常的过程中再度发生了异常（假设异常处理需要访问某个存储单元，而这个存储单元又有问题）。那么就会发生异常的嵌套。

#### 2.2.5 系统调用

**背景**：应用程序一般无法直接访问硬件，也无法执行特权指令。所以，需要通过操作系统来间接完成相关的工作。而基于安全和可靠性的需求，应用程序运行在用户态，操作系统内核运行在内核态，导致应用程序无法通过函数调用来访问操作系统提供的各种服务，于是通过系统调用的方式就成了应用程序向OS发出请求并获得服务反馈的唯一通道和接口。

**定义**：

- 操作系统服务的编程接口
- 通常由高级语言编写
- 程序访问通常是通过高层次的**API接口**（函数调用），而不是直接进行系统调用。

三种最常访问的API：

- Win32 API
- POSIX API用于POSIX-based systems（类UNIX，包括Linux和MacOS X的所有版本）
- Java API用于Java虚拟机（JVM）

**实现**：

- 每个系统调用对应一个系统调用编号：来维护**系统调用表**的索引
- 调用内核态中的**系统调用功能**实现，并返回系统调用的**状态和结果**
- **黑盒性**，用户不需要知道系统调用的实现

##### 系统调用和函数调用的不同

- INT和IRET用于系统调用：堆栈切换和特权级转换
- CALL和RET用于常规调用（**不用堆栈切换**）

##### 系统调用的开销

系统调用的开销是超过函数调用的，因为有一个从用户态到内核态的切换。

> 系统调用的开销大于函数调用，这主要是因为系统调用涉及到从用户态到内核态的上下文切换，而函数调用则通常在用户态内完成。具体体现在以下几个方面：
>
> 1. **上下文切换**：系统调用需要操作系统从用户态切换到内核态，这个过程需要保存用户态的状态，并加载内核态的状态。完成系统调用后，还需要再次切换回用户态。这个上下文切换过程涉及到寄存器和内存状态的保存与恢复，是一个相对耗时的操作。
>
> 2. **安全性检查**：系统调用通常涉及到资源的管理或者敏感操作，因此每次系统调用都需要进行权限检查和安全性验证，以确保调用是合法的。这些检查是必要的，但也增加了额外的开销。
>
> 3. **指令开销**：执行系统调用通常需要特殊的指令，如x86架构中的`int`（中断）或`syscall`/`sysenter`指令，这些指令本身的执行时间就比普通的函数调用指令要长。
>
> 4. **内核态资源访问**：系统调用通常需要访问内核资源，比如文件系统、网络堆栈、设备驱动等。这些资源可能涉及到锁定机制、队列等待等同步操作，这些都可能导致延迟。
>
> 5. **数据复制**：系统调用可能涉及到用户空间和内核空间之间的数据传输。例如，读写文件时，数据需要从用户空间复制到内核缓冲区，或者相反。这种复制操作也会增加开销。
>
> 相比之下，普通的函数调用只是在用户态的程序内部跳转，不需要上下文切换，也没有安全性检查和数据复制到内核空间的需求。因此，函数调用的开销相对较小。

## lab_1

### 练习一

1. 操作系统镜像文件ucore.img是如何一步一步生成的？(需要比较详细地解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果)

   为了解释这一问题，必须贴上Makefile的代码和执行结果。

   ```makefile
   PROJ	:= challenge
   EMPTY	:=
   SPACE	:= $(EMPTY) $(EMPTY)
   SLASH	:= /
   
   V       := @
   # PROJ := challenge：这个变量用于定义一个项目名或标识符，将它设为challenge。
   
   # EMPTY :=：定义了一个空变量，即没有赋值给它。
   
   # SPACE := $(EMPTY) $(EMPTY)：这里使用了之前定义的空变量，将两个空变量拼接在一起，实际上就是定义了一个包含两个空格的变量。这种技巧在 Makefile 中有时用于创建间隔或空格。
   
   # SLASH := /：定义了一个变量SLASH，将其设为/，即斜杠符号。可能用于指示路径分隔符。
   
   # V := @：这个变量将V设为@。在 Makefile 中，@符号通常用于抑制命令的输出，即在命令前加上@，使得执行命令时不显示这个命令本身。
   
   # 这些变量的作用是在后续的规则、命令或其他部分中引用，比如使用V来执行命令时不显示命令本身，或者在某些地方需要一个空格或斜杠时可以直接引用SPACE、SLASH等变量。这些变量的定义是为了在整个 Makefile 中统一管理、方便维护和修改。
   
   # try to infer the correct GCCPREFX
   ifndef GCCPREFIX
   GCCPREFIX := $(shell if i386-elf-objdump -i 2>&1 | grep '^elf32-i386$$' >/dev/null 2>&1; \
   	then echo 'i386-elf-'; \
   	elif objdump -i 2>&1 | grep 'elf32-i386' >/dev/null 2>&1; \
   	then echo ''; \
   	else echo "***" 1>&2; \
   	echo "*** Error: Couldn't find an i386-elf version of GCC/binutils." 1>&2; \
   	echo "*** Is the directory with i386-elf-gcc in your PATH?" 1>&2; \
   	echo "*** If your i386-elf toolchain is installed with a command" 1>&2; \
   	echo "*** prefix other than 'i386-elf-', set your GCCPREFIX" 1>&2; \
   	echo "*** environment variable to that prefix and run 'make' again." 1>&2; \
   	echo "*** To turn off this error, run 'gmake GCCPREFIX= ...'." 1>&2; \
   	echo "***" 1>&2; exit 1; fi)
   endif
   # 这部分代码是一个条件判断语句，用于设置变量 GCCPREFIX。让我逐步解释它的作用：
   
   # ifndef GCCPREFIX：这是一个条件判断语句，检查变量 GCCPREFIX 是否已经被定义。如果 GCCPREFIX 没有被定义，那么执行接下来的操作。
   
   # GCCPREFIX := $(shell ...)：这是一个赋值操作，使用 shell 函数执行一系列命令。它的作用是尝试推断出合适的 GCCPREFIX。具体的操作如下：
   
   # 首先，它尝试执行 i386-elf-objdump -i 命令，并检查输出是否包含 elf32-i386。如果找到了，它将 GCCPREFIX 设置为 'i386-elf-'。
   
   # 如果上面的尝试失败了，它接着尝试执行 objdump -i 命令，并检查输出是否包含 elf32-i386。如果找到了，它将 GCCPREFIX 设置为空字符串 ''。
   
   #如果两次尝试都失败了，它会输出一条错误信息，并提供一些可能的解决方案。最后，如果检测失败了，它会退出并返回错误码 1。
   
   # endif：结束条件判断的语句块。
   
   # 总体来说，这段代码的目的是根据当前系统环境尝试推断合适的 GCCPREFIX，以便在后续的编译过程中使用。它会检查是否存在特定的工具链，如果找到了就设置对应的 GCCPREFIX，如果找不到则给出错误提示。
   
   # try to infer the correct QEMU
   ifndef QEMU
   QEMU := $(shell if which qemu-system-i386 > /dev/null; \
   	then echo 'qemu-system-i386'; exit; \
   	elif which i386-elf-qemu > /dev/null; \
   	then echo 'i386-elf-qemu'; exit; \
   	else \
   	echo "***" 1>&2; \
   	echo "*** Error: Couldn't find a working QEMU executable." 1>&2; \
   	echo "*** Is the directory containing the qemu binary in your PATH" 1>&2; \
   	echo "***" 1>&2; exit 1; fi)
   endif
   # 和上面的内容类似，检查是否存在合适的qemu
   
   # eliminate default suffix rules
   .SUFFIXES: .c .S .h
   # 这个规则告诉 Make 不要使用默认的后缀规则来生成文件。通常，Make 会根据后缀来识别文件类型并确定如何编译它们。在这里，通过清空默认的后缀规则，用户可以自定义更灵活的规则来处理 .c、.S 和 .h 类型的文件，而不受默认规则的影响。
   
   # delete target files if there is an error (or make is interrupted)
   .DELETE_ON_ERROR:
   # 这个规则告诉 Make 在执行过程中，如果发生错误或者中断，应该删除那些正在构建的目标文件。这有助于确保在发生错误时，不会保留部分构建成功的目标文件，以免造成后续的问题。
   
   # define compiler and flags
   
   HOSTCC		:= gcc
   HOSTCFLAGS	:= -g -Wall -O2
   # 这两行定义了用于主机编译的编译器和编译选项。HOSTCC 设定为 gcc，表示使用 gcc 作为主机编译器。HOSTCFLAGS 设置了一系列编译选项，包括 -g（生成调试信息）、-Wall（显示所有警告信息）、-O2（启用优化级别2）。这些选项可以根据需要进行修改，用于在主机上编译源文件。
   
   CC		:= $(GCCPREFIX)gcc
   CFLAGS	:= -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc $(DEFS)
   CFLAGS	+= $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
   CTYPE	:= c S
   # 这几行代码定义了一些用于编译的变量，并为编译器和编译选项赋值。让我逐行解释：
   
   #1. `CC := $(GCCPREFIX)gcc`：这里定义了一个变量 `CC`，它用于存储编译器的名称。这里采用了 `GCCPREFIX` 变量作为前缀，并附加 `gcc`，表示在编译时使用特定前缀的 `gcc` 编译器。
   
   # 2. `CFLAGS := -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc $(DEFS)`：这个变量定义了编译时的一系列选项。解释如下：
   #   - `-fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc` 是一些编译选项：
   #     - `-fno-builtin`：禁用内建函数。
   #     - `-fno-PIC`：禁用位置无关代码（Position Independent Code）。
   #     - `-Wall`：启用大部分警告信息。
   #     - `-ggdb`：生成适用于 `gdb` 调试器的调试信息。
   #     - `-m32`：生成 32 位代码。
   #     - `-gstabs`：使用 `stabs` 格式的调试信息。
   #     - `-nostdinc`：不要搜索标准系统头文件目录。
   #   - `$(DEFS)` 是一个变量，可能包含一些额外的定义或标志。
   
   #3. `CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)`：这一行做了以下事情：
   #   - 使用 `shell` 命令执行一个子命令。
   #   - 子命令中使用 `$(CC)` 编译器来处理一个空的 C 文件 `/dev/null`，并试图使用 `-fno-stack-protector` 标志进行预处理。
   #   - 如果编译成功（没有报错），则添加 `-fno-stack-protector` 标志到 `CFLAGS` 变量中。
   #   - 这一步可能是为了检查编译器是否支持 `-fno-stack-protector` 标志，如果支持，则将其添加到编译选项中。
   
   #4. `CTYPE := c S`：这里定义了一个变量 `CTYPE`，它包含了源文件的类型，可能是 `c` 和 `S`，表示 `c` 源文件和 `S` 汇编文件。
   
   # 这些代码段定义了编译过程中使用的编译器、编译选项和源文件类型，确保了在构建过程中使用了特定的设置。
   
   LD      := $(GCCPREFIX)ld
   LDFLAGS	:= -m $(shell $(LD) -V | grep elf_i386 2>/dev/null | head -n 1)
   LDFLAGS	+= -nostdlib
   # 这些代码是关于链接器的设置，让我逐行解释：
   
   # 1. `LD := $(GCCPREFIX)ld`：这里定义了一个变量 `LD`，它存储了链接器的名称。`GCCPREFIX` 是之前推断的 GCC 前缀，这里使用它作为前缀，并附加 `ld`，表示在链接过程中使用特定前缀的链接器。
   
   # 2. `LDFLAGS := -m $(shell $(LD) -V | grep elf_i386 2>/dev/null | head -n 1)`：
   #   - `-m` 标志指定链接器的选项，这里是为了确定目标平台的体系结构。
   #   - `$(shell $(LD) -V | grep elf_i386 2>/dev/null | head -n 1)` 这部分是一个子命令：
   #     - `$(LD) -V` 获取链接器的版本信息。
   #     - `grep elf_i386` 过滤出包含 `elf_i386` 字符串的行。
   #     - `2>/dev/null` 将标准错误重定向到 `/dev/null`，即忽略错误输出。
   #     - `head -n 1` 只保留匹配结果的第一行。
   #   - 最终结果是，通过版本信息确定链接器的体系结构，从而设置了 `-m` 选项，可能是为了确保链接器工作在符合 `elf_i386` 格式的环境下。
   
   # 3. `LDFLAGS += -nostdlib`：`+=` 表示将 `-nostdlib` 选项追加到链接器标志中。`-nostdlib` 标志告诉链接器不使用标准系统库。
   
   # 这些代码用于定义链接器和链接器选项，在编译过程中确保了使用了指定的链接器以及相关的链接选项。
   
   OBJCOPY := $(GCCPREFIX)objcopy
   OBJDUMP := $(GCCPREFIX)objdump
   
   COPY	:= cp
   MKDIR   := mkdir -p
   MV		:= mv
   RM		:= rm -f
   AWK		:= awk
   SED		:= sed
   SH		:= sh
   TR		:= tr
   TOUCH	:= touch -c
   
   OBJDIR	:= obj
   BINDIR	:= bin
   
   ALLOBJS	:=
   ALLDEPS	:=
   TARGETS	:=
   
   include tools/function.mk
   
   listf_cc = $(call listf,$(1),$(CTYPE))
   # listf_cc = $(call listf,$(1),$(CTYPE))：这里定义了一个变量 listf_cc，它通过 $(call listf,$(1),$(CTYPE)) 的方式调用 listf 函数。listf 函数可能是在 tools/function.mk 中定义的，作用是获取特定类型的文件列表，这里使用了 $(CTYPE) 变量指示文件类型。
   
   # for cc
   add_files_cc = $(call add_files,$(1),$(CC),$(CFLAGS) $(3),$(2),$(4))
   create_target_cc = $(call create_target,$(1),$(2),$(3),$(CC),$(CFLAGS))
   
   # for hostcc
   add_files_host = $(call add_files,$(1),$(HOSTCC),$(HOSTCFLAGS),$(2),$(3))
   create_target_host = $(call create_target,$(1),$(2),$(3),$(HOSTCC),$(HOSTCFLAGS))
   # add_files_cc 和 add_files_host 是在Makefile中定义的函数，它们用于添加文件到构建过程中，但是它们的用途和上下文有所不同。
   
   # add_files_cc: 这个函数通常用于添加项目的源代码文件，这些文件将被交叉编译器（cross-compiler）编译。交叉编译器是为了生成在不同于构建环境的目标系统上运行的代码。例如，在构建操作系统或嵌入式系统时，开发者可能在x86架构的机器上编译用于ARM架构的代码。
   
   # add_files_cc 函数会根据指定的编译器（如$(CC)），编译标志（如$(CFLAGS)），和源文件列表，生成相应的编译规则和目标文件。这些目标文件最终会被链接成最终的可执行文件或库。
   
   # add_files_host: 相比之下，add_files_host 函数用于添加需要在构建环境本身运行的工具或程序的源代码文件。这些工具不是最终产品的一部分，而是辅助构建过程的工具，比如上面提到的sign工具。
   
   # add_files_host 函数会使用主机的编译器（如$(HOSTCC)），编译标志（如$(HOSTCFLAGS)），和源文件列表，生成编译这些工具所需的规则和目标文件。这些工具在构建过程中运行，通常不会被包含在最终的产品中。
   
   # 总结来说，add_files_cc 用于添加和编译最终产品的代码，而add_files_host 用于添加和编译构建过程中使用的工具代码。两者的主要区别在于它们编译的目标环境不同：一个是为了目标系统（可能是不同的架构），另一个是为了构建环境（即主机系统）。
   
   
   cgtype = $(patsubst %.$(2),%.$(3),$(1))
   objfile = $(call toobj,$(1))
   asmfile = $(call cgtype,$(call toobj,$(1)),o,asm)
   outfile = $(call cgtype,$(call toobj,$(1)),o,out)
   symfile = $(call cgtype,$(call toobj,$(1)),o,sym)
   
   # for match pattern
   match = $(shell echo $(2) | $(AWK) '{for(i=1;i<=NF;i++){if(match("$(1)","^"$$(i)"$$")){exit 1;}}}'; echo $$?)
   # 这段代码定义了一个名为 match 的变量，它通过 shell 的 echo 命令和 awk 实现了一种模式匹配的功能。具体来说，这段代码做了以下几件事：
   
   # $(shell ...)：这是一个 makefile 中的函数，它允许执行 shell 命令并返回结果给 match 变量。
   
   # echo $(2)：将传递给它的第二个参数（$(2)）作为字符串输出。
   
   #| $(AWK) '{for(i=1;i<=NF;i++){if(match("$(1)","^"$$(i)"$$")){exit 1;}}}'：使用管道将上一步的输出传递给 awk 命令进行处理。$(AWK) 是在 Makefile 中定义的 awk 工具。
   
   # $(1) 是 awk 命令中的第一个参数，^$$(i)$$ 是一个正则表达式模式。整个 awk 命令是一个循环，遍历了 $(2) 的字段（根据空格分隔的单词），然后使用 match 函数匹配 $(1) 是否以某个字段作为开头。如果匹配成功，则 exit 1 终止循环，并返回 1。
   
   # echo $$?：这个命令会输出上一个命令的返回值。$$? 是 shell 变量，代表上一个命令执行后的返回值，也就是 awk 命令中的 exit 1 的返回值。
   
   # 综合来说，这段代码的作用是检查第一个参数（$(1)）是否与第二个参数（$(2)）中的任何一个字段匹配，并返回一个布尔值作为结果。
   
   
   # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   # include kernel/user
   
   INCLUDE	+= libs/
   
   CFLAGS	+= $(addprefix -I,$(INCLUDE))
   
   LIBDIR	+= libs
   
   # 这段代码用于配置编译器的包含路径和一些编译选项。
   
   # 1. `INCLUDE += libs/`：这里将 `libs/` 目录添加到 `INCLUDE` 变量中。`INCLUDE` 可能是一个包含了头文件路径的变量，通过 `+=` 操作符，将 `libs/` 目录添加到现有的路径列表中。
   
   # 2. `CFLAGS += $(addprefix -I,$(INCLUDE))`：这行代码是将 `-I` 标志添加到 `CFLAGS` 变量中。`-I` 标志用于指定编译器查找头文件的路径。`addprefix` 函数会在 `$(INCLUDE)` 中的每个路径前面添加 `-I`，这样就将 `INCLUDE` 中的路径都转换成了编译器可识别的头文件路径。
   
   # 3. `LIBDIR += libs`：这里将 `libs` 目录添加到 `LIBDIR` 变量中。`LIBDIR` 可能是一个包含库文件路径的变量，通过 `+=` 操作符，将 `libs` 目录添加到现有的路径列表中。
   
   # 综合来看，这段代码的目的是将 `libs/` 目录添加到编译器的头文件搜索路径中（使用 `-I` 标志），并且将 `libs` 目录添加到库文件搜索路径中（这部分在提供的代码中并没有直接使用，但是有可能在后续的编译过程中会用到）。
   
   $(call add_files_cc,$(call listf_cc,$(LIBDIR)),libs,)
   
   # -------------------------------------------------------------------
   # kernel
   
   KINCLUDE	+= kern/debug/ \
   			   kern/driver/ \
   			   kern/trap/ \
   			   kern/mm/
   # 将一系列内核代码的头文件路径添加到 KINCLUDE 变量中。
   
   KSRCDIR		+= kern/init \
   			   kern/libs \
   			   kern/debug \
   			   kern/driver \
   			   kern/trap \
   			   kern/mm
   # 将一系列内核代码的源文件目录添加到 KSRCDIR 变量中。
   
   KCFLAGS		+= $(addprefix -I,$(KINCLUDE))
   # 将 KINCLUDE 中的路径通过 -I 标志添加到 KCFLAGS 变量中，这样编译器在编译时会包含这些头文件路径。
   
   $(call add_files_cc,$(call listf_cc,$(KSRCDIR)),kernel,$(KCFLAGS))
   # 调用了 add_files_cc 函数，该函数可能是一个通用的函数，用于向编译器添加一系列源文件以及相关的编译选项。这里使用了 $(call listf_cc,$(KSRCDIR)) 获取了 KSRCDIR 中的源文件列表，然后使用 $(KCFLAGS) 作为编译选项传递给 add_files_cc 函数，最终把这些源文件编译成了一个名为 kernel 的目标。
   
   KOBJS	= $(call read_packet,kernel libs)
   # 这里可能是定义了一个变量 KOBJS，用于存储编译后的目标文件，它通过 read_packet 函数将 kernel 和 libs 作为参数，可能会处理这些目标文件。
   
   # create kernel target
   kernel = $(call totarget,kernel)
   # 定义了一个名为 kernel 的变量，通过 totarget 函数可能会返回一个特定的目标文件名，这里是 kernel。
   
   $(kernel): tools/kernel.ld
   # 这是一个生成 kernel 目标文件的规则。表示 kernel 依赖于 tools/kernel.ld 文件。
   
   $(kernel): $(KOBJS)
   	@echo + ld $@
   	$(V)$(LD) $(LDFLAGS) -T tools/kernel.ld -o $@ $(KOBJS)
   	@$(OBJDUMP) -S $@ > $(call asmfile,kernel)
   	@$(OBJDUMP) -t $@ | $(SED) '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $(call symfile,kernel)
   # 接下来的命令是编译链接内核，通过 $(LD) 将目标文件链接成最终的 kernel，然后使用 OBJDUMP 生成汇编文件和符号表文件。
   
   $(call create_target,kernel)
   # 可能是调用一个函数 create_target 来创建名为 kernel 的目标。
   
   # -------------------------------------------------------------------
   
   # create bootblock
   bootfiles = $(call listf_cc,boot)
   # 通过 listf_cc 函数获取了引导块（boot）的文件列表，存储在 bootfiles 变量中。
   
   $(foreach f,$(bootfiles),$(call cc_compile,$(f),$(CC),$(CFLAGS) -Os -nostdinc))
   # 对于 bootfiles 中的每个文件 f，调用了 cc_compile 函数（可能是一个通用的编译函数），编译这些文件。这里使用了 $(CC) 作为编译器，$(CFLAGS) -Os -nostdinc 作为编译选项。
   
   bootblock = $(call totarget,bootblock)
   # 定义了一个名为 bootblock 的变量，通过 totarget 函数获取了目标文件名。
   
   $(bootblock): $(call toobj,$(bootfiles)) | $(call totarget,sign)
   	@echo + ld $@
   	$(V)$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 $^ -o $(call toobj,bootblock)
   	@$(OBJDUMP) -S $(call objfile,bootblock) > $(call asmfile,bootblock)
   	@$(OBJDUMP) -t $(call objfile,bootblock) | $(SED) '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $(call symfile,bootblock)
   	@$(OBJCOPY) -S -O binary $(call objfile,bootblock) $(call outfile,bootblock)
   	@$(call totarget,sign) $(call outfile,bootblock) $(bootblock)
   # 这是一个规则，表示生成 bootblock 这个目标文件。它依赖于 $(call toobj,$(bootfiles)) 返回的文件列表和另一个名为 sign 的目标。| 符号表示 bootblock 的构建还依赖于 sign 这个目标。
   # 接下来的命令是链接操作。使用 $(LD) 链接器将目标文件链接成最终的 bootblock。然后使用 OBJDUMP 生成汇编文件和符号表文件，最后使用 OBJCOPY 将目标文件转换为二进制文件。
   
   
   $(call create_target,bootblock)
   # 可能是调用一个函数 create_target 来创建名为 bootblock 的目标。
   # -------------------------------------------------------------------
   
   # create 'sign' tools
   $(call add_files_host,tools/sign.c,sign,sign)
   $(call create_target_host,sign,sign)
   
   # -------------------------------------------------------------------
   
   # create ucore.img
   UCOREIMG	:= $(call totarget,ucore.img)
   # 定义了一个名为 UCOREIMG 的变量，使用 totarget 函数生成了 ucore.img 的目标文件路径或名称。
   
   # 定义了构建 ucore.img 目标文件的规则。这个规则表明 ucore.img 文件依赖于 kernel 和 bootblock 这两个目标文件。
   $(UCOREIMG): $(kernel) $(bootblock)
   	$(V)dd if=/dev/zero of=$@ count=10000
   	$(V)dd if=$(bootblock) of=$@ conv=notrunc
   	$(V)dd if=$(kernel) of=$@ seek=1 conv=notrunc
   # $(V)dd if=/dev/zero of=$@ count=10000：创建一个大小为10000块的空文件，用 /dev/zero 的内容填充，其中 $@ 表示目标文件的名称 ucore.img。
   # $(V)dd if=$(bootblock) of=$@ conv=notrunc：将 bootblock 的内容复制到 ucore.img 文件中，conv=notrunc 表示不截断输出文件。这个命令会将 bootblock 的内容写入 ucore.img 的开头。
   # $(V)dd if=$(kernel) of=$@ seek=1 conv=notrunc：将 kernel 的内容追加到 ucore.img 文件中，seek=1 表示跳过文件开头，从第1个块开始写入，conv=notrunc 表示不截断输出文件。
   
   $(call create_target,ucore.img)
   # $(call create_target,ucore.img)：这可能是调用一个函数 create_target 来创建名为 ucore.img 的目标。
   
   # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   
   $(call finish_all)
   
   # 后面的内容应该就是一些命令行参数的定义，不是特别重要就暂时不写注释了。
   IGNORE_ALLDEPS	= clean \
   				  dist-clean \
   				  grade \
   				  touch \
   				  print-.+ \
   				  handin
   
   ifeq ($(call match,$(MAKECMDGOALS),$(IGNORE_ALLDEPS)),0)
   -include $(ALLDEPS)
   endif
   
   # files for grade script
   
   TARGETS: $(TARGETS)
   all: $(TARGETS)
   .DEFAULT_GOAL := TARGETS
   
   .PHONY: qemu qemu-nox debug debug-nox
   lab1-mon: $(UCOREIMG)
   	$(V)$(TERMINAL) -e "$(QEMU) -S -s -d in_asm -D $(BINDIR)/q.log -monitor stdio -hda $< -serial null"
   	$(V)sleep 2
   	$(V)$(TERMINAL) -e "gdb -q -x tools/lab1init"
   debug-mon: $(UCOREIMG)
   #	$(V)$(QEMU) -S -s -monitor stdio -hda $< -serial null &
   	$(V)$(TERMINAL) -e "$(QEMU) -S -s -monitor stdio -hda $< -serial null"
   	$(V)sleep 2
   	$(V)$(TERMINAL) -e "gdb -q -x tools/moninit"
   qemu-mon: $(UCOREIMG)
   	$(V)$(QEMU) -monitor stdio -hda $< -serial null
   qemu: $(UCOREIMG)
   	$(V)$(QEMU) -parallel stdio -hda $< -serial null
   
   qemu-nox: $(UCOREIMG)
   	$(V)$(QEMU) -serial mon:stdio -hda $< -nographic
   TERMINAL        :=gnome-terminal
   gdb: $(UCOREIMG)
   	$(V)$(QEMU) -S -s -parallel stdio -hda $< -serial null
   debug: $(UCOREIMG)
   	$(V)$(QEMU) -S -s -parallel stdio -hda $< -serial null &
   	$(V)sleep 2
   	$(V)$(TERMINAL)  -e "cgdb -q -x tools/gdbinit"
   	
   debug-nox: $(UCOREIMG)
   	$(V)$(QEMU) -S -s -serial mon:stdio -hda $< -nographic &
   	$(V)sleep 2
   	$(V)$(TERMINAL) -e "gdb -q -x tools/gdbinit"
   
   debug-nogdb: $(UCOREIMG)
   	$(V)$(QEMU) -S -s -parallel stdio -hda $< -serial null
   
   .PHONY: grade touch
   
   GRADE_GDB_IN	:= .gdb.in
   GRADE_QEMU_OUT	:= .qemu.out
   HANDIN			:= proj$(PROJ)-handin.tar.gz
   
   TOUCH_FILES		:= kern/trap/trap.c
   
   MAKEOPTS		:= --quiet --no-print-directory
   
   grade:
   	$(V)$(MAKE) $(MAKEOPTS) clean
   	$(V)$(SH) tools/grade.sh
   
   touch:
   	$(V)$(foreach f,$(TOUCH_FILES),$(TOUCH) $(f))
   
   print-%:
   	@echo $($(shell echo $(patsubst print-%,%,$@) | $(TR) [a-z] [A-Z]))
   
   .PHONY: clean dist-clean handin packall
   clean:
   	$(V)$(RM) $(GRADE_GDB_IN) $(GRADE_QEMU_OUT)
   	-$(RM) -r $(OBJDIR) $(BINDIR)
   
   dist-clean: clean
   	-$(RM) $(HANDIN)
   
   handin: packall
   	@echo Please visit http://learn.tsinghua.edu.cn and upload $(HANDIN). Thanks!
   
   packall: clean
   	@$(RM) -f $(HANDIN)
   	@tar -czf $(HANDIN) `find . -type f -o -type d | grep -v '^\.*$$' | grep -vF '$(HANDIN)'`
   ```

   这边我需要尝试解释这个`Makefile`文件：

   > 你的总结基本上是准确的，我会对你的描述进行检查和补充。
   >
   > 1. **变量定义**:
   >    你正确地指出，Makefile的头部定义了一系列变量，用于配置项目名称、路径、命令前缀等。这些变量确实为后续的编译和链接过程提供了基础配置。
   >
   > 2. **环境检查**:
   >    Makefile确实会检查系统中是否存在特定前缀的GCC工具链（`i386-elf-`），这是为了交叉编译用于不同平台的代码。如果没有找到合适的工具链，它会提示错误。
   >
   > 3. **QEMU检查**:
   >    类似地，Makefile会检查是否存在`qemu-system-i386`，这是用于模拟i386架构的QEMU虚拟机。如果没有找到，它同样会提示错误。
   >
   > 4. **Make规则配置**:
   >    你提到的“不使用默认的后缀规则”和“发生错误时删除目标文件”是Makefile的两个配置项，确保了编译过程的特定行为。
   >
   > 5. **Shell命令别称**:
   >    你正确地识别了Makefile中定义的一系列别称，它们为常用的编译、链接和其他命令提供了简化的引用方式。
   >
   > 6. **引入外部.mk文件**:
   >    `tools/function.mk`确实可能包含了一些预定义的函数，这些函数用于简化Makefile中的文件操作和编译规则的定义。
   >
   > 接下来，我会补充你后面不太明白的部分：
   >
   > 7. **编译和链接规则**:
   >    Makefile中定义了一系列的规则，用于编译源代码文件（C和汇编文件）并将它们链接成可执行文件。这些规则使用了之前定义的变量和引入的函数。
   >
   > 8. **目标文件和依赖关系**:
   >    Makefile定义了多个目标（如`kernel`, `bootblock`, `ucore.img`等），以及它们之间的依赖关系。这些目标对应于构建过程中的不同阶段，例如编译内核、创建引导块和生成完整的磁盘镜像。
   >
   > 9. **清理和辅助目标**:
   >    Makefile还包含了用于清理构建文件、打包和调试的辅助目标。这些目标使得开发者可以轻松地管理和测试他们的代码。
   >
   > 10. **条件编译**:
   >     Makefile使用条件判断来决定是否包含依赖文件，这取决于`MAKECMDGOALS`，以此来优化构建过程。
   >
   > 11. **伪目标声明**:
   >     通过`.PHONY`声明，Makefile确保了即使存在同名文件，也会执行指定的目标。
   >
   > 总的来说，这个Makefile为操作系统项目提供了一个完整的构建和管理框架，包括自动化编译、链接、生成二进制文件、清理和调试等功能。

   2. 一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？
      答：一个被系统认为是符合规范的硬盘主引导扇区的特征是，它以`0x55`和`0xAA`作为最后扇区的最后两个字节。这两个字节标识着这是一个主引导扇区，其中前面`446`个字节包含了一些指令等内容，`64`个字节包含了分区表信息（每个主分区记录大小为16字节，因此最多有4个主分区），最后剩余的`2`个字节则标识出它是一个主引导记录。<font color="red">值得注意的是，这是旧时MBR分区格式下的特征。新式的GPT分区格式会有所不同。</font>

      > 这段描述基本上是准确的，它概述了MBR（Master Boot Record）分区格式下硬盘主引导扇区的结构。确实，主引导扇区是硬盘上的第一个扇区（通常是512字节），它包含了启动计算机所需的代码和分区表。
      >
      > 这里的描述可以补充一些细节：
      >
      > 1. **引导代码**：前446个字节通常包含了引导代码，这部分代码负责在计算机启动时加载操作系统。
      >
      > 2. **分区表**：接下来的64个字节是分区表，它包含了硬盘上的分区信息。每个分区表项占用16字节，因此最多可以有4个分区表项，这些表项描述了硬盘上的主分区。
      >
      > 3. **有效标志**：最后两个字节（0x55和0xAA）是有效标志，这是用来标识一个有效的引导扇区。如果这两个字节不是0x55和0xAA，计算机的BIOS或UEFI不会认为这是一个有效的引导扇区，因此不会从该硬盘启动。
      >
      > 需要补充的是，GPT（GUID Partition Table）是一个较新的分区格式，它支持超过2TB的硬盘和多于4个的主分区。GPT分区格式的硬盘也有一个保护MBR，位于硬盘的第一个扇区，但它的结构和目的与传统MBR不同。GPT的实际分区表和引导数据位于硬盘的其他部分。
      >
      > 此外，对于GPT分区格式，引导数据通常位于EFI系统分区（ESP），这是一个特殊的分区，用于存储UEFI引导加载器和相关数据，而不是传统的MBR引导代码。
   
   

### 练习二

为了熟悉使用qemu和gdb进行的调试工作，我们进行如下的小练习：

1. 从CPU加电后执行的第一条指令开始，单步跟踪BIOS的执行。
2. 在初始化位置0x7c00设置实地址断点,测试断点正常。
3. 从0x7c00开始跟踪代码运行,将单步跟踪反汇编得到的代码与bootasm.S和 bootblock.asm进行比较。
4. 自己找一个bootloader或内核中的代码位置，设置断点并进行测试。

在这里，我会逐个解释这些任务是如何完成的。

1. CPU加电后的第一条指令，指的就是CPU加电时它的代码段寄存器（CS）和当前指令指针（EIP）指向的段：偏移地址，这是一个线性地址，在没有启动页机制的情况下它也是一个物理地址。这个物理地址指向了`0xffff0`这个地址，这是加电后执行的第一条指令的位置。

   那么，如何进行单步跟踪呢？首先我们需要注意到，在`Makefile`中有这么一段：

   ```makefile
   debug: $(UCOREIMG)
   	$(V)$(QEMU) -S -s -parallel stdio -hda $< -serial null &
   	$(V)sleep 2
   	$(V)$(TERMINAL)  -e "cgdb -q -x tools/gdbinit"
   
   这段代码是一个Makefile脚本的一部分，通常用于自动化编译和调试过程。它定义了一个名为`debug`的目标，该目标用于启动QEMU模拟器以运行和调试一个名为`$(UCOREIMG)`的操作系统镜像。下面是每一行代码的详细解释：
   
   1. `debug: $(UCOREIMG)`
      这行定义了一个Makefile规则的目标`debug`，它依赖于变量`$(UCOREIMG)`。这通常意味着在执行`debug`目标之前，`$(UCOREIMG)`需要被创建或是最新的。
   
   2. `$(V)$(QEMU) -S -s -parallel stdio -hda $< -serial null &`
      这行代码执行QEMU命令来启动一个虚拟机：
      - `$(V)`和`$(QEMU)`是Makefile变量，它们可能被定义为控制命令的可视化输出和QEMU的路径。
      - `-S`参数告诉QEMU在启动时暂停CPU的执行，等待调试器的连接。
      - `-s`参数是一个便捷选项，它创建了一个GDB服务器监听在默认的TCP端口1234上。
      - `-parallel stdio`可能是将QEMU的并行端口重定向到标准输入输出。
      - `-hda $<`指定了要使用的硬盘镜像，`$<`是Makefile的自动变量，它代表规则依赖中的第一个项，在这里是`$(UCOREIMG)`。
      - `-serial null`将串行端口输出重定向到null，这样可以避免在QEMU中显示额外的信息。
      - `&`将QEMU进程放到后台执行。
   
   3. `$(V)sleep 2`
      这行代码使得Makefile脚本暂停执行2秒钟。这通常是为了给QEMU足够的时间启动并等待调试器的连接。
   
   4. `$(V)$(TERMINAL) -e "cgdb -q -x tools/gdbinit"`
      这行代码打开一个新的终端窗口并执行`cgdb`，一个图形化的GDB前端：
      - `$(TERMINAL)`是一个变量，指向用户的终端程序。
      - `-e`参数指定终端执行的命令。
      - `"cgdb -q -x tools/gdbinit"`启动`cgdb`并告诉它使用`tools/gdbinit`作为GDB的初始化脚本。`-q`参数使`cgdb`在启动时不显示任何欢迎信息。
   
   综上所述，这段代码的作用是为了调试`$(UCOREIMG)`操作系统镜像。它启动了一个QEMU虚拟机实例，并设置了GDB调试器，允许开发者在图形界面中调试操作系统代码。
   ```

   这里是定义了一个类似`make`命令的参数形式，当我们执行`make debug`时，`shell`中会执行`debug`这个块中的所有命令。

   注意到，这些命令中包含了`"cgdb -q -x tools/gdbinit"`，也就是说需要用到`tools/gdbinit`这个文件用来初始化`gdb`，`gdbinit`的初始内容如下：

   ```shell
   file obj/bootblock.o
   target remote :1234
   break bootmain
   continue
   ```

   在不修改这个文件的情况下，它会输出关于目标文件`bootblock`的一些基本信息，然后链接到`qemu`，在`bootmain`这个函数的起始位置设置一个断点，随后启动程序。

   因此，为了我们的单步调试，我们将这个文件内容修改为：

   ```shell
   file obj/bootblock.o
   set architecture i8086
   break *0xffff0	# 这句没用
   target remote :1234
   break *0x7c00
   ```

   这将调试环境设置为`i8086`，并链接到`qemu`以及在两个内存地址处设置断点。一个问题在于，在`0xffff0`这个位置设置的断点似乎并不能被触发，暂时没明白原因。至于`0x7c00`这个地址是`bios`找到了主引导记录后将操作系统内核加载到内存中的位置，也是我们下一个问题要做的。

2. 这个问题在上面已经得到解答。

3. 单步机器代码执行的指令是`si`，在`gdb`调试器中输入即可。输入`x /10i $pc`可以查看接下来十条反汇编的代码，在执行`bootmain`函数之前，它的内容和`bootasm.S`和`bootblock.asm`的内容都是相同的。

4. 略

### 练习三

BIOS将通过读取硬盘主引导扇区到内存，并转跳到对应内存中的位置执行bootloader。请分析bootloader是如何完成从实模式进入保护模式的。

提示：需要阅读**小节“保护模式和分段机制”**和lab1/boot/bootasm.S源码，了解如何从实模式切换到保护模式，需要了解：

- 为何开启A20，以及如何开启A20
- 如何初始化GDT表
- 如何使能和进入保护模式



答：	首先，为了回答<font color="red">为何开启A20？</font>我们必须了解什么是A20.

#### A20

`A20`指的是地址总线上的第21根地址线。

在旧式的`Intel 8086`CPU上，这个时候应该还没有"实模式"和"保护模式"的区分。由CPU寄存器通过地址总线传输给内存的都是物理地址，因此应用软件就有机会在它使用CPU时通过寻址访问操作系统所在的内存，进而引发危险的操作。

另外需要说明的一点是，`Intel 8086`提供了20根地址线，因此其理论寻址能力是$2^{20}=1048576\ bytes=1MB$。但是8086的寄存器只有16位，也就是说如果没有别的机制的情况下，它的实际寻址能力是不足$2^{20}$的。

因此，8086提供了段地址(segment)：偏移地址(offset)的方式来增强寻址能力，`segment`和`offset`都是16位的寄存器(其最大值都是$2^{16}$，也就是`0xffff`)。其中`segment`用来表示20位地址的高16位，`offset`则表示20位地址的低4位。

在段地址：偏移的情况下，理论最大寻址范围为：

```
segment: 0xffff << 4 = 1111 1111 1111 1111 0000
offset:       0xffff = 0000 1111 1111 1111 1111
segment + offset:
result:     0x10ffef = 0001 0000 1111 1111 1110 1111
```

理论上最大能够访问的地址是`0x10FFEF`，大约是`1114095`个字节，`1088`个字节，这超出了实模式下`1024KB`的地址线的访问能力，能够满足我们对地址表达的要求。

但是还是那个问题，地址线只有20根，`0x10FFEF`这个地址传输给地址线时，会发生地址的**回卷**。也就是说最高位的1地址线传输不了，因此实际上寻址是`0xffef`，这就导致了错误的寻址，但是不会引发异常，程序员需要自己确保访问到了正确的地址，由于错误寻址以及导致的意外修改数据的风险需要自己承担。

然而在下一代的`Intel 80286`处理器中，地址线变成了24根，这就能保证正常的访问`0x10FFEF`这样的地址了，不会发生地址的回卷。这意味着`A20`在默认情况下处于启用状态。为了保证向下的兼容性，IBM决定在PC AT计算机系统上加个硬件逻辑，来模仿以上的回卷特征，于是出现了A20 Gate。

方法就是把A20地址线控制和键盘控制器的一个输出进行AND操作，这样来控制A20地址线的打开（使能）和关闭（屏蔽\禁止）。一开始时A20地址线控制是被屏蔽的（总为0），直到系统软件通过一定的IO操作去打开它（参看bootasm.S）。

在保护模式下，如果我们有32条地址线，想要访问到所有的内存，就必须要打开A20。否则，地址将始终是类似`0xfffeffff`这样的形式（第21位永远是0，因此其16进制下最多为e）。这将导致我们只能访问奇数兆的内存。

<font color="red">那么，如何打开A20呢？</font>

需要通过向键盘控制器8042发送一个命令来完成。键盘控制器8042将会将它的的某个输出引脚的输出置高电平，作为 A20 地址线控制的输入。一旦设置成功之后，内存将不会再被绕回(memory wrapping)，这样我们就可以寻址整个 286 的 16M 内存，或者是寻址 80386级别机器的所有 4G 内存了。

键盘控制器8042，其实也就是`Intel 8042`芯片。其中它的IO端口范围从`0x60 ~ 0x6f`，但是实际上早期的`IBM PC/AT`只用到了`0x60`（输入和输出缓冲）和`0x64`（输入缓冲）。

8042通过这两个端口实现IO操作。此外，8042键盘控制器内部还包含了特定的输出端口`P1`和`P2`。

> 在计算机体系结构中，I/O（Input/Output）端口是用于与外部设备进行通信的一种机制。在x86架构中，有一些特定的I/O端口范围被分配给不同的设备或者功能。
>
> 8042是一个常用于键盘控制的芯片，负责处理键盘输入并将其传递给计算机。这个芯片的I/O端口范围通常是从0x60到0x6F。这些端口包括了用于键盘输入和输出的通信端口，以及控制和状态寄存器等。
>
> P1和P2是特定于键盘控制器的输出端口，它们用于与键盘进行通信。这些端口通常是8042芯片内部的寄存器或者通道，用于发送命令、接收键盘输入等操作。
>
> 因此，P1和P2可以说是8042芯片内部的输出端口，而整个键盘控制器的I/O端口范围则涵盖了与计算机进行通信所需的所有端口，包括了与键盘交互的部分以及控制和状态寄存器等。虽然它们都属于键盘控制器的一部分，但是P1和P2更加具体地指向了与键盘交互的特定端口或寄存器。

其中，输出端口`P2`用于特定目的，位0（P20）引脚用于实现CPU复位操作，<font color="red">位1（P21）用户控制A20信号线的开启与否。</font>

在实际设置A20端口的过程中，系统向输入缓冲（`0x64`）写入一个字节（表示一个命令），这个命令如果需要一个参数的话，则将这个参数写入到另一个输入缓冲(`0x60`)中以供读取，命令完成后的返回值也是从输出缓冲(`0x60`)去读。

8042有4个寄存器：

- 1个8-bit长的Input buffer；Write-Only；
- 1个8-bit长的Output buffer； Read-Only；
- 1个8-bit长的Status Register；Read-Only；
- 1个8-bit长的Control Register；Read/Write。.

有两个端口地址：`0x60`和`0x64`，有关对它们的读写操作描述如下：

- 读`0x60`端口，读output buffer
- 写`0x60`端口，写input buffer
- 读`0x64`端口，读Status Register
- 操作Control Register，首先要向`0x64`端口写一个命令（`0x20`为读命令，`0x60`为写命令），然后根据命令从`0x60`端口读出Control Register的数据或者向`0x60`端口写入Control Register的数据（`0x64`端口还可以接受许多其它的命令）。

Status Register的定义（要用bit 0和bit 1）：

| bit  | meaning                                                 |
| ---- | ------------------------------------------------------- |
| 0    | output register (60h) 中有数据                          |
| 1    | input register (60h/64h) 有数据                         |
| 2    | 系统标志（上电复位后被置为0）                           |
| 3    | data in input register is command (1) or data (0)       |
| 4    | 1=keyboard enabled, 0=keyboard disabled (via switch)    |
| 5    | 1=transmit timeout (data transmit not complete)         |
| 6    | 1=receive timeout (data transmit not complete)          |
| 7    | 1=even parity rec'd, 0=odd parity rec'd (should be odd) |

除了这些资源外，8042还有3个内部端口：Input Port、Outport Port和Test Port，这三个端口的操作都是通过向64h发送命令，然后在60h进行读写的方式完成，其中本文要操作的A20 Gate被定义在Output Port的bit 1上，所以有必要对Outport Port的操作及端口定义做一个说明。

- 读Output Port：向64h发送0d0h命令，然后从60h读取Output Port的内容
- 写Output Port：向64h发送0d1h命令，然后向60h写入Output Port的数据
- 禁止键盘操作命令：向64h发送0adh
- 打开键盘操作命令：向64h发送0aeh

---

<font color="red">有了上面这些知识，我们可以考虑如何来设置`A20`端口了。</font>

首先，为了保证我们的命令参数能够正常传输，我们需要保证`0x60`输入缓冲区为空。因此首先我们需要了解`0x60`的输入缓冲区的状态，这是通过读`status register`来实现的，从上面的内容不难看出，这指的是我们读`0x64`端口。在`bootasm.S`代码中，我们使用`inb`命令读取一个字节（该命令本身就是读一个字节）到`AL`寄存器中：

```assembly
inb $0x64, %al
```

在`status register`的`bit 1`位置，标志了输入缓冲区(`0x60`和`0x64`)中是否有数据，因此我们需要通过按位与（`testb`）来判断`bit 1`位置是多少：

```assembly
testb $0x2, %al
```

此时，按位与的结果显然要么0要么1，我们当然希望结果是0（输入缓冲区为空）。但是如果结果为1的话，则会执行`jnz seta20.1`命令，这条命令根据上一条命令的执行结果为真，则跳转到`seta20.1`处（有点像`goto`命令），如果为假则不跳转继续往下顺序执行。完整代码为：

```assembly
seta20.1:
    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).
    testb $0x2, %al
    jnz seta20.1

    movb $0xd1, %al                                 # 0xd1 -> port 0x64
    outb %al, $0x64                                 # 0xd1 means: write data to 8042's P2 port
```

<font color="blue">上面这部分就完整的展示了我们判断键盘控制器输入缓冲区是否为空的完整流程。最后的两行代码表示，如果缓冲区终于空了，则会将`0xd1`这个值传给`AL`寄存器并将该命令发送给`0x64`输入端口。</font>

`0xd1`则是`x86`结构下的一种约定，这个约定表明，如果发送了`0xd1`这个命令，则表示要将数据写入到接收方的`P2`端口中。

> 这段汇编代码是用于在x86架构的计算机中操作键盘控制器（通常是Intel 8042芯片）以更改地址线A20的状态。A20线是用来处理内存地址的，它的状态影响计算机如何访问内存。在早期的PC架构中，由于历史原因，需要禁用A20线以进入实模式。
>
> 代码的具体操作如下：
>
> 1. `seta20.1:` 是一个标签，用于循环的跳转。
>
> 2. `inb $0x64, %al`：从端口0x64读取一个字节到AL寄存器中。端口0x64是键盘控制器的状态寄存器端口，用于检查控制器的状态。
>
> 3. `testb $0x2, %al`：测试AL寄存器的第二位（即输入缓冲区状态位）。这是通过将AL寄存器的内容与0x2进行AND操作来实现的，如果结果非零，则设置零标志（ZF）为0。
>
> 4. `jnz seta20.1`：如果零标志（ZF）为0（即AL寄存器的第二位为1，表示输入缓冲区不为空），则跳转回`seta20.1`标签处，形成一个等待循环，直到输入缓冲区为空。
>
> 5. `movb $0xd1, %al`：将0xd1移动到AL寄存器中。0xd1是一个命令字节，告诉键盘控制器接下来要写入的字节将被发送到控制器的P2端口。
>
> 6. `outb %al, $0x64`：将AL寄存器的内容（即0xd1）输出到端口0x64。这个操作实际上是发送一个命令给键盘控制器，告诉它准备接收一个写入到P2端口的数据字节。
>
> 这段代码的目的是准备键盘控制器，以便可以发送一个命令来更改A20线的状态。但是，这段代码本身并没有改变A20线的状态，它只是设置了键盘控制器，以便可以发送一个命令来做这个更改。通常，紧接着这段代码之后，会有另一段代码发送实际的数据字节到P2端口，以启用或禁用A20线。

接着，在下一个代码段中，我们仍然需要判断一下输入缓冲区是否为空，才能确保我们发送给键盘控制器的下一个字节能否正确发送。这是因为在两次操作之间，可能有其他字节被写入到输入缓冲区中。

> 在`seta20.1`代码段中判断输入缓冲区是否为空是为了确保在向键盘控制器发送0xD1命令之前，控制器已经处理完之前的所有指令，并且准备好接收新的指令。这是因为如果控制器的输入缓冲区不为空，即它还在忙于处理之前的数据或命令，那么新的命令可能会被忽略或导致错误。
>
> 在`seta20.2`代码段中再次判断输入缓冲区是否为空是因为在两次写操作之间需要确保键盘控制器已经处理完第一个写操作（即接收0xD1命令并准备好接收到P2端口的数据）。在发送0xD1命令后，控制器需要一些时间来处理这个命令并设置自己的状态，以便接收下一个字节到P2端口。如果不等待控制器准备好，直接发送下一个字节（0xDF），那么这个字节可能会丢失或导致不可预知的行为。
>
> 因此，每次向键盘控制器发送命令或数据之前，都需要检查输入缓冲区是否为空，以确保控制器已经准备好接收新的输入。这是一种常见的同步机制，用于确保与低速设备的通信是可靠的。

当输入缓冲区准备好了以后，我们则通过`AL`寄存器向`0x60`这个端口发送命令`0xdf`，这个操作就是实际上的启用`A20`端口的命令。

```assembly
seta20.2:
    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).
    testb $0x2, %al
    jnz seta20.2

    movb $0xdf, %al                                 # 0xdf -> port 0x60
    outb %al, $0x60                                 # 0xdf = 11011111, means set P2's A20 bit(the 1 bit) to 1
```

>这段代码是在前一段代码的基础上，继续进行了一些操作，包括启用A20线，切换到保护模式，并跳转到32位代码段。具体解释如下：
>
>1. `seta20.2:` 是一个新的标签，用于循环的跳转。
>
>2. `inb $0x64, %al` 和 `testb $0x2, %al`，`jnz seta20.2` 这三行代码的功能与前一段代码中的相同，都是等待键盘控制器的输入缓冲区为空。
>
>3. `movb $0xdf, %al`：将0xdf移动到AL寄存器中。0xdf是一个命令字节，用于设置键盘控制器的P2端口的A20线。
>
>4. `outb %al, $0x60`：将AL寄存器的内容（即0xdf）输出到端口0x60。这个操作实际上是发送一个命令给键盘控制器，告诉它启用A20线。
>

<font color="red">经过以上的操作，我们就成功的启用了A20端口。但是，这**并不完全意味着**进入了保护模式。</font>

为什么这么说呢？因为开启A20端口，实际上是使得CPU的可用地址线数升到了32，这从实际意义上增强了CPU的寻址能力。但是我们仍然需要某个“状态”让CPU知道自己进入了保护模式，这也就涉及到了**CR0寄存器**。

因此，在`bootasm.S`文件的`seta20.2`段中，还包含以下汇编：

```assembly
    # Switch from real to protected mode, using a bootstrap GDT
    # and segment translation that makes virtual addresses
    # identical to physical addresses, so that the
    # effective memory map does not change during the switch.
    lgdt gdtdesc
    movl %cr0, %eax
    orl $CR0_PE_ON, %eax
    movl %eax, %cr0

    # Jump to next instruction, but in 32-bit code segment.
    # Switches processor into 32-bit mode.
    ljmp $PROT_MODE_CSEG, $protcseg
```

> 5. `lgdt gdtdesc`：加载全局描述符表（GDT）的地址到GDTR寄存器中。gdtdesc是GDT的地址。
>
> 6. `movl %cr0, %eax`：将控制寄存器CR0的内容移动到EAX寄存器中。
>
> 7. `orl $CR0_PE_ON, %eax`：将CR0_PE_ON（即保模护式使能位）与EAX寄存器的内容进行OR操作，结果存回EAX寄存器。这个操作的目的是设置CR0的PE位，以启用保护模式。
>
> 8. `movl %eax, %cr0`：将EAX寄存器的内容移动回CR0寄存器，完成保护模式的启用。
>
> 9. `ljmp $PROT_MODE_CSEG, $protcseg`：长跳转到保护模式的代码段。PROT_MODE_CSEG是代码段选择子，protcseg是跳转的目标地址。这个操作的目的是切换到32位代码段，同时也触发了处理器从实模式切换到保护模式。
>

通过上述汇编代码，我们就将`CR0`寄存器的`PE`位启用了，也就完成了保护模式使能。

完成了保护模式使能后，我们就需要改变我们的寻址方式了。在实模式下我们通过直接访问物理地址的方式来进行读写。而进入保护模式后，则是通过段-偏移的方式来寻址。

因此，在上述代码的最后我们使用`ljmp $PROT_MODE_CSEG, $protcseg`执行一个长跳转。将段选择子设置为`0x8`（这是我们定义的`GDT`表中第二个段（第一个段是一个空段）在表中的位置），将偏移量设置为保护模式下的代码的起始地址。

<font color="red">上面的内容解释了为何开启A20，如何开启A20，如何使能和进入保护模式的操作。最后一个问题是，如何初始化GDT表？</font>

首先，在`bootasm.S`中有以下内容：

```assembly
# Bootstrap GDT
.p2align 2                                          # force 4 byte alignment
gdt:
    SEG_NULLASM                                     # null seg
    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)           # code seg for bootloader and kernel
    SEG_ASM(STA_W, 0x0, 0xffffffff)                 # data seg for bootloader and kernel

gdtdesc:
    .word 0x17                                      # sizeof(gdt) - 1
    .long gdt                                       # address gdt

```

其中，`gdt`的部分就设置了我们的`GDT`表。它包含了一个空段、一个4GB大小的代码段和一个4GB大小的数据段。其中代码段可读可执行，数据段可写。

紧随其后，`gdtdesc`中定义了`GDT`表的大小和`gdt`表的地址。`.word`表示一个字大小的数字（16位）`0x17`，因为`GDT`表的大小从0开始计算，因此实际大小是`0x17 + 1 = 0x18 = 24`个字节。

`.long`则表示这是一个32位的数字，表示gdt表的地址。

有了这些定义后，在`seta20.2`部分的代码中，通过`lgdt gdtdesc`就可以将`gdt`表加载到`GDTR`寄存器中了。这样就完成了GDT表的初始化。

### 练习四

通过阅读bootmain.c，了解bootloader如何加载ELF文件。通过分析源代码和通过qemu来运行并调试bootloader&OS，

- bootloader如何读取硬盘扇区的？
- bootloader是如何加载ELF格式的OS？

提示：可阅读“硬盘访问概述”，“ELF执行文件格式概述”这两小节。

---

这部分的代码内容位于`bootmain.c`中，这里就不完整列出了。仅给出解释。

首先，在`bootasm.S`中，通过`call bootmain`的方式调用了`bootmain.c`中的`bootmain`函数。

该函数中第一句为`readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0);`，这里解释各个参数的意义。

- `ELFHDR`，这是一个宏定义，`#define ELFHDR      ((struct elfhdr *)0x10000) `。在这里是初始化了一个`elfhdr *`结构体指针，其地址为`0x10000`。
  为什么要初始化为`0x10000`？这个地址是一个临时空间，用于存放从硬盘读取的ELF格式的内核映像的头部信息。这个地址必须足够低，以便在没有操作系统管理内存的情况下使用，同时又要足够高，以避免覆盖引导加载器自身的代码和数据。`0x10000` 是一个常见的选择，因为它通常位于可用的内存区域，并且远离BIOS和其他关键结构。

- `SECTSIZE * 8`，这里的扇区大小也是一个宏定义，大小为512。这表示我们要读取8个扇区。也就是4096个字节，4KB的大小。

  > 在这段代码中，ELF头部和程序头表被读取到8个扇区（即4KB）的内存中，这并不是一个强制的规定或者默认的约定，而是一个设计选择。
  >
  > ELF头部的大小通常是固定的，对于32位系统，通常是52字节，对于64位系统，通常是64字节。程序头表的大小则取决于程序段的数量，每个程序头表项通常是32或56字节（取决于是32位还是64位系统）。因此，对于大多数系统，ELF头部和程序头表的总大小通常远小于4KB。
  >
  > 然而，这段代码选择读取8个扇区（4KB），可能是出于以下几个原因：
  >
  > 1. **简化设计**：由于硬盘的最小读取单位是一个扇区（通常是512字节），因此选择读取整数个扇区可以简化设计和实现。读取8个扇区（4KB）可以确保无论ELF头部和程序头表的实际大小如何，都能完全读入内存。
  >
  > 2. **性能优化**：硬盘的读取性能通常以连续的扇区为单位最优。一次读取多个扇区通常比分多次读取单个扇区更快。
  >
  > 3. **容错**：即使程序头表异常地大，或者有些额外的数据需要加载，预留更多的空间也能确保这些数据能被正确地加载到内存中。
  >
  > 总的来说，这是一个权衡简化设计、优化能性和增强容错能力的结果。在实际的系统设计中，这个值可能会根据具体的需求和约束进行调整。

- 第三个参数0，实际上表示的是`offset`，这表示了内核映像的偏移量。即从内核映像的哪个位置开始读取。这里从头开始读取，因此偏移量为0。

接下来进入到`readseg`函数中，定义`end_va`为读取结束的位置。并将目标虚拟地址（`va`）减去偏移量（`offset`）与扇区大小（`SECTSIZE`）的模，这样做是为了将虚拟地址向下对齐到扇区边界。因为硬盘读取操作是以扇区为单位的，所以即使请求的数据不是从扇区的起始位置开始，也需要从扇区的起始位置读取数据。

 接着，函数计算出要读取的第一个扇区号。它通过将偏移量除以扇区大小得到偏移量所在的扇区号，然后加1（因为内核映像是从硬盘的第二个扇区开始的，第一个扇区被引导加载器，也就是`bootasm.S`和`bootmain.c`占用）。

`readseg` 函数接下来进入一个循环，循环的每次迭代都会读取一个扇区的数据到内存中。循环会一直进行，直到目标虚拟地址加上要读取的字节数（`end_va`）为止。在每次迭代中，函数会：

- 调用 `readsect` 函数，将数据从硬盘的当前扇区号读取到当前的虚拟地址。
- 将虚拟地址向前移动一个扇区大小（`SECTSIZE`），以便下一次迭代读取下一个扇区。
- 将扇区号递增，以便下一次迭代读取下一个扇区。

> `readsect`函数的主要任务是从硬盘的指定扇区读取数据到内存中的指定位置。这个函数使用了BIOS中断调用（`int 0x13`）来完成硬盘的读取操作。下面是对这个函数的逐句解释：
>
> 1. **等待硬盘准备好**：
>    `waitdisk`函数会等待硬盘准备好，即等待硬盘的状态寄存器的第7位（BUSY位）清零，第3位（DRQ位）置1。这表示硬盘已经准备好数据传输。
> 2. **设置硬盘参数**：
>    接下来，函数设置硬盘的参数，准备进行读取操作。它通过向I/O端口`0x1F2`到`0x1F7`写入数据来设置参数：
>    - 向`0x1F2`端口写入`1`，表示要读取1个扇区的数据。
>    - 向`0x1F3`到`0x1F5`端口写入扇区号的低24位，这是要读取的扇区的编号。
>    - 向`0x1F6`端口写入扇区号的高8位和硬盘号，这里硬盘号被设置为0，表示从第一个硬盘读取数据。
>    - 向`0x1F7`端口写入`0x20`，这是硬盘控制器的读命令，表示要开始读取数据。
> 3. **等待硬盘准备好**：
>    再次调用`waitdisk`函数，等待硬盘准备好数据。
> 4. **读取数据**：
>    最后，函数通过从`0x1F0`端口读取数据，将一个扇区的数据读取到内存中的指定位置。因为一个扇区通常是512字节，所以这个操作需要进行128次，每次读取4字节。
>    注意的是，这里调用`insl`函数进行读取。每次读取的大小为4个字节，`insl`的第三个参数用于指定读取的次数，因此实参为`SECTSIZE / 4`。
>
> 通过这个过程，`readsect`函数能够将硬盘的一个扇区的数据读取到内存中的指定位置。这是`readseg`函数的基础，`readseg`函数通过多次调用`readsect`函数，可以将内核映像的一部分或全部从硬盘加载到内存中。

通过上述内容，就可以将ELF文件头读取到内存中了。

接下来，校验我们读取的数据是否符合ELF文件的"魔数"，以确定其是否是一个合法的ELF文件。

然后，我们需要将代码段加载到内存中：

> 这段代码是从ELF（Executable and Linkable Format）格式的可执行文件中加载程序段到内存，并跳转到程序的入口点执行。这通常是操作系统引导加载器的一部分，用于加载内核到内存并开始执行。下面是对这段代码的逐行解释：
>
> 1. `struct proghdr *ph, *eph;`
>    
>    这行代码声明了两个指向`proghdr`结构体的指针，`ph`和`eph`。`proghdr`结构体通常定义了ELF文件中的一个程序头部（program header），它描述了一个程序段（segment）的位置和大小等信息。
>
> 2. `ph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR->e_phoff);`
>    
>    这行代码将`ph`指针初始化为指向ELF文件中程序头部表的开始位置。`ELFHDR`是一个指向ELF文件头的指针，`e_phoff`是文件头中的一个字段，表示程序头部表相对于ELF文件开始的偏移量。通过将ELF文件的起始地址与偏移量相加，我们得到了程序头部表的实际内存地址。
>
> 3. `eph = ph + ELFHDR->e_phnum;`
>    
>    这行代码将`eph`指针初始化为指向程序头部表的结束位置。`e_phnum`是ELF文件头中的一个字段，表示程序头部的数量。通过将`ph`指针加上头部数量，我们得到了表的结束位置。
>
> 4. `for (; ph < eph; ph ++) {`
>    
>    这是一个for循环，它遍历所有的程序头部。循环会一直进行，直到`ph`指针达到`eph`指针指向的位置。
>
> 5. `readseg(ph->p_va & 0xFFFFFF, ph->p_memsz, ph->p_offset);`
>    
>    在循环体内，调用`readseg`函数来加载程序段。`ph->p_va`是程序头部中定义的该段的虚拟地址，`ph->p_memsz`是该段在内存中所需的大小，`ph->p_offset`是该段在ELF文件中的偏移量。`& 0xFFFFFF`可能是为了进行地址对齐或者去除高位的地址信息。`readseg`函数负责将ELF文件中的数据读取到内存的指定位置。
>
> 6. `((void (*)(void))(ELFHDR->e_entry & 0xFFFFFF))();`
>    
>    这行代码是一个函数指针的调用，它从ELF文件头中获取入口点地址`e_entry`，并将其转换为一个无参数、无返回值的函数指针，然后调用这个函数。这实际上是跳转到加载的程序的入口点并开始执行。同样地，`& 0xFFFFFF`可能是用于地址对齐或者去除高位的地址信息。注意，这个调用是不会返回的，意味着一旦跳转到入口点，控制权就完全交给了加载的程序。
>
> 总的来说，这段代码负责将ELF文件中定义的程序段加载到内存，并跳转到程序的入口点开始执行。这是操作系统从引导加载器转交控制权到内核的关键步骤。

### 练习五

我们需要在lab1中完成kdebug.c中函数print_stackframe的实现，可以通过函数print_stackframe来跟踪函数调用堆栈中记录的返回地址。在如果能够正确实现此函数，可在lab1中执行 “make qemu”后，在qemu模拟器中得到类似如下的输出：

```shell
……
ebp:0x00007b28 eip:0x00100992 args:0x00010094 0x00010094 0x00007b58 0x00100096
    kern/debug/kdebug.c:305: print_stackframe+22
ebp:0x00007b38 eip:0x00100c79 args:0x00000000 0x00000000 0x00000000 0x00007ba8
    kern/debug/kmonitor.c:125: mon_backtrace+10
ebp:0x00007b58 eip:0x00100096 args:0x00000000 0x00007b80 0xffff0000 0x00007b84
    kern/init/init.c:48: grade_backtrace2+33
ebp:0x00007b78 eip:0x001000bf args:0x00000000 0xffff0000 0x00007ba4 0x00000029
    kern/init/init.c:53: grade_backtrace1+38
ebp:0x00007b98 eip:0x001000dd args:0x00000000 0x00100000 0xffff0000 0x0000001d
    kern/init/init.c:58: grade_backtrace0+23
ebp:0x00007bb8 eip:0x00100102 args:0x0010353c 0x00103520 0x00001308 0x00000000
    kern/init/init.c:63: grade_backtrace+34
ebp:0x00007be8 eip:0x00100059 args:0x00000000 0x00000000 0x00000000 0x00007c53
    kern/init/init.c:28: kern_init+88
ebp:0x00007bf8 eip:0x00007d73 args:0xc031fcfa 0xc08ed88e 0x64e4d08e 0xfa7502a8
<unknow>: -- 0x00007d72 –
……
```

请完成实验，看看输出是否与上述显示大致一致，并解释最后一行各个数值的含义。

提示：可阅读小节“函数堆栈”，了解编译器如何建立函数调用关系的。在完成lab1编译后，查看lab1/obj/bootblock.asm，了解bootloader源码与机器码的语句和地址等的对应关系；查看lab1/obj/kernel.asm，了解 ucore OS源码与机器码的语句和地址等的对应关系。

要求完成函数kern/debug/kdebug.c::print_stackframe的实现，提交改进后源代码包（可以编译执行），并在实验报告中简要说明实现过程，并写出对上述问题的回答。

补充材料：

由于显示完整的栈结构需要解析内核文件中的调试符号，较为复杂和繁琐。代码中有一些辅助函数可以使用。例如可以通过调用print_debuginfo函数完成查找对应函数名并打印至屏幕的功能。具体可以参见kdebug.c代码中的注释。



若要解决这个问题，首先必须了解一些前置知识。在`bootasm.S`这个文件中，包含了对于栈的一些初始化：

```assembly
![寄存器及栈帧](D:\Code\Reinforcement-Learning\cpp_note\images\寄存器及栈帧.png)# start address should be 0:7c00, in real mode, the beginning address of the running bootloader
.globl start
start:
.code16                                             # Assemble for 16-bit mode
    cli                                             # Disable interrupts
    cld                                             # String operations increment

    # Set up the important data segment registers (DS, ES, SS).
    xorw %ax, %ax                                   # Segment number zero
    movw %ax, %ds                                   # -> Data Segment
    movw %ax, %es                                   # -> Extra Segment
    movw %ax, %ss                                   # -> Stack Segment
```

这部分代码的解释为：

> 这段代码是一个操作系统引导程序的一部分，通常是在16位实模式下运行的，这是计算机启动时CPU的默认模式。下面是对这段代码的逐行解释：
>
> 1. `.globl start`：这行指示汇编器将`start`标签（或符号）设置为全局的，这意味着`start`可以在其他汇编文件中被引用。
>
> 2. `start:`：这是一个标签，表示接下来的代码块的开始点，通常是程序的入口点。
>
> 3. `.code16`：这个指令告诉汇编器生成16位模式下的代码。这是必要的，因为现代计算机在启动时处于16位的实模式。
>
> 4. `cli`：这个指令用于清除中断标志，禁用硬件中断。这是为了防止在设置段寄存器和栈的时候发生中断，从而保证这些操作的原子性。
>
> 5. `cld`：清除方向标志，这样之后的字符串操作（如`movsb`, `movsw`等）会向高地址方向递增。
>
> 6. `xorw %ax, %ax`：这个指令将AX寄存器的值设置为0。`xor`是异或操作，任何值与自身异或的结果都是0。
>
> 7. `movw %ax, %ds`：将AX寄存器（现在是0）的值移动到DS寄存器，设置数据段寄存器为0。
>
> 8. `movw %ax, %es`：将AX寄存器的值移动到ES寄存器，设置附加段寄存器为0。
>
> 9. `movw %ax, %ss`：将AX寄存器的值移动到SS寄存器，设置堆栈段寄存器为0。
>
> 这些操作将数据段（DS）、附加段（ES）和堆栈段（SS）寄存器都初始化为0，这意味着它们都指向内存的0地址。在实模式下，这通常是RAM的开始位置。
>

然后，在该文件的另一个部分，设置了`ebp`寄存器和`esp`寄存器指针的初始地址：

```assembly
    movl $0x0, %ebp
    movl $start, %esp
```

`ebp`是栈的基址指针，`esp`可以理解为栈顶指针寄存器。

为了理解接下来的内容，我们需要想象这么一个栈：栈的底部为高地址，顶部为低地址。范围从`0x7c~0x00`。在初始化时，`esp`指针指向`0x7c`（栈为空），`ebp`指针指向`0x0`（表示没有函数调用）。

来看这张图，我们通过这张图来解释当函数调用时，栈中以及`ebp`、`esp`的变化：

![img](.\images\寄存器及栈帧.png)

我们需要从最下面的`Caller's Caller's EBP`来开始看。我们假设在`main`函数中发生了对`fun`函数的调用。

首先，它是一个高地址，当函数调用发生时，首先将`main`函数中的局部变量以及寄存器的值保存。

然后，将`fun`函数的参数（我们假设其有3个参数）按照从右到左的顺序逐个压入栈中，在这个过程中，`esp`会不断减少（栈顶为低地址）来指向新的栈顶。

将参数压入完毕后，将<font color="red">返回地址（也就是 执行完`fun`函数后下一条指令所在的地址）压入栈中。</font>

然后，将`ebp`（此时它还在指向`Caller's Caller's EBP`这个位置的地址）压入栈中，并将`ebp`更新为`esp`（`esp`此时指向刚压入栈中的这个`ebp`），这样就完成了一个栈帧。

接着，就是`fun`函数内部的调用了，可能会将某些局部变量压入栈中，或者嵌套调用某个函数重复上述过程。

当`fun`函数调用完毕时，`esp`会不断增加来将参数出栈。可以想象，当`esp`和`ebp`指向了同一个栈帧时，说明`fun`函数中的内容都被出栈了。此时将`ebp`更新为这个栈帧中保存的地址（也就是`Caller's Caller's EBP`的地址），即可还原栈。



那么，上述就是调用函数时，整个调用栈中发生的过程了。那么我们现在来思考一下本练习的内容，我们如何计算出具体`ebp`的地址呢？

在这里仍然需要一个前置知识：

> 在x86架构中，栈是由一系列32位的字（word）组成的，每个字是4个字节。当我们说 `ebp+8` 时，我们实际上是指基指针（EBP）的地址加上8个字节。这里的单位是字节。

从上图来看，当函数调用发生的时候，`Argument #1 2 3`都处在比`EBP`更高的地址当中。由于一个"格子"的大小为4个字节，所以如果我们想要得到`Argument #1`，就需要通过`EBP + 8`的方式来得到这个参数。

而在`kdebug.c`以及相关文件提供的`read_ebp()`中，返回的是一个`uint32_t`类型的整数，而不是一个指针类型指向某个内存地址。因此在遍历栈的时候，还需要进行一些操作。

具体而言，`printStackframe`函数的实现为：

```c
void print_stackframe(void) {
     /* LAB1 YOUR CODE : STEP 1 */
     /* (1) call read_ebp() to get the value of ebp. the type is (uint32_t);
      * (2) call read_eip() to get the value of eip. the type is (uint32_t);
      * (3) from 0 .. STACKFRAME_DEPTH
      *    (3.1) printf value of ebp, eip
      *    (3.2) (uint32_t)calling arguments [0..4] = the contents in address (uint32_t)ebp +2 [0..4]
      *    (3.3) cprintf("\n");
      *    (3.4) call print_debuginfo(eip-1) to print the C calling function name and line number, etc.
      *    (3.5) popup a calling stackframe
      *           NOTICE: the calling funciton's return addr eip  = ss:[ebp+4]
      *                   the calling funciton's ebp = ss:[ebp]
      */
    uint32_t ebp = read_ebp();
    uint32_t eip = read_eip();
    for(int i = 0; i < 20; i++){
        cprintf("ebp:%08x eip:%08x args:", ebp, eip);
        uint32_t *args =  (uint32_t *)ebp + 2;
        for(int j = 0; j < 4; j++){
            cprintf("%08x ", args[j]);
        }
        cprintf("\n");
        print_debuginfo(eip - 1);
        eip = ((uint32_t *)ebp)[1];
        ebp = ((uint32_t *)ebp)[0];

        if(ebp == 0){
            break;
        }
    }
}
```

首先，我们得到了`ebp`和当前指令指针`eip`的`uint32_t`值。

然后，由于我们设置了栈中最多允许20层嵌套调用，因此我们来进行一个20次的循环来遍历函数栈。

在循环的开头，我们打印出当前的`ebp`和`eip`的值。

随后，我们将`ebp`加上`2 * sizeof(uint32_t)`个字节，也就是8个字节，使得`args`指针指向函数栈中调用函数的第1个参数的地址，并通过循环打印4个参数的地址。

值得注意的是，我们通过`uint32_t eip = read_eip();`获取了`eip`的地址，但是在执行该函数时，实际得到的是它的上一句`uint32_t ebp = read_ebp();`的地址。因此我们通过`print_debuginfo(eip - 1);`的方式来输出一些调试信息。

最后，我们通过`eip = ((uint32_t *)ebp)[1];`来得到调用函数的父函数的返回地址（即上图中的`Return Address`）。`ebp = ((uint32_t *)ebp)[0];`这条语句看上去好像是自身给自身赋值，但是仔细一想，它得到的其实是`*ebp`的地址，即上图中`Caller's Caller's EBP`的地址。

### 练习六

请完成编码工作和回答如下问题：

1. 中断描述符表（也可简称为保护模式下的中断向量表）中一个表项占多少字节？其中哪几位代表中断处理代码的入口？
2. 请编程完善kern/trap/trap.c中对中断向量表进行初始化的函数idt_init。在idt_init函数中，依次对所有中断入口进行初始化。使用mmu.h中的SETGATE宏，填充idt数组内容。每个中断的入口由tools/vectors.c生成，使用trap.c中声明的vectors数组即可。
3. 请编程完善trap.c中的中断处理函数trap，在对时钟中断进行处理的部分填写trap函数中处理时钟中断的部分，使操作系统每遇到100次时钟中断后，调用print_ticks子程序，向屏幕上打印一行文字”100 ticks”。

> 【注意】除了系统调用中断(T_SYSCALL)使用陷阱门描述符且权限为用户态权限以外，其它中断均使用特权级(DPL)为０的中断门描述符，权限为内核态权限；而ucore的应用程序处于特权级３，需要采用｀int 0x80`指令操作（这种方式称为软中断，软件中断，Tra中断，在lab5会碰到）来发出系统调用请求，并要能实现从特权级３到特权级０的转换，所以系统调用中断(T_SYSCALL)所对应的中断门描述符中的特权级（DPL）需要设置为３。

要求完成问题2和问题3 提出的相关函数实现，提交改进后的源代码包（可以编译执行），并在实验报告中简要说明实现过程，并写出对问题1的回答。完成这问题2和3要求的部分代码后，运行整个系统，可以看到大约每1秒会输出一次”100 ticks”，而按下的键也会在屏幕上显示。

> 在保护模式下，中断描述符表（IDT）中的每个表项称为门描述符（Gate Descriptor），通常有两种类型：中断门（Interrupt Gate）和陷阱门（Trap Gate）。每个门描述符占用8个字节（64位）。
>
> 在这8个字节中，中断处理代码的入口地址（即中断服务例程的地址）由以下几部分组成：
>
> 1. 偏移量的低16位：位于描述符的第0和第1字节。
> 2. 段选择器：位于描述符的第2和第3字节，用于指定中断处理程序代码所在的段。
> 3. 偏移量的高16位：位于描述符的第6和第7字节。
>
> 因此，中断处理代码的入口地址由这两部分偏移量和段选择器共同确定，它们指向了处理该中断所需执行的代码的确切位置。

## 第三章 连续内存管理

### 3.1 计算机体系结构和内存层次

**基本要求**：一个进程需要一块存储时分配，完成工作后收回
**基本结构**：首先分为物理存储和逻辑存储。

**物理存储**可以从计算机体系结构的三个重要模块入手：CPU、内存和I/O设备。

![img](.\images\CPU、内存及IO设备.png)

首先，最快速的设备是高速缓存。其大小虽然只有几KB到几十KB，但是其读写速度和CPU几乎一样快。高速缓存的使用是我们感觉不到的，因为其依赖硬件进行实现和调用。

其次就是内存，内存的基本单位是字节(`Byte`)，一个字节为8位(`bit`)。在旧式的32位操作系统中，一次内存读写大小就是32位(4字节)。CPU在查找要使用的数据时，如果高速缓存未命中，就会到内存中查找数据。

如果内存中也找不到我们需要的数据，则去到硬盘这样的`I/O`存储设备中查找，硬盘的速度相对来说是最慢的，需要毫秒级别的响应时间。

![img](.\images\不同设备的查找速度.png)

此外，我们需要考虑一个问题。在古早的年代，内存中需要运行的只有一个或数个程序，因此使用物理地址进行寻址来运行程序是可行的。然而，随着内存设备的发展，如果还要按照物理地址来寻址的话，一方面无法保证安全性，再者而言我们无法保证**某个程序一定放在物理地址为某一段的地方来执行**。因此就诞生了**逻辑地址**。

**逻辑地址空间**：我们希望我们各个进程使用的存储都相对性地低耦合，有一个比较清晰的逻辑结构。把线性的物理地址编号转换为抽象的逻辑内存结构的管理机制是MMU（Memory Manage Unit）。

**内存管理的核心目的**：抽象、保护、共享、虚拟化。

- **抽象**：抽象指的就是把物理地址空间映射到逻辑地址空间，这样编写程序的人无需关心自己的程序到底被放在内存中的什么地方。直接在对应的逻辑地址空间查找数据即可，操作系统会把逻辑地址转换为对应的物理地址去寻址。
- **保护**：每个程序都应该拥有自己独立的一段地址空间。A程序**通常情况下**不应该试图去访问B程序所在的地址空间，从而避免错误的操作。
- **共享**：操作系统也是运行在内存中的，且程序需要与其交互来实现系统调用等操作。如果只是简单的禁止程序访问除了自身所在地址空间以外的任何内容，就无法和操作系统交互了。而针对每一段地址空间都复制一段内核程序与用户程序进行交互又实属多此一举。
- **虚拟化**：有时候我们的内存中可能也不够放我们需要使用的数据，在这样的情况下就产生了虚拟内存。虚拟内存使得**程序能够拥有比实际内存空间更大的地址空间**。这是通过将内存中一段最近未使用的数据放到虚拟内存中，为内存腾出空间来做到的。

那么，如何去实现这些目标呢？内存管理提供了四种实现方法：重定位（relocation）、分段（segmentation）、分页（paging）、虚拟存储（virtual memory）。

- **重定位**：重定位指的就是将物理地址和逻辑地址相互映射的这个过程，其实就是将物理地址变成了段地址：偏移的形式。

- **分段**：程序在内存中的排列并不是一个完全连续的一段内容。而是通过分成代码、数据、堆栈段来做到的。这样的话每个段的大小就不会特别大了。在内存中也不一定是一个相邻的状态。

- **分页**：与分段不同，分段指的是在**一段逻辑地址空间**中，将地址空间划分为不同的段。而分页）则是一种物理内存管理技术，它将内存分为固定大小的页，每个页都有自己的物理地址。当程序需要更多内存时，操作系统可以简单地分配一个或多个空闲的页给程序。分页的主要优点是简化了内存管理，避免了内存碎片的问题。

  在实际的操作系统中，分段和分页通常会同时使用。例如，在x86架构的计算机中，操作系统首先将程序分为多个段，然后再将每个段分为多个页。这样做的好处是既能够反映程序的逻辑结构，又能够简化内存管理，同时还能够支持虚拟内存和内存保护等高级功能。

- **虚拟存储**：就是我们上面提到的虚拟化，不再过多赘述。

### 3.2 地址空间和地址生成

#### 3.2.1 地址空间的定义

物理空间地址：硬件支持的地址空间，起始地址为0，直到MAXsys。（例如，在32位地址总线的操作系统中，地址范围就是$[0, 2^{32}-1]$。这里的$2^{32}-1$就是`MAXsys`）。
逻辑地址空间：在CPU运行的进程看到的地址，起始地址同样为0，直到MAXprog。逻辑地址空间中的起始地址同样是一个逻辑地址，它可能对应的是物理地址中的某个位置（例如1000）。

#### 3.2.2 逻辑地址的生成

逻辑地址生成的步骤主要分为编译、汇编、链接、重定位。

首先，编译会将我们编写的的高级语言代码编译成汇编代码。假如我们在高级语言中编写了某个函数调用，函数名作为符号在编译成汇编语言时仍然保留符号名称。通过`jmp`或者`call`指令跳转到相应的汇编代码段中执行。

下一个阶段是汇编，汇编将汇编语言翻译成二进制的机器语言。此时汇编代码中的符号名会被翻译成对应的地址名，在汇编文件的头部会包含一个可以认为是函数表的东西，函数表中包含了这个文件中的各个函数所在位置相对于文件起始位置的偏移量。

再之后是链接，由于我们可能调用了不在这个文件中定义的某个函数，因此在链接阶段我们需要将多个文件包括其函数表在内进行链接。链接后不同的函数在文件中的相对位置又会发生变化，更新函数表的内容。

最后再进行一次重定位，将每个函数需要跳转的位置重新进行一次描述。

> 逻辑地址的生成过程确实包括编译、汇编、链接和重定位这四个步骤。这是一个从高级语言代码到可执行机器代码的转换过程，涉及到的各个步骤都是为了解决代码中的符号引用和地址定位问题。
>
> 1. 编译：编译器将源代码（高级语言）转换为汇编代码。在这个过程中，编译器会进行词法分析、语法分析、语义分析和优化等操作。
>
> 2. 汇编：汇编器将汇编代码转换为机器代码（目标代码）。在这个过程中，汇编器会将汇编指令转换为机器指令，并将符号地址转换为相对地址。
>
> 3. 链接：链接器将多个目标文件链接成一个可执行文件。在这个过程中，链接器会解决外部符号引用问题，并将相对地址转换为绝对地址。
>
> 4. 重定位：在程序加载到内存运行时，加载器会进行重定位操作，将程序中的绝对地址转换为实际的物理地址。
>
> 这四个步骤是逻辑地址生成的基本过程，但在实际的系统中，可能还会涉及到其他的一些操作，比如动态链接、动态加载等。
>
>
> 在链接阶段，多个目标文件（object files）被合并成一个单一的可执行文件。在这个过程中，链接器会处理所有的符号定义和引用，确保每个符号都被正确地解析到其在最终可执行文件中的地址。
>
> 链接器的工作可以简化为以下几个步骤：
>
> 1. **地址和空间分配**：链接器会为每个目标文件分配地址空间。它会根据每个目标文件的大小和需要的对齐方式来确定它们在最终可执行文件中的位置。
>
> 2. **符号解析**：链接器会查看所有目标文件，解析出所有的符号引用，将外部符号引用与其定义关联起来。如果一个符号在一个目标文件中被引用，在另一个目标文件中被定义，链接器会解析这些引用，确保它们指向正确的地址。
>
> 3. **重定位**：链接器会调整代码和数据中的地址引用，使它们指向正确的位置。这包括将相对地址转换为绝对地址，即相对于可执行文件起始地址的偏移。
>
> 在链接后的可执行文件中，所有的地址都是相对于可执行文件的起始地址的偏移量，这个起始地址在文件被加载到内存时通常是一个基地址，这时候操作系统的加载器会进一步将这些地址转换为实际的物理地址或虚拟地址。这个过程称为加载时重定位。

##### 3.2.2.1 地址生成的时机和限制

- 如果**起始地址已知**，则地址在**编译时生成**，起始地址改变必须重新编译
- 编译时**起始位置未知**，编译器需要生成可重定位的代码，**加载时生成**绝对地址
- 也可以在**执行时生成**地址，执行时代码可移动，需地址转换硬件支持

不同的系统里，这几种方法均有采用。

##### 3.2.2.2 地址生成过程

ALU（算术逻辑单元）所需要的地址是逻辑地址，但向内存中取用时，需要的是物理地址。

CPU中依靠MMU进行一次逻辑到物理地址的转换。虽然这是硬件完成的，但是操作系统提供两者之间的关系的描述（这是页表的功劳）

而后还要进行地址检查，防止超过段长度。加上段基址完成重定位即可。

### 3.3 连续内存分配算法

#### 3.3.1 概念

- 连续内存分配：给进程分配一块不小于指定大小的连续物理内存区域。
- 内存碎片：不能被利用的空闲内存，分为外部碎片和内部碎片。
- 外部碎片：分配单元之间的未被利用内存。例如我们有3个进程，分别使用了4字节、2字节、8字节。现在第二个进程结束了，中间这两个字节可能就会成为外部碎片。如果后续申请的内存大于2个字节，那么这个2字节内存无法被利用。
- 内部碎片：分配单元内部的未被使用内存，取决于分配单元大小是否要取整。例如进程要求50字节，实际上为了保持4字节对齐分配了52字节。那么分配区域中最后2字节无法被利用。

#### 3.3.2 动态分配策略

##### **最先分配策略**：（first-fit）

- 直接选用第一个够用的分区。
- **优点**：简单，且高地址处会有大块的分区
- **缺点**：是会产生外碎片，且分配大块时需要搜索较长时间

##### **最优分配策略**（best-fit）：

- **申请**：空闲分区列表从小到大排序，搜索一个比它大但最小的分区，分区利用率最高
- **释放**：释放时要在空闲分区中查找相邻空闲分区，较慢
- **外碎片**：避免大分区拆分，减小外碎片大小，简单，但同时外碎片难以利用

##### **最差分配策略**：

- 与最优策略对应，空闲分区由大到小排。
- **优点**：中等大小分配较多时效果较好，避免出现太多的小碎片
- **缺点**：释放空间较慢；大分区被破坏掉，而后难以分配较大的空间

#### 3.4 碎片整理算法

在前述的各种内存分配策略下，总会产生大大小小的内存碎片。如果此时我们要求得到一块较大的连续内存，而内存中已无足够大小的连续内存可用，则需要进行碎片整理以得到足够大小的内存。通常的碎片整理算法有**紧凑分区**和**分区置换**这两种方法。

**紧凑分区**：

- **定义**：通过**移动**分配给进程的内存分区，以合并外部碎片。
- **条件**：所有的应用可以动态重定位。也就是说，如果进程中包含了绝对地址，那么如果对进程进行移动。那么该绝对地址就会成为一个错误的引用，因此要求进行移动的进程中的所有地址都是可动态重定位的。
- **问题**：进程等待时移动，所移动的进程必须处于等待状态。且移动进程会产生开销。

**分区对换**：

- **定义**：通过抢占并回收出于等待状态进程的分区，从而增大可用内存空间。
- 类似windows的虚拟内存机制，相等于将一部分外存用作内存，.swp文件就来源于分区对换（swapping）
- 早期多进程实现方式。

### 3.5 伙伴系统

伙伴系统（buddy system）就是采用二分的思路进行占用率相对较高的分配。

在最初未进行内存分配时，将空闲内存的中空闲块的大小认为是2的整数次幂。也就是说假设有1028KB的空闲内存，也认为是1024KB的空闲内存。

将空闲内存块以`free[size][start_address]`的形式存放在二维数组中，第一维表示空闲块的大小，第二维表示空闲块的起始地址。

每次我们请求一个内存块时，分配的原则是：**找到一个空闲块，如果它的大小大于请求大小的2倍，则将空闲块对半分为两块。从分好后的第一个空闲块中继续以上步骤。直到满足该空闲块大小足够又不大于请求大小的2倍，将这个空闲块直接分配**。

![img](.\images\伙伴系统的内存分配.jpg)

回收时也需要注意一点：**如果回收时相邻的内存中也包含了空闲块，不代表一定能进行合并，除非合并后的大小也是2的整数次幂(这一要求其实变相说明合并前两块大小相同)，且满足要合并的相邻的两块内存的第一块的起始地址是2的整数次幂。**

为什么要满足**要合并的相邻的两块内存的第一块的起始地址是2的整数次幂**？请看下图：

![img](.\images\伙伴系统内存合并.jpg)

假设D块的内存被回收，如果不考虑上述要求，那么它和左右两块任意一块都能合并。但是实际上，<font color="red">如果D块内存回收后与左边的块进行合并，那么合并后的512KB永远不能和右边的256KB继续合并了。</font>这就造成如果我要申请一块大于512KB的内存（例如700KB），那么我永远无法满足这一要求，即便我把A、C也回收了也只会形成256、512、256这样的三个空闲块，分不了700KB内存。

因此上述这个条件也是必须满足的。
