# 笔记

## 第一章 操作系统概述

本课程为清华大学操作系统课程，主要讲述以下模块：

- 中断和系统调用：中断是软件和硬件的联结，而系统调用是应用软件和系统软件的联结。
- 内存管理：负责调度内存资源，包括物理内存和虚存。
- 进程和线程：负责程序运行过程的调度
- CPU调度：进程共用处理器时的时间共享
- 进程间通信：同步互斥
- 文件系统：组织文件，便于读写和查找
- I/O子系统：使用较为统一性的接口对不同的外设兼容

### 1.1 操作系统定义

- 操作系统可以看作是一种控制程序，控制各个程序的执行，以防止不当的使用并为使用者提供服务。
- 操作系统可以看作是软件和硬件之间的中间层，它协调软硬件之间的通信并完成相应的任务。

操作系统是一种系统软件，它对外提供的接口是`Shell`和`GUI`。

操作系统的内核包含以下特征：

- 并发：多个程序同时运行
- 共享：宏观上程序共享CPU，微观上它们之间是互斥的，CPU不存在真正的意义上的同步。
- 虚拟：使用多道程序技术，让每个用户都感到自己被单独服务。
- 异步：保证异步程序执行的正确性（比如，当一个程序在运行过程中时间片耗尽而进入等待，操作系统需要保存它当前的状态并能够在下次执行时能在正确的状态下）。

### 1.2 操作系统的难点

- 代码量大
- 并发性和琐碎的调度算法的挑战。
- 高效性、低耗性、稳定性需求，具有一定的硬件编程的性质。
- 锁的问题：操作系统底层必须互斥
- 权衡：时间-空间、性能和可预测性、公平和性能等
- 管理**原始**硬件：中断、异常、上下文切换、TLB和页表、汇编语言

### 1.3~1.5 重点

这部分描述了操作系统的发展流程，具体百度即可。

操作系统的结构也分为好几种：

- 分层结构，逐层向上进行封装。
- 微内核结构，应用程序直接和内核功能进行交互。
- 外核结构，将部分物理资源分给多个程序，让每个程序决定如何处理这些资源。（虚拟机就是一种外核结构）

### 额外知识：CPU的运行模式

实模式（Real Mode）和保护模式（Protected Mode）是指中央处理器（CPU）的两种不同的运行模式，主要存在于Intel x86架构的处理器中。

**实模式：**
实模式是最初的8086和8088处理器所运行的模式，也是所有x86处理器在启动时的默认模式。在实模式下，CPU寻址是直接的，它使用20位地址总线，可以直接访问1MB的内存空间。实模式不支持高级的内存管理功能，如分页或内存保护。由于没有内存保护，任何程序都可以访问任何内存地址，这就意味着一个程序可以轻易地干扰另一个程序的运行，导致系统不稳定。

**保护模式：**
保护模式首次出现在80286处理器中，它提供了更高级的内存管理能力。在保护模式下，CPU使用32位（或在更现代的处理器中使用64位）地址总线，可以访问超过1MB的内存。保护模式引入了分段和分页机制，允许操作系统实现进程间的内存隔离，从而提高了系统的稳定性和安全性。此外，保护模式支持多任务处理，允许多个程序同时运行，而不会互相干扰。

**其他模式：**

- **虚拟8086模式：** 这是保护模式下的一个特殊模式，允许保护模式的操作系统在一个受保护的环境中运行实模式程序。这种模式常用于运行旧的DOS程序。

- **长模式（Long Mode）：** 这是在64位x86处理器上运行的模式，它支持64位的内存寻址，可以访问更大的内存空间。长模式同时支持运行32位和64位的应用程序。

- **系统管理模式（System Management Mode, SMM）：** 这是一种特殊的操作模式，用于处理系统级的功能，如电源管理和硬件控制。这个模式通常对操作系统是不可见的。

- **无管理模式（Unreal Mode）：** 这不是官方的CPU模式，而是通过对实模式的一些操作来扩展访问超过1MB内存的非正式模式。

每种模式都有其特定的用途和操作环境，随着计算机硬件的发展，新的模式和功能不断被引入以满足现代计算的需求。

## 第二章 启动、中断、异常和系统调用

### 2.1 计算机系统的启动过程

<font color="red">cpu加电后，执行的第一条指令在**内存**中。</font>

但是作为一个随机读写存储器（RAM），我们早就学过它的特点就是断电后丢失数据，那么哪来的指令让cpu去读呢？cpu为什么知道要去内存读呢？

这里课程里讲的真没听太懂，完整介绍流程在<[BIOS固件-电脑开机的启动流程 - tyong - 博客园 (cnblogs.com)](https://www.cnblogs.com/tyong/articles/10141205.html)>。这里给出个人理解的流程：
$$
BIOS\rightarrow硬件自检\rightarrow启动顺序\rightarrow存储设备
\\
\rightarrow主引导记录\rightarrow分区表\rightarrow活动分区\rightarrow卷引导记录
\\
\rightarrow启动管理器\rightarrow列出可启动的操作系统供用户选择\rightarrow加载操作系统
$$
计算机的整个启动过程分为四个阶段：

#### 第一阶段：BIOS

上个世纪70年代初，"只读内存"（read-only memory，缩写为ROM）发明，开机程序被刷入ROM芯片，计算机通电后，第一件事就是读取它。

这块芯片里的程序叫做"基本输入输出系統"（Basic Input/Output System），简称为BIOS。

##### 硬件自检

BIOS程序首先检查，计算机硬件能否满足运行的基本条件，这叫做"硬件自检"（Power-On Self-Test），缩写为POST。

如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止。如果没有问题，屏幕就会显示出CPU、内存、硬盘等信息。

##### 启动顺序

硬件自检完成后，BIOS把控制权转交给下一阶段的启动程序。

这时，BIOS需要知道，"下一阶段的启动程序"具体存放在哪一个设备。也就是说，BIOS需要有一个外部储存设备的排序，排在前面的设备就是优先转交控制权的设备。这种排序叫做"启动顺序"（Boot Sequence）。

打开BIOS的操作界面，里面有一项就是"设定启动顺序"。

#### 第二阶段：主引导记录


BIOS按照"启动顺序"，把控制权转交给排在第一位的储存设备。

这时，计算机读取该设备的第一个扇区，也就是读取最前面的512个字节。如果这512个字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给"启动顺序"中的下一个设备。

这最前面的512个字节，就叫做"主引导记录"（Master boot record，缩写为MBR）。

> 0x55 和 0xAA 是两个十六进制数，分别对应于十进制的 85 和 170。在计算机中，这两个数通常作为主引导记录（MBR，Master Boot Record）的最后两个字节，用来标识一个有效的引导扇区。
>
> MBR 是硬盘的第一个扇区（通常是 512 字节），它包含了启动计算机操作系统所需的代码和分区表。MBR 的结构通常如下：
>
> - 引导代码（Boot code）：这部分包含了一些基本的代码，用于启动计算机。
> - 分区表（Partition table）：描述硬盘分区的信息。
> - 签名字节（Signature bytes）：0x55 和 0xAA，位于扇区的最后两个字节（第 511 和第 512 字节）。
>
> 使用 0x55 和 0xAA 作为标识符的原因主要是历史和传统。这两个字节作为“魔术数字”（magic numbers），在早期的IBM PC 兼容机中被用来标识一个扇区是否是可引导的。这个约定被广泛接受，并成为了行业标准。选择这两个特定的值可能是因为它们的位模式（0x55 = 01010101b，0xAA = 10101010b）在某种程度上是互补的，这种模式可能有助于错误检测。
>
> 在计算机引导过程中，BIOS（基本输入输出系统）会检查连接的存储设备的第一个扇区的最后两个字节，如果这两个字节是 0x55 和 0xAA，BIOS 就会认为这是一个有效的引导扇区，并从中加载引导代码来启动操作系统。如果这两个字节不是 0x55 和 0xAA，BIOS 将认为该扇区不是一个有效的引导扇区，将不会从该设备启动，并会继续检查其他设备。
>
> <font color="blue">Question:</font>    假如我的启动顺序最前面是光盘，然后是硬盘。但是在启动计算机时，我并没有放入光盘。那计算机究竟是跳过光盘启动还是说有什么办法知道没有光盘，接着从硬盘尝试读主引导记录并启动？
>
> <font color="green">Answer:</font>    当计算机启动时，BIOS（基本输入输出系统）会根据设置的启动顺序来检查每个设备是否包含可启动的媒体。如果您的启动顺序中光盘驱动器排在硬盘之前，BIOS会首先检查光盘驱动器。
>
> 如果光盘驱动器中没有光盘，或者光盘不是一个启动盘，BIOS会检测到光盘驱动器中没有可启动的媒体。这通常是通过尝试读取光盘的启动扇区来完成的。如果读取失败或者启动扇区不包含有效的启动签名（例如，不包含0x55和0xAA这样的魔术数字），BIOS会认为光盘驱动器不包含有效的启动记录。
>
> 在确认光盘驱动器中没有可启动媒体之后，BIOS会继续按照启动顺序检查下一个设备，也就是硬盘。然后，BIOS会尝试从硬盘的主引导记录（MBR）读取启动信息。如果硬盘的MBR是有效的（即包含正确的启动签名），BIOS会从硬盘加载MBR中的引导代码，并开始操作系统的启动过程。
>
> 如果所有配置的启动设备都没有找到可启动的媒体，BIOS通常会显示一条错误消息，例如“No bootable device”或“Insert boot media in selected boot device and press a key”，提示用户没有找到可启动的设备。

##### 主引导记录的结构

"主引导记录"只有512个字节，放不了太多东西。它的主要作用是，告诉计算机到硬盘的哪一个位置去找操作系统。

主引导记录了由三个部分组成：

1. 第1~446字节：446字节，调用操作系统的机器码
2. 第447~510字节：64字节，分区表（Partition table）
3. 第511~512字节：主引导记录签名（0x55和0xAA）

其中，第二部分"分区表"的作用，是将硬盘分成若干个区。

##### 分区表

考虑到每个区可以安装不同的操作系统，"主引导记录"因此必须知道将控制权转交给哪个区。

分区表的长度只有64个字节，里面又分成四项，每项16个字节。所以，一个硬盘最多只能分四个一级分区，又叫做"主分区"。

每个主分区在分区表中的大小均为16字节，分为6个部分：

1.  第1个字节：如果为0x80，就代表该主分区是激活分区，控制权要转交给这个分区。四个主分区里面只能有一个是激活的。
2.  第2~4字节：主分区第一个扇区的物理位置（柱面、磁头、扇区号等）。
3.  第5个字节：主分区类型。
4.  第6~8字节：主分区最后一个扇区的物理位置。
5.  第9~12字节：该主分区的第一个扇区的逻辑地址。
6.  第13~16字节：主分区的扇区总数。

最后的四个字节（"主分区的扇区总数"），决定了这个主分区的长度。也就是说，一个主分区的扇区总数最多不超过2的32次方。

如果每个扇区为512个字节，就意味着单个分区最大不超过2TB。再考虑到扇区的逻辑地址也是32位，所以单个硬盘可利用的空间最大也不超过2TB。如果想使用更大的硬盘，只有2个方法：一是提高每个扇区的字节数，二是增加扇区总数。

> 你提到的内容是关于传统的MBR（Master Boot Record）分区表的结构和限制。MBR是硬盘的一种分区方案，它存在于硬盘的最前面，是硬盘启动的关键所在。MBR中包含了启动代码和分区表信息，而分区表就是用来记录硬盘分区情况的数据结构。
>
> 你的描述非常准确，MBR分区表中确实只有64个字节用于描述分区，分成四个16字节的分区表项，每个表项描述一个主分区。这里的限制是每个硬盘最多只能有四个主分区，或者三个主分区加一个扩展分区。扩展分区可以被进一步分割成多个逻辑分区。
>
> 关于MBR的限制，你提到了两个主要的点：
>
> 1. 单个分区大小的限制：由于分区表中记录扇区总数的字段是一个32位的数，所以最大值是$2^{32-1}$个扇区。如果每个扇区大小为512字节，那么最大数量分区情况下总大小为$512 * 2^{32}$字节，即`2TB`。
>
> 2. 硬盘大小的限制：由于MBR使用32位地址来记录扇区位置，所以它最多只能寻址到2^32个扇区，这同样限制了硬盘的最大大小为2TB（如果扇区大小为512字节）。
>
> 为了解决这些限制，现代计算机系统通常使用GPT（GUID Partition Table）分区方案。GPT不受MBR的这些限制，因为它使用64位的地址来记录扇区位置，这使得理论上的最大分区和硬盘大小可以达到ZB（Zettabytes）级别，远远超过了当前硬盘技术的容量。
>
> 此外，GPT分区表存储在硬盘的前面和后面，提供了冗余保护，即使一部分数据损坏，也能恢复分区信息。GPT还包含了对分区的名称和类型的描述，以及其他的一些先进特性，使得它成为了大容量硬盘的首选分区方案。

在硬盘上，分区格式的信息是存储在硬盘的前面几个扇区中的。对于MBR和GPT分区格式，这些信息的存储方式有所不同：

1. **MBR（Master Boot Record）**：在MBR分区格式中，分区信息存储在硬盘的第一个扇区（通常称为扇区0）。这个扇区包含了启动代码（Bootstrap Code）、分区表和一个有效性标志（通常是0x55AA）。BIOS在启动过程中会读取这个扇区，并根据其中的代码和分区表来加载操作系统。

2. **GPT（GUID Partition Table）**：GPT分区格式采用了不同的方式。它在硬盘的第一个扇区也存储了一个保护性MBR（Protective MBR），这是为了向后兼容那些只能识别MBR的工具。保护性MBR的分区表只包含一个条目，这个条目占据了整个硬盘，但实际上并不用于分区。真正的GPT头部信息是存储在硬盘的第二个扇区，它包含了GPT分区表的位置、大小和循环冗余校验（CRC）校验值等信息。GPT分区表本身则紧随GPT头部信息之后。

对于BIOS和GPT的兼容性问题，事实上传统的BIOS并不支持GPT分区格式。BIOS是在UEFI之前的固件标准，它只能识别MBR分区表。如果你的计算机使用的是传统的BIOS固件，那么它无法直接从GPT分区的硬盘启动操作系统。

相反，UEFI（Unified Extensible Firmware Interface）是一种现代的固件接口标准，它支持GPT分区格式。UEFI在启动时会读取GPT的头部信息，确定分区表的位置，然后根据分区表加载EFI系统分区（ESP），ESP包含了用于启动操作系统的EFI应用程序（如引导加载程序）。

因此，如果你的硬盘使用GPT分区，并且你希望从该硬盘启动操作系统，你需要确保你的计算机使用的是UEFI固件，而不是传统的BIOS。现代计算机通常都支持UEFI，并且默认使用UEFI模式。在UEFI模式下，计算机可以识别GPT分区格式，并从中启动操作系统。

> <font color="blue">question:</font>    "保护性MBR的分区表只包含一个条目，这个条目占据了整个硬盘"，这是什么意思？
>
> <font color="green">answer:</font>    保护性MBR（Protective MBR）是GPT（GUID Partition Table）分区方案的一部分，它位于硬盘的第一个扇区，也就是传统MBR的位置。保护性MBR的目的是为了保护GPT分区的硬盘免受不支持GPT的旧式系统和工具的干扰。
>
> 在保护性MBR中，分区表通常只包含一个条目，这个条目的类型被设置为0xEE，这是一个特殊的分区类型，用来指示整个硬盘或者一个很大的区域已经被GPT占用。这个条目并不指向实际的文件系统或数据分区，而是作为一个标记存在，告诉任何可能读取MBR的软件：“这个硬盘使用的是GPT分区方案，你不应该试图用MBR的方式来管理它。”
>
> 这个条目通常会从硬盘的第一个可用扇区开始，直到硬盘的最后一个扇区，覆盖整个硬盘的范围。这样做的目的是为了防止不支持GPT的系统和工具错误地认为硬盘未分区，并试图在硬盘上创建新的MBR分区，这可能会导致数据丢失。
>
> 因此，保护性MBR是一种兼容性措施，确保了GPT分区的硬盘在旧系统中不会被误操作，同时允许支持GPT的系统正确识别和使用硬盘。真正的GPT分区信息存储在硬盘的其他位置，通常是从第二个扇区开始的GPT头部，紧接着是分区表本身。
>
> 
>
> <font color="blue">question:</font>    也就是说，假设我在旧式的BIOS上读取了一块硬盘，而这块硬盘采取的是GPT格式的分区方式。BIOS会尝试读取扇区0，然后读取到0xEE，它会认为这不是一个激活分区。因此它会跳过这个硬盘尝试去别的硬件上寻找系统。
>
> <font color="green">answer:</font>    是的，您的理解基本正确。在旧式的BIOS系统中，当BIOS尝试读取采用GPT格式分区的硬盘时，它会首先检查扇区0，也就是MBR所在的位置。在这种情况下，它会发现保护性MBR，其中包含一个类型为0xEE的分区条目，这个条目覆盖整个硬盘。
>
> BIOS会识别到这个特殊的分区类型，但由于BIOS不支持GPT，它不会理解这个分区条目的真实含义。BIOS可能会认为这个硬盘不包含任何有效的可启动分区，因为0xEE类型的分区不是一个可启动的分区类型。因此，BIOS不会从这个硬盘启动操作系统，而是会继续搜索其他可能包含有效MBR和可启动分区的硬盘或启动设备。
>
> 这就是保护性MBR的作用：它防止了BIOS基于错误的假设（即硬盘使用MBR分区表）对硬盘进行操作，同时也向BIOS表明这个硬盘使用了一种它不理解的分区方案。这样可以减少数据损坏的风险，并确保只有支持GPT的系统（如UEFI固件）才能管理和启动这个硬盘上的操作系统。

#### 第三阶段： 硬盘启动

到了这个时期，计算机的控制权就要转交给硬盘的某个分区了，这里又分成三种情况。

##### **情况1：卷引导记录**

上一节提到，四个主分区里面，只有一个是激活的。计算机会读取激活分区的第一个扇区，叫做"卷引导记录"（Volume boot record，缩写为VBR）。

"卷引导记录"的主要作用是，告诉计算机，操作系统在这个分区里的位置。然后，计算机就会加载操作系统了。

##### **情况2：扩展分区和逻辑分区**

随着硬盘越来越大，四个主分区已经不够了，需要更多的分区。但是，分区表只有四项，因此规定有且仅有一个区可以被定义成"扩展分区"（Extended partition）。

所谓"扩展分区"，就是指这个区里面又分成多个区。这种分区里面的分区，就叫做"逻辑分区"（logical partition）。

计算机先读取扩展分区的第一个扇区，叫做"扩展引导记录"（Extended boot record，缩写为EBR）。它里面也包含一张64字节的分区表，但是最多只有两项（也就是两个逻辑分区）。

计算机接着读取第二个逻辑分区的第一个扇区，再从里面的分区表中找到第三个逻辑分区的位置，以此类推，直到某个逻辑分区的分区表只包含它自身为止（即只有一个分区项）。因此，扩展分区可以包含无数个逻辑分区。

但是，似乎很少通过这种方式启动操作系统。如果操作系统确实安装在扩展分区，一般采用下一种方式启动。

##### **情况3：启动管理器**

在这种情况下，计算机读取"主引导记录"前面446字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的"启动管理器"（boot loader），由用户选择启动哪一个操作系统。

#### 第四阶段：操作系统

控制权转交给操作系统后，操作系统的内核首先被载入内存。

以Linux系统为例，先载入/boot目录下面的kernel。内核加载成功后，第一个运行的程序是/sbin/init。它根据配置文件（Debian系统是/etc/initab）产生init进程。这是Linux启动后的第一个进程，pid进程编号为1，其他进程都是它的后代。

然后，init线程加载系统的各个模块，比如窗口程序和网络程序，直至执行/bin/login程序，跳出登录界面，等待用户输入用户名和密码。

**至此，全部启动过程完成。**

<font color="red">总结上述内容，一个计算机的启动过程大致描述为：首先，在cpu通电后，它会初始化一些自身包含的寄存器以及主板上的一些ROM，这些内容共同构成了BIOS（基本输入输出系统）。然后，BIOS会进行硬件自检，检查必要的硬件设备（内存、显卡）是否正常工作，计算机是否满足基本的运行条件。<br><br>然后，BIOS中保存了一个"启动顺序"，它按照启动顺序从外部硬件设备中尝试读入操作系统内核。例如，启动顺序第一位的是硬盘，BIOS会尝试读取硬盘的第一个扇区（扇区0），检查其是否以`0x55`、`0xAA`结尾（判断它是不是主引导记录。注意，这是MBR格式分区的硬盘的读取方式。新的GPT分区格式读取又有区别）。<br><br>在它找到主引导记录后，BIOS又需要读主引导记录中保存的分区表的信息，确定哪个主分区是以`0x80`为第一个字节，这个分区称为激活分区。计算机的控制权转交给这个分区。<br><br>随后，又要根据不同的情况（卷引导记录、扩展分区和逻辑分区、启动管理器等）选择不同的启动方式。<br><br>最后，成功找到了操作系统在外部存储设备中的位置。首先加载操作系统内核，随后启动进程以及各个模块。整个操作系统至此就成功启动了。</font>

> 上述描述对操作系统启动流程的概述是正确的，但可以进一步细化和补充一些细节：
>
> 1. **CPU复位和自检**：在通电后，CPU会执行一个复位操作，这通常涉及到读取内存地址0xFFFFFFF0处的内容，这是因为在x86架构中，这个地址映射到BIOS的起始位置。CPU从这个位置开始执行指令，进入BIOS。
>
> 2. **BIOS初始化**：BIOS会进行POST（Power-On Self Test，加电自检），检查系统硬件配置，如CPU、内存、键盘、驱动器等，并可能显示一些基本的系统信息。
>
> 3. **启动设备检测**：BIOS会根据预设的启动顺序检查各个启动设备，如硬盘、光驱、USB设备等。
>
> 4. **MBR或GPT读取**：对于MBR（Master Boot Record）格式的硬盘，BIOS会读取硬盘的第一个扇区，检查`0x55`和`0xAA`这两个字节来确认MBR的有效性。对于GPT（GUID Partition Table）格式的硬盘，启动流程稍有不同，BIOS或UEFI（Unified Extensible Firmware Interface，统一的可扩展固件接口）会读取EFI系统分区来加载操作系统。
>
> 5. **引导加载器**：在MBR中，BIOS会加载并执行主引导记录中的代码，这通常会引导到一个引导加载器，如GRUB或Windows Boot Manager。对于GPT分区表，UEFI会加载EFI系统分区中的EFI应用程序（如引导加载器）。
>
> 6. **操作系统加载**：引导加载器会加载操作系统内核到内存中，并将控制权交给操作系统。操作系统接管后，会继续加载系统驱动和服务，最终进入用户界面。
>
> 补充说明：
>
> - 在现代计算机中，BIOS已经逐渐被UEFI所取代，UEFI提供了更加丰富的界面和功能，支持更大的硬盘以及更快的启动速度。
> - 在UEFI模式下，通常使用GPT分区表，而在传统的BIOS模式下，使用MBR分区表。
> - 在某些系统中，还可能有一个快速启动的功能，这通常是通过将系统状态保存到一个文件中，在下一次启动时直接读取该文件来实现快速启动的。
>
> 这些补充信息提供了更全面的视角来理解计算机启动的过程。

#### 额外知识：cpu的代码段寄存器和当前指令指针

根据俗成的约定，在cpu完成初始化加载后。它的代码段寄存器（CS）和当前指令指针（IP，32位称EIP，64位称RIP）指向预设的物理地址。

根据传统的BIOS启动流程，当cpu复位时，CS寄存器为`0xffff`，IP寄存器为`0x00`。这个组合会将cpu的执行指向物理内存地址`0xFFFF0`（CS寄存器的值乘以16加上IP寄存器的值，即`0xFFFF0 = 0XFFFF * 16 + 0X0000`）.

这个地址位于系统的ROM BIOS中，紧靠1MB地址空间的顶端（在一个1MB的地址空间中，最高的16字节）。这里通常存放的是BIOS启动代码的跳转指令，它会将CPU的控制权转移到BIOS的主体部分，开始执行系统的自检和初始化过程。

这样设计的原因是为了确保计算机在启动时能够找到一个固定的位置开始执行代码，因为在计算机启动时内存中还没有加载操作系统或其他程序。通过将控制权交给BIOS，计算机可以进行硬件初始化和引导过程，最终加载操作系统。

在UEFI（统一可扩展固件接口）系统中，启动过程有所不同，但基本原理相似：UEFI固件存储在主板上的一个芯片中，计算机启动时会执行该固件中的代码来初始化硬件并引导操作系统。

> 我还有一些疑问，为什么"这个组合会将cpu的执行指向物理内存地址`0xFFFF0`（CS寄存器的值乘以16加上IP寄存器的值，即`0xFFFF0 = 0XFFFF * 16 + 0X0000`）"为什么要将CS寄存器的值乘以16再相加？
> 还有一个问题是，它指向了1MB地址空间的顶端，这个1MB地址空间是做什么用的？指令的执行是自顶向下的吗？
>
> 
>
> 您的问题涉及到x86架构的实模式内存寻址方式，以及BIOS在系统启动时的内存布局。我来逐一解答：
>
> ### 为什么要将CS寄存器的值乘以16再相加？
>
> 在x86架构的实模式下，物理地址是通过段地址和偏移地址组合而成的。段地址（存储在段寄存器中）需要乘以16（或左移4位）来得到基础地址，然后加上偏移地址（存储在指令指针寄存器中）来得到最终的物理地址。这种寻址方式称为段:偏移寻址。
>
> 这样设计的初衷是为了在16位处理器上扩展内存寻址能力。在16位处理器中，一个寄存器只能存储16位的值，最大只能直接寻址64KB的内存。通过将16位的段地址乘以16，再加上16位的偏移地址，可以寻址高达1MB的内存空间（2^20字节）。
>
> 所以，当CS寄存器为0xFFFF时，乘以16（或左移4位）得到的基础地址是0xFFFF0。加上IP寄存器的值0x0000，得到的物理地址仍然是0xFFFF0。
>
> ### 这个1MB地址空间是做什么用的？
>
> 在实模式下，CPU可以寻址的最大内存空间是1MB。这个1MB的内存空间不仅包括RAM，还包括了其他类型的内存，如BIOS ROM、视频内存、以及其他I/O设备的内存映射区域。这个空间的布局大致如下：
>
> - 0x00000 - 0x9FFFF：常规RAM（640KB）
> - 0xA0000 - 0xBFFFF：视频内存区域
> - 0xC0000 - 0xFFFFF：系统BIOS和其他固件（包括视频BIOS、网络卡BIOS等）
>
> 在这1MB的空间中，顶端的区域（通常是0xF0000 - 0xFFFFF）被保留给系统BIOS使用。这是因为在早期的PC设计中，BIOS需要在一个固定的位置，以便CPU在启动时可以找到并执行它的代码。
>
> ### 指令的执行是自顶向下的吗？
>
> 指令的执行顺序并不是由物理地址的高低决定的，而是由程序的控制流决定的。CPU从BIOS固件的预设入口点（0xFFFF0）开始执行指令，然后按照指令本身的逻辑顺序执行。这些指令可能会跳转到BIOS中的其他部分，或者在执行完必要的初始化后，跳转到引导扇区的代码，最终引导操作系统的加载。
>
> 
>
> 
>
> 那么也就是说，代码段寄存器和当前指令指针初始化时得到的并不是物理地址。而是段地址加偏移地址，因此需要计算将其还原为物理地址。第二个问题我的理解是，现代工业厂家设计的内存条大多都符合了这个约定，预留了1MB的地址空间（实际上这个空间中并不一定有数据，只是把地址预留出来）。这些地址指向了一些外部的硬件设备，cpu直接执行它们的代码并跳转或将控制权移交。第三个问题我的理解是，虽然0xffff0是第一条指令所在的地址。但是这条指令的作用可能是将cpu控制权移交给bios，接下来去什么地址读取执行命令由bios决定。
> 我的理解对吗？
>
> 
>
>
> 您的理解基本上是正确的，但让我稍微澄清一下：
>
> ### 关于物理地址和段:偏移地址
>
> 在x86实模式下，物理地址确实是由段地址和偏移地址组合而成的。CPU在启动时，代码段寄存器（CS）和指令指针（IP）提供了一个初始的段:偏移组合，这需要转换成物理地址才能访问内存。这个转换是通过将段地址乘以16（或左移4位），然后加上偏移地址来完成的。因此，物理地址是由这个计算得到的，而不是直接由CS和IP的值决定的。
>
> ### 关于1MB地址空间的预留
>
> 在早期的PC设计中，1MB地址空间的布局是由工业标准决定的，确实预留了一部分空间给系统BIOS和其他固件。这个空间中的一些区域可能没有物理RAM对应，但它们被映射到了其他类型的存储器或设备。例如，BIOS固件存储在主板上的非易失性存储器中，而不是在RAM内存条中。因此，当CPU访问这些特定的地址时，它实际上是在读取或写入这些设备的存储器，而不是RAM。
>
> ### 关于BIOS的控制权
>
> 当CPU在启动时执行位于物理地址0xFFFF0的指令时，这通常是一个跳转指令，它会将CPU的控制权转移到BIOS固件中的其他位置，开始执行BIOS的初始化代码。BIOS代码负责进行硬件检测、初始化，并最终找到启动设备（如硬盘）上的引导扇区，从而加载引导代码并最终引导操作系统。因此，BIOS决定了在完成自身初始化后，CPU应该去哪个地址继续执行指令。
>
> 您对这些概念的理解是正确的。这些细节对于理解计算机如何从零开始启动到加载操作系统是非常重要的。